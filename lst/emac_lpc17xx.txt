; generated by ARM C/C++ Compiler, 4.1 [Build 644]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\out\emac_lpc17xx.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\out\emac_lpc17xx.d --cpu=Cortex-M3 --apcs=interwork -I.\inc -I.\inc\file_system -I.\inc\IR -IC:\Keil\ARM\RL\TCPnet\Drivers -I.\inc\tcpip -IC:\Keil\ARM\CMSIS\Include -IC:\Keil\ARM\INC\NXP\LPC17xx -DLPC1700 -DFLASH_512 --omf_browse=.\out\emac_lpc17xx.crf src\tcpip\EMAC_LPC17xx.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  output_MDIO PROC
;;;793    
;;;794    static void output_MDIO (U32 val, U32 n) {
000000  b510              PUSH     {r4,lr}
;;;795      /* Output a value to the MII PHY management interface. */
;;;796    
;;;797      for (val <<= (32 - n); n; val <<= 1, n--) {
000002  f1c10220          RSB      r2,r1,#0x20
000006  4090              LSLS     r0,r0,r2
;;;798        if (val & 0x80000000) {
;;;799          LPC_GPIO2->FIOSET = MDIO;
000008  f44f7400          MOV      r4,#0x200
00000c  4aff              LDR      r2,|L1.1036|
;;;800        }
;;;801        else {
;;;802          LPC_GPIO2->FIOCLR = MDIO;
;;;803        }
;;;804        delay ();
;;;805        LPC_GPIO2->FIOSET = MDC;
00000e  1553              ASRS     r3,r2,#21
000010  e00e              B        |L1.48|
                  |L1.18|
000012  2800              CMP      r0,#0                 ;798
000014  da01              BGE      |L1.26|
000016  6594              STR      r4,[r2,#0x58]         ;799
000018  e000              B        |L1.28|
                  |L1.26|
00001a  65d4              STR      r4,[r2,#0x5c]         ;802
                  |L1.28|
00001c  bf00              NOP                            ;804
00001e  bf00              NOP                            ;804
000020  bf00              NOP                            ;804
000022  6593              STR      r3,[r2,#0x58]
;;;806        delay ();
000024  bf00              NOP      
000026  bf00              NOP      
000028  bf00              NOP      
;;;807        LPC_GPIO2->FIOCLR = MDC;
00002a  65d3              STR      r3,[r2,#0x5c]
00002c  0040              LSLS     r0,r0,#1              ;797
00002e  1e49              SUBS     r1,r1,#1              ;797
                  |L1.48|
000030  2900              CMP      r1,#0                 ;797
000032  d1ee              BNE      |L1.18|
;;;808      }
;;;809    }
000034  bd10              POP      {r4,pc}
;;;810    
                          ENDP

                  read_PHY PROC
;;;890    
;;;891    static U16 read_PHY (U32 PhyReg) {
000036  b570              PUSH     {r4-r6,lr}
000038  4604              MOV      r4,r0
;;;892      /* Read a PHY register 'PhyReg'. */
;;;893      U32 tout, val;
;;;894    
;;;895      if (dev_175x == __TRUE) {
00003a  48f5              LDR      r0,|L1.1040|
00003c  7800              LDRB     r0,[r0,#0]  ; dev_175x
00003e  2801              CMP      r0,#1
000040  d013              BEQ      |L1.106|
;;;896        /* Software MII Management for LPC175x. */
;;;897        /* Remapped MDC on P2.8 and MDIO on P2.9 does not work. */
;;;898        LPC_GPIO2->FIODIR |= MDIO;
;;;899    
;;;900        /* 32 consecutive ones on MDO to establish sync */
;;;901        output_MDIO (0xFFFFFFFF, 32);
;;;902    
;;;903        /* start code (01), read command (10) */
;;;904        output_MDIO (0x06, 4);
;;;905    
;;;906        /* write PHY address */
;;;907        output_MDIO (DP83848C_DEF_ADR >> 8, 5);
;;;908    
;;;909        /* write the PHY register to write */
;;;910        output_MDIO (PhyReg, 5);
;;;911    
;;;912        /* turnaround MDO is tristated */
;;;913        turnaround_MDIO ();
;;;914    
;;;915        /* read the data value */
;;;916        val = input_MDIO ();
;;;917    
;;;918        /* turnaround MDIO is tristated */
;;;919        turnaround_MDIO ();
;;;920      }
;;;921      else {
;;;922        LPC_EMAC->MADR = DP83848C_DEF_ADR | PhyReg;
000042  f04f41a0          MOV      r1,#0x50000000
000046  f4447080          ORR      r0,r4,#0x100
00004a  6288              STR      r0,[r1,#0x28]
;;;923        LPC_EMAC->MCMD = MCMD_READ;
00004c  2001              MOVS     r0,#1
00004e  6248              STR      r0,[r1,#0x24]
;;;924    
;;;925        /* Wait until operation completed */
;;;926        for (tout = 0; tout < MII_RD_TOUT; tout++) 
000050  2000              MOVS     r0,#0
000052  130b              ASRS     r3,r1,#12
                  |L1.84|
;;;927    	{
;;;928          if ((LPC_EMAC->MIND & MIND_BUSY) == 0) 
000054  6b4a              LDR      r2,[r1,#0x34]
000056  07d2              LSLS     r2,r2,#31
000058  d002              BEQ      |L1.96|
00005a  1c40              ADDS     r0,r0,#1              ;926
00005c  4298              CMP      r0,r3                 ;926
00005e  d3f9              BCC      |L1.84|
                  |L1.96|
;;;929    	  {
;;;930            break;
;;;931          }
;;;932        }
;;;933        LPC_EMAC->MCMD = 0;
000060  2000              MOVS     r0,#0
000062  6248              STR      r0,[r1,#0x24]
;;;934        val = LPC_EMAC->MRDD;
000064  6b0c              LDR      r4,[r1,#0x30]
                  |L1.102|
;;;935      }
;;;936      return (val);
000066  b2a0              UXTH     r0,r4
;;;937    }
000068  bd70              POP      {r4-r6,pc}
                  |L1.106|
00006a  4de8              LDR      r5,|L1.1036|
00006c  6c28              LDR      r0,[r5,#0x40]         ;898
00006e  f4407000          ORR      r0,r0,#0x200          ;898
000072  6428              STR      r0,[r5,#0x40]         ;898
000074  2120              MOVS     r1,#0x20              ;901
000076  f04f30ff          MOV      r0,#0xffffffff        ;901
00007a  f7fffffe          BL       output_MDIO
00007e  2104              MOVS     r1,#4                 ;904
000080  2006              MOVS     r0,#6                 ;904
000082  f7fffffe          BL       output_MDIO
000086  2105              MOVS     r1,#5                 ;907
000088  2001              MOVS     r0,#1                 ;907
00008a  f7fffffe          BL       output_MDIO
00008e  2105              MOVS     r1,#5                 ;910
000090  4620              MOV      r0,r4                 ;910
000092  f7fffffe          BL       output_MDIO
000096  f7fffffe          BL       turnaround_MDIO
00009a  f04f0400          MOV      r4,#0                 ;913
00009e  4620              MOV      r0,r4                 ;913
0000a0  f44f7180          MOV      r1,#0x100             ;913
                  |L1.164|
0000a4  ea4f0444          LSL      r4,r4,#1              ;913
0000a8  65a9              STR      r1,[r5,#0x58]         ;913
0000aa  bf00              NOP                            ;913
0000ac  bf00              NOP                            ;913
0000ae  bf00              NOP                            ;913
0000b0  65e9              STR      r1,[r5,#0x5c]         ;913
0000b2  6d6a              LDR      r2,[r5,#0x54]         ;913
0000b4  0592              LSLS     r2,r2,#22             ;913
0000b6  d501              BPL      |L1.188|
0000b8  f0440401          ORR      r4,r4,#1              ;913
                  |L1.188|
0000bc  1c40              ADDS     r0,r0,#1              ;913
0000be  2810              CMP      r0,#0x10              ;913
0000c0  d3f0              BCC      |L1.164|
0000c2  f7fffffe          BL       turnaround_MDIO
0000c6  e7ce              B        |L1.102|
;;;938    
                          ENDP

                  write_PHY PROC
;;;843    
;;;844    static void write_PHY (U32 PhyReg, U16 Value) {
0000c8  b570              PUSH     {r4-r6,lr}
0000ca  4605              MOV      r5,r0
;;;845      /* Write a data 'Value' to PHY register 'PhyReg'. */
;;;846      U32 tout;
;;;847    
;;;848      if (dev_175x == __TRUE) {
0000cc  48d0              LDR      r0,|L1.1040|
0000ce  460c              MOV      r4,r1                 ;844
0000d0  7800              LDRB     r0,[r0,#0]  ; dev_175x
0000d2  2801              CMP      r0,#1
0000d4  d00e              BEQ      |L1.244|
;;;849        /* Software MII Management for LPC175x. */
;;;850        /* Remapped MDC on P2.8 and MDIO on P2.9 do not work. */
;;;851        LPC_GPIO2->FIODIR |= MDIO;
;;;852    
;;;853        /* 32 consecutive ones on MDO to establish sync */
;;;854        output_MDIO (0xFFFFFFFF, 32);
;;;855    
;;;856        /* start code (01), write command (01) */
;;;857        output_MDIO (0x05, 4);
;;;858    
;;;859        /* write PHY address */
;;;860        output_MDIO (DP83848C_DEF_ADR >> 8, 5);
;;;861    
;;;862        /* write the PHY register to write */
;;;863        output_MDIO (PhyReg, 5);
;;;864    
;;;865        /* turnaround MDIO (1,0)*/
;;;866        output_MDIO (0x02, 2);
;;;867    
;;;868        /* write the data value */
;;;869        output_MDIO (Value, 16);
;;;870    
;;;871        /* turnaround MDO is tristated */
;;;872        turnaround_MDIO ();
;;;873      }
;;;874      else {
;;;875        /* Hardware MII Management for LPC176x devices. */
;;;876        LPC_EMAC->MADR = DP83848C_DEF_ADR | PhyReg;
0000d6  f04f42a0          MOV      r2,#0x50000000
0000da  f4457080          ORR      r0,r5,#0x100
0000de  6290              STR      r0,[r2,#0x28]
;;;877        LPC_EMAC->MWTD = Value;
0000e0  62d4              STR      r4,[r2,#0x2c]
;;;878    
;;;879        /* Wait utill operation completed */
;;;880        for (tout = 0; tout < MII_WR_TOUT; tout++) {
0000e2  2000              MOVS     r0,#0
0000e4  1313              ASRS     r3,r2,#12
                  |L1.230|
;;;881          if ((LPC_EMAC->MIND & MIND_BUSY) == 0) {
0000e6  6b51              LDR      r1,[r2,#0x34]
0000e8  07c9              LSLS     r1,r1,#31
0000ea  d002              BEQ      |L1.242|
0000ec  1c40              ADDS     r0,r0,#1              ;880
0000ee  4298              CMP      r0,r3                 ;880
0000f0  d3f9              BCC      |L1.230|
                  |L1.242|
;;;882            break;
;;;883          }
;;;884        }
;;;885      }
;;;886    }
0000f2  bd70              POP      {r4-r6,pc}
                  |L1.244|
0000f4  48c5              LDR      r0,|L1.1036|
0000f6  6c01              LDR      r1,[r0,#0x40]         ;851
0000f8  f4417100          ORR      r1,r1,#0x200          ;851
0000fc  6401              STR      r1,[r0,#0x40]         ;851
0000fe  2120              MOVS     r1,#0x20              ;854
000100  f04f30ff          MOV      r0,#0xffffffff        ;854
000104  f7fffffe          BL       output_MDIO
000108  2104              MOVS     r1,#4                 ;857
00010a  2005              MOVS     r0,#5                 ;857
00010c  f7fffffe          BL       output_MDIO
000110  2105              MOVS     r1,#5                 ;860
000112  2001              MOVS     r0,#1                 ;860
000114  f7fffffe          BL       output_MDIO
000118  2105              MOVS     r1,#5                 ;863
00011a  4628              MOV      r0,r5                 ;863
00011c  f7fffffe          BL       output_MDIO
000120  2102              MOVS     r1,#2                 ;866
000122  4608              MOV      r0,r1                 ;866
000124  f7fffffe          BL       output_MDIO
000128  2110              MOVS     r1,#0x10              ;869
00012a  4620              MOV      r0,r4                 ;869
00012c  f7fffffe          BL       output_MDIO
000130  e8bd4070          POP      {r4-r6,lr}            ;872
000134  f7ffbffe          B.W      turnaround_MDIO
;;;887    
                          ENDP

                  init_ethernet PROC
;;;280    
;;;281    void init_ethernet (void) {
000138  e92d47fc          PUSH     {r2-r10,lr}
;;;282      /* Initialize the EMAC ethernet controller. */
;;;283      U32 regv,tout,id1=id1 = 0,id2=id2 = 0;
;;;284      U32 pb[2];
;;;285    
;;;286      //printf("passo0\r\r");
;;;287      //fflush(stdout);
;;;288    
;;;289      dev_175x = __FALSE;
00013c  4db4              LDR      r5,|L1.1040|
00013e  2400              MOVS     r4,#0
;;;290      /* Read device ID with IAP*/
;;;291      pb[0] = 54;
000140  2036              MOVS     r0,#0x36
000142  702c              STRB     r4,[r5,#0]            ;289
;;;292      iap_entry (&pb[0], &pb[0]);
000144  9000              STR      r0,[sp,#0]
000146  4669              MOV      r1,sp
000148  686a              LDR      r2,[r5,#4]  ; iap_entry
00014a  4608              MOV      r0,r1
00014c  4790              BLX      r2
00014e  48b1              LDR      r0,|L1.1044|
;;;293      if ((pb[1] >> 24) == 0x25) {
;;;294        /* Use software RMII management routines. */
;;;295    //    dev_175x = __TRUE;
;;;296      }
;;;297    
;;;298      //printf("passo1\r\r");
;;;299      //fflush(stdout);
;;;300    
;;;301      /* Power Up the EMAC controller. */
;;;302      LPC_SC->PCONP |= 0x40000000;
000150  6801              LDR      r1,[r0,#0]
000152  f0414180          ORR      r1,r1,#0x40000000
000156  6001              STR      r1,[r0,#0]
;;;303    
;;;304      /* Enable P1 Ethernet Pins. */
;;;305      LPC_PINCON->PINSEL2 = 0x50150105;
000158  48b0              LDR      r0,|L1.1052|
00015a  49af              LDR      r1,|L1.1048|
00015c  6081              STR      r1,[r0,#8]
;;;306      if (dev_175x == __FALSE) {
00015e  7829              LDRB     r1,[r5,#0]  ; dev_175x
000160  2900              CMP      r1,#0
000162  d07d              BEQ      |L1.608|
;;;307        /* LPC176x devices, no MDIO, MDC remap. */
;;;308        LPC_PINCON->PINSEL3 = (LPC_PINCON->PINSEL3 & ~0x0000000F) | 0x00000005;
;;;309      }
;;;310      else {
;;;311        /* LPC175x devices, use software MII management. */  
;;;312        LPC_PINCON->PINSEL4 &= ~0x000F0000;
000164  6901              LDR      r1,[r0,#0x10]
000166  f4212170          BIC      r1,r1,#0xf0000
00016a  6101              STR      r1,[r0,#0x10]
;;;313        LPC_GPIO2->FIODIR |= MDC;
00016c  48a7              LDR      r0,|L1.1036|
00016e  6c01              LDR      r1,[r0,#0x40]
000170  f4417180          ORR      r1,r1,#0x100
000174  6401              STR      r1,[r0,#0x40]
                  |L1.374|
;;;314      }
;;;315    
;;;316        //printf("passo2\r\r");
;;;317      //fflush(stdout);
;;;318    
;;;319      /* Reset all EMAC internal modules. */
;;;320      LPC_EMAC->MAC1    = MAC1_RES_TX | MAC1_RES_MCS_TX | MAC1_RES_RX | 
000176  f04f45a0          MOV      r5,#0x50000000
00017a  f44f404f          MOV      r0,#0xcf00
00017e  6028              STR      r0,[r5,#0]
;;;321                          MAC1_RES_MCS_RX | MAC1_SIM_RES | MAC1_SOFT_RES;
;;;322      LPC_EMAC->Command = CR_REG_RES | CR_TX_RES | CR_RX_RES | CR_PASS_RUNT_FRM;
000180  2078              MOVS     r0,#0x78
000182  f8c50100          STR      r0,[r5,#0x100]
;;;323    
;;;324      /* A short delay after reset. */
;;;325      for (tout = 100; tout; tout--);
000186  2064              MOVS     r0,#0x64
                  |L1.392|
000188  1e40              SUBS     r0,r0,#1
00018a  d1fd              BNE      |L1.392|
;;;326    
;;;327      /* Initialize MAC control registers. */
;;;328      LPC_EMAC->MAC1 = MAC1_PASS_ALL;
00018c  f04f0902          MOV      r9,#2
000190  f8c59000          STR      r9,[r5,#0]
;;;329      LPC_EMAC->MAC2 = MAC2_CRC_EN | MAC2_PAD_EN;
000194  2030              MOVS     r0,#0x30
000196  6068              STR      r0,[r5,#4]
;;;330      LPC_EMAC->MAXF = ETH_MAX_FLEN;
000198  0140              LSLS     r0,r0,#5
00019a  6168              STR      r0,[r5,#0x14]
;;;331    	
;;;332      LPC_EMAC->MCFG = 0x8020;
00019c  f2480020          MOV      r0,#0x8020
0001a0  6228              STR      r0,[r5,#0x20]
;;;333      LPC_EMAC->MCFG &= ~(MCFG_RES_MII);
0001a2  6a28              LDR      r0,[r5,#0x20]
0001a4  f4204000          BIC      r0,r0,#0x8000
0001a8  6228              STR      r0,[r5,#0x20]
;;;334    	
;;;335      LPC_EMAC->CLRT = CLRT_DEF;
0001aa  f243700f          MOV      r0,#0x370f
0001ae  6128              STR      r0,[r5,#0x10]
;;;336      LPC_EMAC->IPGR = IPGR_DEF;
0001b0  f04f0812          MOV      r8,#0x12
0001b4  f8c5800c          STR      r8,[r5,#0xc]
;;;337    
;;;338      //printf("passo3\r\r");
;;;339      //fflush(stdout);
;;;340    
;;;341      /* Enable Reduced MII interface. */
;;;342      LPC_EMAC->Command = CR_RMII | CR_PASS_RUNT_FRM;
0001b8  f44f7010          MOV      r0,#0x240
0001bc  f8c50100          STR      r0,[r5,#0x100]
;;;343    
;;;344      /* Reset Reduced MII Logic. */
;;;345      LPC_EMAC->SUPP = SUPP_RES_RMII;
0001c0  f44f6000          MOV      r0,#0x800
0001c4  61a8              STR      r0,[r5,#0x18]
;;;346      for (tout = 100; tout; tout--);
0001c6  2664              MOVS     r6,#0x64
                  |L1.456|
0001c8  1e76              SUBS     r6,r6,#1
0001ca  d1fd              BNE      |L1.456|
;;;347      LPC_EMAC->SUPP = 0;
0001cc  61ac              STR      r4,[r5,#0x18]
;;;348    
;;;349      /* Put the DP83848C in reset mode */
;;;350      write_PHY (PHY_REG_BMCR, 0x8000);
0001ce  f44f4100          MOV      r1,#0x8000
0001d2  2000              MOVS     r0,#0
0001d4  f7fffffe          BL       write_PHY
;;;351      delay ();
0001d8  bf00              NOP      
0001da  bf00              NOP      
0001dc  bf00              NOP      
;;;352      delay ();
0001de  bf00              NOP      
0001e0  bf00              NOP      
0001e2  bf00              NOP      
;;;353      delay ();
0001e4  bf00              NOP      
0001e6  bf00              NOP      
0001e8  bf00              NOP      
;;;354    
;;;355      printf("[Ethernet Hardware Reset...Wait]\r");
0001ea  a08d              ADR      r0,|L1.1056|
0001ec  f7fffffe          BL       __2printf
;;;356      fflush(stdout);
0001f0  4894              LDR      r0,|L1.1092|
0001f2  f7fffffe          BL       fflush
;;;357    
;;;358      /* Wait for hardware reset to end. */
;;;359      for (tout = 0; tout < 0x100000; tout++) 
0001f6  f44f1780          MOV      r7,#0x100000
                  |L1.506|
;;;360      {
;;;361        regv = read_PHY (PHY_REG_BMCR);
0001fa  2000              MOVS     r0,#0
0001fc  f7fffffe          BL       read_PHY
;;;362        if (!(regv & 0x8000)) 
000200  0400              LSLS     r0,r0,#16
000202  d502              BPL      |L1.522|
000204  1c76              ADDS     r6,r6,#1              ;359
000206  42be              CMP      r6,r7                 ;359
000208  d3f7              BCC      |L1.506|
                  |L1.522|
;;;363    	{
;;;364          /* Reset complete, device not Power Down. */
;;;365          break;
;;;366        }
;;;367    
;;;368    //	wdt_feed();
;;;369    //	LED_PWR_TOG();
;;;370    //	if(!(tout % 5000))
;;;371    //	{
;;;372    //		printf("[%X...reg:%X]\r\r",tout,regv);
;;;373    //  		fflush(stdout);
;;;374    //	}
;;;375    
;;;376      }
;;;377    
;;;378      printf("[Ethernet Hardware...OK]\r");
00020a  a08f              ADR      r0,|L1.1096|
00020c  f7fffffe          BL       __2printf
;;;379      fflush(stdout);
000210  488c              LDR      r0,|L1.1092|
000212  f7fffffe          BL       fflush
;;;380    
;;;381      /* Check if this is a DP83848C PHY. */
;;;382    //  id1 = read_PHY (PHY_REG_IDR1);	//teste de leitura do mac
;;;383    //  id2 = read_PHY (PHY_REG_IDR2);	//teste deleitura do mac
;;;384    
;;;385      //printf("id1:%X...id2:%X\r\r",id1,id2);
;;;386      //fflush(stdout);
;;;387    
;;;388      delay ();
000216  bf00              NOP      
000218  bf00              NOP      
00021a  bf00              NOP      
;;;389      delay ();
00021c  bf00              NOP      
00021e  bf00              NOP      
000220  bf00              NOP      
;;;390      delay ();
000222  bf00              NOP      
000224  bf00              NOP      
000226  bf00              NOP      
;;;391      //printf("passo5\r\r");
;;;392      //fflush(stdout);
;;;393    
;;;394      if (1/*((id1 << 16) | (id2 & 0xFFF0)) == DP83848C_ID*/) {
;;;395        /* Configure the PHY device */
;;;396    #if defined (_10MBIT_)
;;;397        /* Connect at 10MBit */
;;;398        write_PHY (PHY_REG_BMCR, PHY_FULLD_10M);
;;;399    #elif defined (_100MBIT_)
;;;400        /* Connect at 100MBit */
;;;401        write_PHY (PHY_REG_BMCR, PHY_FULLD_100M);
;;;402    #else
;;;403        /* Use autonegotiation about the link speed. */
;;;404        write_PHY (PHY_REG_BMCR, 0x1000 /*PHY_AUTO_NEG*/);
000228  f44f5180          MOV      r1,#0x1000
00022c  2000              MOVS     r0,#0
00022e  f7fffffe          BL       write_PHY
;;;405        /* Wait to complete Auto_Negotiation. */
;;;406        for (tout = /*0x100000*/  0x10000; tout; tout--) {
000232  f44f3680          MOV      r6,#0x10000
                  |L1.566|
;;;407          regv = read_PHY (PHY_REG_BMSR);
000236  2001              MOVS     r0,#1
000238  f7fffffe          BL       read_PHY
00023c  4607              MOV      r7,r0
;;;408          if (regv & 0x0020) 
00023e  0680              LSLS     r0,r0,#26
000240  d401              BMI      |L1.582|
000242  1e76              SUBS     r6,r6,#1              ;406
000244  d1f7              BNE      |L1.566|
                  |L1.582|
;;;409    	  {
;;;410    	  		//printf("Autonegotiation Complete\r");
;;;411    			//fflush(stdout);
;;;412            /* Autonegotiation Complete. */
;;;413            break;
;;;414          }
;;;415        }
;;;416    		
;;;417    		if (tout == 0){
;;;418    			// Time out, return error
;;;419    		}
;;;420    #endif
;;;421      }
;;;422    
;;;423      delay ();
000246  bf00              NOP      
000248  bf00              NOP      
00024a  bf00              NOP      
;;;424      delay ();
00024c  bf00              NOP      
00024e  bf00              NOP      
000250  bf00              NOP      
;;;425      delay ();
000252  bf00              NOP      
000254  bf00              NOP      
000256  bf00              NOP      
;;;426    
;;;427      //   printf("passo6\r\r");
;;;428      //fflush(stdout);
;;;429    
;;;430      /* Configure Full/Half Duplex mode. */
;;;431      if (regv & 0x0004) {
000258  0778              LSLS     r0,r7,#29
00025a  d515              BPL      |L1.648|
;;;432        /* Full duplex is enabled. */
;;;433        LPC_EMAC->MAC2    |= MAC2_FULL_DUP;
00025c  6868              LDR      r0,[r5,#4]
00025e  e000              B        |L1.610|
                  |L1.608|
000260  e00c              B        |L1.636|
                  |L1.610|
000262  f0400001          ORR      r0,r0,#1
000266  6068              STR      r0,[r5,#4]
;;;434        LPC_EMAC->Command |= CR_FULL_DUP;
000268  f8d50100          LDR      r0,[r5,#0x100]
00026c  f4406080          ORR      r0,r0,#0x400
000270  f8c50100          STR      r0,[r5,#0x100]
;;;435        LPC_EMAC->IPGT     = IPGT_FULL_DUP;
000274  2015              MOVS     r0,#0x15
000276  60a8              STR      r0,[r5,#8]
;;;436    	printf("[Ethernet Full Duplex]\r");
000278  a07a              ADR      r0,|L1.1124|
00027a  e008              B        |L1.654|
                  |L1.636|
00027c  68c1              LDR      r1,[r0,#0xc]          ;308
00027e  f021010f          BIC      r1,r1,#0xf            ;308
000282  1d49              ADDS     r1,r1,#5              ;308
000284  60c1              STR      r1,[r0,#0xc]          ;308
000286  e776              B        |L1.374|
                  |L1.648|
;;;437      }
;;;438      else {
;;;439        /* Half duplex mode. */
;;;440        LPC_EMAC->IPGT = IPGT_HALF_DUP;
000288  f8c58008          STR      r8,[r5,#8]
;;;441    	printf("[Ethernet Half Duplex]\r");  	
00028c  a07b              ADR      r0,|L1.1148|
                  |L1.654|
00028e  f7fffffe          BL       __2printf
;;;442      }
;;;443    
;;;444      fflush(stdout);
000292  486c              LDR      r0,|L1.1092|
000294  f7fffffe          BL       fflush
;;;445      delay ();
000298  bf00              NOP      
00029a  bf00              NOP      
00029c  bf00              NOP      
;;;446      delay ();
00029e  bf00              NOP      
0002a0  bf00              NOP      
0002a2  bf00              NOP      
;;;447      delay ();
0002a4  bf00              NOP      
0002a6  bf00              NOP      
0002a8  bf00              NOP      
;;;448      //printf("passo7\r\r");
;;;449      //fflush(stdout);
;;;450    
;;;451      /* Configure 100MBit/10MBit mode. */
;;;452      if (regv & 0x0002) {
0002aa  07b8              LSLS     r0,r7,#30
0002ac  d502              BPL      |L1.692|
;;;453        /* 10MBit mode. */
;;;454        LPC_EMAC->SUPP = 0;
0002ae  61ac              STR      r4,[r5,#0x18]
;;;455    	printf("[Ethernet 10Mbit mode]\r\r");
0002b0  a078              ADR      r0,|L1.1172|
0002b2  e003              B        |L1.700|
                  |L1.692|
;;;456      }
;;;457      else {
;;;458        /* 100MBit mode. */
;;;459        LPC_EMAC->SUPP = SUPP_SPEED;
0002b4  f44f7080          MOV      r0,#0x100
0002b8  61a8              STR      r0,[r5,#0x18]
;;;460    	printf("[Ethernet 100Mbit mode]\r\r"); 	
0002ba  a07d              ADR      r0,|L1.1200|
                  |L1.700|
0002bc  f7fffffe          BL       __2printf
;;;461      }
;;;462    	fflush(stdout);	
0002c0  4860              LDR      r0,|L1.1092|
0002c2  f7fffffe          BL       fflush
;;;463    	
;;;464    	 /* Check the link status. */
;;;465    ////   for (tout = 0; tout < 0x10000; tout++) {
;;;466    ////     regv = read_PHY (PHY_REG_STS);
;;;467    ////     if (regv & 0x0001) {
;;;468    ////       /* Link is on. */
;;;469    ////       break;
;;;470    ////     }
;;;471    ////   }
;;;472    
;;;473    
;;;474    //	for (tout = 0; tout < 0x10000; tout++) 
;;;475    //	{
;;;476    //    	regv = read_PHY (PHY_REG_BMSR);
;;;477    //    	if (regv & (1<<2)) 
;;;478    //		{
;;;479    //      		/* Link is on. */
;;;480    //			//printf("Link is on 2\r");
;;;481    //			//fflush(stdout);
;;;482    //      		break;
;;;483    //    	}
;;;484    //	}
;;;485    
;;;486    
;;;487      //printf("Antes...SA0:%X...SA1:%X...SA2:%X\r\r",LPC_EMAC->SA0,LPC_EMAC->SA1,LPC_EMAC->SA2);
;;;488      //fflush(stdout);
;;;489    
;;;490      /* Set the Ethernet MAC Address registers */
;;;491      LPC_EMAC->SA0 = ((U32)own_hw_adr[5] << 8) | (U32)own_hw_adr[4];
0002c6  4881              LDR      r0,|L1.1228|
0002c8  8881              LDRH     r1,[r0,#4]  ; own_hw_adr
0002ca  6429              STR      r1,[r5,#0x40]
;;;492      LPC_EMAC->SA1 = ((U32)own_hw_adr[3] << 8) | (U32)own_hw_adr[2];
0002cc  8841              LDRH     r1,[r0,#2]  ; own_hw_adr
0002ce  6469              STR      r1,[r5,#0x44]
;;;493      LPC_EMAC->SA2 = ((U32)own_hw_adr[1] << 8) | (U32)own_hw_adr[0];
0002d0  8800              LDRH     r0,[r0,#0]  ; own_hw_adr
0002d2  64a8              STR      r0,[r5,#0x48]
0002d4  4b7e              LDR      r3,|L1.1232|
0002d6  4e7f              LDR      r6,|L1.1236|
0002d8  f1a30264          SUB      r2,r3,#0x64
0002dc  2000              MOVS     r0,#0
0002de  f1020120          ADD      r1,r2,#0x20
                  |L1.738|
0002e2  eb000740          ADD      r7,r0,r0,LSL #1
0002e6  eb032747          ADD      r7,r3,r7,LSL #9
0002ea  f8427030          STR      r7,[r2,r0,LSL #3]
0002ee  eb0207c0          ADD      r7,r2,r0,LSL #3
0002f2  607e              STR      r6,[r7,#4]
0002f4  f8414030          STR      r4,[r1,r0,LSL #3]
0002f8  eb0107c0          ADD      r7,r1,r0,LSL #3
0002fc  1c40              ADDS     r0,r0,#1
0002fe  607c              STR      r4,[r7,#4]
000300  2804              CMP      r0,#4
000302  d3ee              BCC      |L1.738|
000304  f8c52108          STR      r2,[r5,#0x108]
000308  f8c5110c          STR      r1,[r5,#0x10c]
00030c  2003              MOVS     r0,#3
00030e  f8c50110          STR      r0,[r5,#0x110]
000312  f8c54118          STR      r4,[r5,#0x118]
000316  496e              LDR      r1,|L1.1232|
000318  2000              MOVS     r0,#0
00031a  4e6f              LDR      r6,|L1.1240|
00031c  3924              SUBS     r1,r1,#0x24
00031e  f1010318          ADD      r3,r1,#0x18
                  |L1.802|
000322  eb000240          ADD      r2,r0,r0,LSL #1
000326  eb062242          ADD      r2,r6,r2,LSL #9
00032a  f8412030          STR      r2,[r1,r0,LSL #3]
00032e  eb0102c0          ADD      r2,r1,r0,LSL #3
000332  6054              STR      r4,[r2,#4]
000334  f8434020          STR      r4,[r3,r0,LSL #2]
000338  1c40              ADDS     r0,r0,#1
00033a  2803              CMP      r0,#3
00033c  d3f1              BCC      |L1.802|
00033e  f10505ac          ADD      r5,r5,#0xac
000342  6729              STR      r1,[r5,#0x70]
000344  676b              STR      r3,[r5,#0x74]
000346  f8c59078          STR      r9,[r5,#0x78]
00034a  67ec              STR      r4,[r5,#0x7c]
;;;494    
;;;495      //printf("Depois...SA0:%X...SA1:%X...SA2:%X\r\r",LPC_EMAC->SA0,LPC_EMAC->SA1,LPC_EMAC->SA2);
;;;496      //fflush(stdout);
;;;497    
;;;498      /* Initialize Tx and Rx DMA Descriptors */
;;;499      rx_descr_init ();
;;;500      tx_descr_init ();
;;;501    
;;;502      /* Receive Broadcast, Multicast and Perfect Match Packets */
;;;503      LPC_EMAC->RxFilterCtrl = RFC_MCAST_EN | RFC_BCAST_EN | RFC_PERFECT_EN;
00034c  f04f0026          MOV      r0,#0x26
000350  f8c50154          STR      r0,[r5,#0x154]
;;;504    
;;;505      /* Enable EMAC interrupts. */
;;;506      LPC_EMAC->IntEnable = INT_RX_DONE | INT_TX_DONE;
000354  f04f0088          MOV      r0,#0x88
000358  f8c50f38          STR      r0,[r5,#0xf38]
;;;507    
;;;508      /* Reset all interrupts */
;;;509      LPC_EMAC->IntClear  = 0xFFFF;
00035c  f64f70ff          MOV      r0,#0xffff
000360  f8c50f3c          STR      r0,[r5,#0xf3c]
;;;510    
;;;511      /* Enable receive and transmit mode of MAC Ethernet core */
;;;512      LPC_EMAC->Command  |= (CR_RX_EN | CR_TX_EN);
000364  6d68              LDR      r0,[r5,#0x54]
000366  f0400003          ORR      r0,r0,#3
00036a  6568              STR      r0,[r5,#0x54]
;;;513      LPC_EMAC->MAC1     |= MAC1_REC_EN;
00036c  f8550dac          LDR      r0,[r5,#-0xac]!
000370  f0400001          ORR      r0,r0,#1
000374  6028              STR      r0,[r5,#0]
;;;514    
;;;515    }
000376  e8bd87fc          POP      {r2-r10,pc}
;;;516    
                          ENDP

                  int_enable_eth PROC
;;;659    
;;;660    void int_enable_eth (void) {
00037a  4858              LDR      r0,|L1.1244|
00037c  f04f5180          MOV      r1,#0x10000000
000380  6001              STR      r1,[r0,#0]
;;;661      /* Ethernet Interrupt Enable function. */
;;;662      NVIC_EnableIRQ(ENET_IRQn);
;;;663    }
000382  4770              BX       lr
;;;664    
                          ENDP

                  int_disable_eth PROC
;;;667    
;;;668    void int_disable_eth (void) {
000384  4856              LDR      r0,|L1.1248|
000386  f04f5180          MOV      r1,#0x10000000
00038a  6001              STR      r1,[r0,#0]
;;;669      /* Ethernet Interrupt Disable function. */
;;;670      NVIC_DisableIRQ(ENET_IRQn);
;;;671    }
00038c  4770              BX       lr
;;;672    
                          ENDP

                  send_frame PROC
;;;675    
;;;676    void send_frame (OS_FRAME *frame) {
00038e  b5f0              PUSH     {r4-r7,lr}
;;;677      /* Send frame to EMAC ethernet controller */
;;;678      U32 idx,len;
;;;679      U32 *sp,*dp;
;;;680    
;;;681      idx = LPC_EMAC->TxProduceIndex;
000390  f04f45a0          MOV      r5,#0x50000000
000394  f8d54128          LDR      r4,[r5,#0x128]
;;;682      sp  = (U32 *)&frame->data[0];
;;;683      dp  = (U32 *)Tx_Desc[idx].Packet;
000398  4e4d              LDR      r6,|L1.1232|
;;;684    
;;;685      /* Copy frame data to EMAC packet buffers. */
;;;686      for (len = (frame->length + 3) >> 2; len; len--) {
00039a  8801              LDRH     r1,[r0,#0]
00039c  3e24              SUBS     r6,r6,#0x24           ;683
00039e  1d02              ADDS     r2,r0,#4              ;682
0003a0  f8563034          LDR      r3,[r6,r4,LSL #3]     ;683
0003a4  1cc9              ADDS     r1,r1,#3
0003a6  0889              LSRS     r1,r1,#2
0003a8  d003              BEQ      |L1.946|
                  |L1.938|
;;;687        *dp++ = *sp++;
0003aa  ca80              LDM      r2!,{r7}
0003ac  1e49              SUBS     r1,r1,#1              ;686
0003ae  c380              STM      r3!,{r7}
0003b0  d1fb              BNE      |L1.938|
                  |L1.946|
;;;688      }
;;;689      Tx_Desc[idx].Ctrl = (frame->length-1) | (TCTRL_INT | TCTRL_LAST);
0003b2  8800              LDRH     r0,[r0,#0]
0003b4  eb0601c4          ADD      r1,r6,r4,LSL #3
0003b8  1e40              SUBS     r0,r0,#1
0003ba  f0404040          ORR      r0,r0,#0xc0000000
;;;690    
;;;691      /* Start frame transmission. */
;;;692      if (++idx == NUM_TX_FRAG) idx = 0;
0003be  1c64              ADDS     r4,r4,#1
0003c0  6048              STR      r0,[r1,#4]
0003c2  2c03              CMP      r4,#3
0003c4  d100              BNE      |L1.968|
0003c6  2400              MOVS     r4,#0
                  |L1.968|
;;;693      LPC_EMAC->TxProduceIndex = idx;
0003c8  f8c54128          STR      r4,[r5,#0x128]
;;;694    }
0003cc  bdf0              POP      {r4-r7,pc}
;;;695    
                          ENDP

                  ENET_IRQHandler PROC
;;;698    
;;;699    void ENET_IRQHandler (void) {
0003ce  b570              PUSH     {r4-r6,lr}
;;;700      /* EMAC Ethernet Controller Interrupt function. */
;;;701      OS_FRAME *frame;
;;;702      U32 idx,int_stat,RxLen,info;
;;;703      U32 *sp,*dp;
;;;704    
;;;705      while ((int_stat = (LPC_EMAC->IntStatus & LPC_EMAC->IntEnable)) != 0) {
;;;706        LPC_EMAC->IntClear = int_stat;
0003d0  f04f46a0          MOV      r6,#0x50000000
0003d4  e0a4              B        |L1.1312|
                  |L1.982|
0003d6  f8c60fe8          STR      r0,[r6,#0xfe8]
;;;707        if (int_stat & INT_RX_DONE) {
0003da  0700              LSLS     r0,r0,#28
0003dc  d515              BPL      |L1.1034|
;;;708          /* Packet received, check if packet is valid. */
;;;709          idx = LPC_EMAC->RxConsumeIndex;
0003de  f8d64118          LDR      r4,[r6,#0x118]
;;;710          while (idx != LPC_EMAC->RxProduceIndex) {
0003e2  e098              B        |L1.1302|
                  |L1.996|
;;;711            info = Rx_Stat[idx].Info;
0003e4  483a              LDR      r0,|L1.1232|
0003e6  3844              SUBS     r0,r0,#0x44
0003e8  f8500034          LDR      r0,[r0,r4,LSL #3]
;;;712            if (!(info & RINFO_LAST_FLAG)) {
0003ec  0041              LSLS     r1,r0,#1
0003ee  d57b              BPL      |L1.1256|
;;;713              goto rel;
;;;714            }
;;;715    
;;;716            RxLen = (info & RINFO_SIZE) - 3;
0003f0  f3c0050a          UBFX     r5,r0,#0,#11
0003f4  1eed              SUBS     r5,r5,#3
;;;717            if (RxLen > ETH_MTU || (info & RINFO_ERR_MASK)) {
0003f6  f24051ea          MOV      r1,#0x5ea
0003fa  428d              CMP      r5,r1
0003fc  d874              BHI      |L1.1256|
0003fe  4939              LDR      r1,|L1.1252|
000400  4208              TST      r0,r1
000402  d171              BNE      |L1.1256|
;;;718              /* Invalid frame, ignore it and free buffer. */
;;;719              goto rel;
;;;720            }
;;;721            /* Flag 0x80000000 to skip sys_error() call when out of memory. */
;;;722            frame = alloc_mem (RxLen | 0x80000000);
000404  f0454000          ORR      r0,r5,#0x80000000
000408  e06f              B        |L1.1258|
                  |L1.1034|
00040a  e089              B        |L1.1312|
                  |L1.1036|
                          DCD      0x2009c000
                  |L1.1040|
                          DCD      ||.data||
                  |L1.1044|
                          DCD      0x400fc0c4
                  |L1.1048|
                          DCD      0x50150105
                  |L1.1052|
                          DCD      0x4002c000
                  |L1.1056|
000420  5b457468          DCB      "[Ethernet Hardware Reset...Wait]\r",0
000424  65726e65
000428  74204861
00042c  72647761
000430  72652052
000434  65736574
000438  2e2e2e57
00043c  6169745d
000440  0d00    
000442  00                DCB      0
000443  00                DCB      0
                  |L1.1092|
                          DCD      __stdout
                  |L1.1096|
000448  5b457468          DCB      "[Ethernet Hardware...OK]\r",0
00044c  65726e65
000450  74204861
000454  72647761
000458  72652e2e
00045c  2e4f4b5d
000460  0d00    
000462  00                DCB      0
000463  00                DCB      0
                  |L1.1124|
000464  5b457468          DCB      "[Ethernet Full Duplex]\r",0
000468  65726e65
00046c  74204675
000470  6c6c2044
000474  75706c65
000478  785d0d00
                  |L1.1148|
00047c  5b457468          DCB      "[Ethernet Half Duplex]\r",0
000480  65726e65
000484  74204861
000488  6c662044
00048c  75706c65
000490  785d0d00
                  |L1.1172|
000494  5b457468          DCB      "[Ethernet 10Mbit mode]\r\r",0
000498  65726e65
00049c  74203130
0004a0  4d626974
0004a4  206d6f64
0004a8  655d0d0d
0004ac  00      
0004ad  00                DCB      0
0004ae  00                DCB      0
0004af  00                DCB      0
                  |L1.1200|
0004b0  5b457468          DCB      "[Ethernet 100Mbit mode]\r\r",0
0004b4  65726e65
0004b8  74203130
0004bc  304d6269
0004c0  74206d6f
0004c4  64655d0d
0004c8  0d00    
0004ca  00                DCB      0
0004cb  00                DCB      0
                  |L1.1228|
                          DCD      own_hw_adr
                  |L1.1232|
                          DCD      ||.bss||+0x64
                  |L1.1236|
                          DCD      0x800005ff
                  |L1.1240|
                          DCD      ||.bss||+0x1864
                  |L1.1244|
                          DCD      0xe000e100
                  |L1.1248|
                          DCD      0xe000e180
                  |L1.1252|
                          DCD      0x1b900000
                  |L1.1256|
0004e8  e00f              B        |L1.1290|
                  |L1.1258|
0004ea  f7fffffe          BL       alloc_mem
;;;723            /* if 'alloc_mem()' has failed, ignore this packet. */
;;;724            if (frame != NULL) {
0004ee  b160              CBZ      r0,|L1.1290|
;;;725              dp = (U32 *)&frame->data[0];
;;;726              sp = (U32 *)Rx_Desc[idx].Packet;
0004f0  4917              LDR      r1,|L1.1360|
0004f2  1d02              ADDS     r2,r0,#4              ;725
;;;727              for (RxLen = (RxLen + 3) >> 2; RxLen; RxLen--) {
0004f4  1ced              ADDS     r5,r5,#3
0004f6  f8513034          LDR      r3,[r1,r4,LSL #3]     ;726
0004fa  08a9              LSRS     r1,r5,#2
0004fc  d003              BEQ      |L1.1286|
                  |L1.1278|
;;;728                *dp++ = *sp++;
0004fe  cb20              LDM      r3!,{r5}
000500  1e49              SUBS     r1,r1,#1              ;727
000502  c220              STM      r2!,{r5}
000504  d1fb              BNE      |L1.1278|
                  |L1.1286|
;;;729              }
;;;730              put_in_queue (frame);
000506  f7fffffe          BL       put_in_queue
                  |L1.1290|
;;;731            }
;;;732    rel:    if (++idx == NUM_RX_FRAG) idx = 0;
00050a  1c64              ADDS     r4,r4,#1
00050c  2c04              CMP      r4,#4
00050e  d100              BNE      |L1.1298|
000510  2400              MOVS     r4,#0
                  |L1.1298|
;;;733            /* Release frame from EMAC buffer. */
;;;734            LPC_EMAC->RxConsumeIndex = idx;
000512  f8c64118          STR      r4,[r6,#0x118]
                  |L1.1302|
000516  f8d60114          LDR      r0,[r6,#0x114]        ;710
00051a  42a0              CMP      r0,r4                 ;710
00051c  f47faf62          BNE      |L1.996|
                  |L1.1312|
000520  f8d60fe0          LDR      r0,[r6,#0xfe0]        ;705
000524  f8d61fe4          LDR      r1,[r6,#0xfe4]        ;705
000528  4008              ANDS     r0,r0,r1              ;705
00052a  f47faf54          BNE      |L1.982|
;;;735          }
;;;736        }
;;;737        if (int_stat & INT_TX_DONE) {
;;;738          /* Frame transmit completed. */
;;;739        }
;;;740      }
;;;741    
;;;742    }
00052e  bd70              POP      {r4-r6,pc}
;;;743    
                          ENDP

                  turnaround_MDIO PROC
;;;812    
;;;813    static void turnaround_MDIO (void) {
000530  4808              LDR      r0,|L1.1364|
;;;814      /* Turnaround MDO is tristated. */
;;;815    
;;;816      LPC_GPIO2->FIODIR &= ~MDIO;
000532  6c01              LDR      r1,[r0,#0x40]
000534  f4217100          BIC      r1,r1,#0x200
000538  6401              STR      r1,[r0,#0x40]
;;;817      LPC_GPIO2->FIOSET  = MDC;
00053a  f44f7180          MOV      r1,#0x100
00053e  6581              STR      r1,[r0,#0x58]
;;;818      delay ();
000540  bf00              NOP      
000542  bf00              NOP      
000544  bf00              NOP      
;;;819      LPC_GPIO2->FIOCLR  = MDC;
000546  65c1              STR      r1,[r0,#0x5c]
;;;820      delay ();
000548  bf00              NOP      
00054a  bf00              NOP      
00054c  bf00              NOP      
;;;821    }
00054e  4770              BX       lr
;;;822    
                          ENDP

                  |L1.1360|
                          DCD      ||.bss||
                  |L1.1364|
                          DCD      0x2009c000

                          AREA ||.bss||, DATA, NOINIT, ALIGN=3

                  Rx_Desc
                          %        32
                  Rx_Stat
                          %        32
                  Tx_Desc
                          %        24
                  Tx_Stat
                          %        12
                  rx_buf
                          %        6144
                  tx_buf
                          %        4608

                          AREA ||.data||, DATA, ALIGN=2

                  dev_175x
000000  00000000          DCB      0x00,0x00,0x00,0x00
                  iap_entry
                          DCD      0x1fff1ff1
