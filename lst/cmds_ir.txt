; generated by ARM C/C++ Compiler, 4.1 [Build 644]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\out\cmds_ir.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\out\cmds_ir.d --cpu=Cortex-M3 --apcs=interwork -I.\inc -I.\inc\file_system -I.\inc\IR -IC:\Keil\ARM\RL\TCPnet\Drivers -I.\inc\tcpip -IC:\Keil\ARM\CMSIS\Include -IC:\Keil\ARM\INC\NXP\LPC17xx -DLPC1700 -DFLASH_512 --omf_browse=.\out\cmds_ir.crf src\IR\cmds_ir.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_u
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_flags
                          REQUIRE _printf_widthprec
                  get_addr_channel PROC
;;;35     *****************************************************************************/
;;;36     char get_addr_channel(char *str)
000000  b510              PUSH     {r4,lr}
;;;37     {
000002  b090              SUB      sp,sp,#0x40
000004  4604              MOV      r4,r0
;;;38     	char string[20];
;;;39     	char str_addr_ir[20];
;;;40     	char str_port_ir[20];
;;;41     	char i,j;
;;;42     	
;;;43     	/*Limpa todas as variaveis que irão armazenar os dados*/	 		
;;;44     	memset(string     ,0,sizeof(string));
000006  2114              MOVS     r1,#0x14
000008  a80a              ADD      r0,sp,#0x28
00000a  f7fffffe          BL       __aeabi_memclr4
;;;45     	memset(str_addr_ir,0,sizeof(str_addr_ir));
00000e  2114              MOVS     r1,#0x14
000010  4668              MOV      r0,sp
000012  f7fffffe          BL       __aeabi_memclr4
;;;46     	memset(str_port_ir,0,sizeof(str_port_ir));
000016  2114              MOVS     r1,#0x14
000018  a805              ADD      r0,sp,#0x14
00001a  f7fffffe          BL       __aeabi_memclr4
;;;47     	strcpy(string,str);
00001e  4621              MOV      r1,r4
000020  a80a              ADD      r0,sp,#0x28
000022  f7fffffe          BL       strcpy
;;;48     
;;;49     	/*Loop para armazenar o endereço do IR*/
;;;50     	for(j=0;j<20;j++)			
000026  2000              MOVS     r0,#0
000028  4602              MOV      r2,r0
00002a  466c              MOV      r4,sp                 ;39
00002c  ab0a              ADD      r3,sp,#0x28           ;38
                  |L1.46|
;;;51     	{
;;;52     		if(string[j] != ':')
00002e  5c19              LDRB     r1,[r3,r0]
000030  293a              CMP      r1,#0x3a
000032  d009              BEQ      |L1.72|
;;;53     		{
;;;54     			if(string[j] < '0' || string[j] > '9')
000034  3930              SUBS     r1,r1,#0x30
000036  290a              CMP      r1,#0xa
000038  d300              BCC      |L1.60|
;;;55     				string[j] = 0;
00003a  541a              STRB     r2,[r3,r0]
                  |L1.60|
;;;56     			str_addr_ir[j] = string[j];
00003c  5c19              LDRB     r1,[r3,r0]
00003e  5421              STRB     r1,[r4,r0]
000040  1c40              ADDS     r0,r0,#1              ;50
000042  b2c0              UXTB     r0,r0                 ;50
000044  2814              CMP      r0,#0x14              ;50
000046  d3f2              BCC      |L1.46|
                  |L1.72|
;;;57     		}else	
;;;58     			break;
;;;59     	}
;;;60     
;;;61     	/*Loop para armazenar a porta do IR*/			
;;;62     	for(i=0,j++;i<20;i++,j++) 						
000048  2100              MOVS     r1,#0
00004a  1c40              ADDS     r0,r0,#1
00004c  b2c0              UXTB     r0,r0
00004e  ac05              ADD      r4,sp,#0x14           ;40
                  |L1.80|
;;;63     		if(string[j] != '\r' && string[j] != '\n')
000050  5c1a              LDRB     r2,[r3,r0]
000052  2a0d              CMP      r2,#0xd
000054  d008              BEQ      |L1.104|
000056  2a0a              CMP      r2,#0xa
000058  d006              BEQ      |L1.104|
;;;64     			str_port_ir[i] = string[j];
00005a  5462              STRB     r2,[r4,r1]
00005c  1c49              ADDS     r1,r1,#1              ;62
00005e  1c40              ADDS     r0,r0,#1              ;62
000060  b2c9              UXTB     r1,r1                 ;62
000062  b2c0              UXTB     r0,r0                 ;62
000064  2914              CMP      r1,#0x14              ;62
000066  d3f3              BCC      |L1.80|
                  |L1.104|
;;;65     		else 
;;;66     			break;
;;;67     
;;;68     	/*Converte para inteiro endereço e porta recebidas pela função como string*/
;;;69     	rcv_addr_ir = atoi(str_addr_ir);
000068  4668              MOV      r0,sp
00006a  f7fffffe          BL       atoi
00006e  4c80              LDR      r4,|L1.624|
000070  8060              STRH     r0,[r4,#2]
;;;70     	rcv_port_ir = atoi(str_port_ir);
000072  a805              ADD      r0,sp,#0x14
000074  f7fffffe          BL       atoi
000078  b2c0              UXTB     r0,r0
00007a  7020              STRB     r0,[r4,#0]
;;;71     
;;;72     	/*Analisa possiveis erros de parâmetro*/
;;;73     	if(str_port_ir[0] == '?')
00007c  f89d1014          LDRB     r1,[sp,#0x14]
000080  293f              CMP      r1,#0x3f
000082  d00d              BEQ      |L1.160|
;;;74     		/*Retorna valor que informa que está sendo requisitado a porta do IR de endereço recebido*/ 
;;;75     		return 2;
;;;76     	if(rcv_port_ir>16 || rcv_port_ir == 0 || rcv_addr_ir>=MAX_QTD_IR || str_addr_ir[0] == 0 || str_port_ir[0] == 0)
000084  2810              CMP      r0,#0x10
000086  d80d              BHI      |L1.164|
000088  b160              CBZ      r0,|L1.164|
00008a  8860              LDRH     r0,[r4,#2]  ; rcv_addr_ir
00008c  f5b06f1b          CMP      r0,#0x9b0
000090  d208              BCS      |L1.164|
000092  f89d0000          LDRB     r0,[sp,#0]
000096  b128              CBZ      r0,|L1.164|
000098  b121              CBZ      r1,|L1.164|
;;;77     		/*Erro encontrado*/	
;;;78     		return 0;
;;;79     	else
;;;80     		/*Nenhum erro encontrado*/
;;;81     		return 1;
00009a  2001              MOVS     r0,#1
                  |L1.156|
;;;82     }
00009c  b010              ADD      sp,sp,#0x40
00009e  bd10              POP      {r4,pc}
                  |L1.160|
0000a0  2002              MOVS     r0,#2                 ;75
0000a2  e7fb              B        |L1.156|
                  |L1.164|
0000a4  2000              MOVS     r0,#0                 ;78
0000a6  e7f9              B        |L1.156|
;;;83     /****************************************************************************
                          ENDP

                  cmd_ir_learn PROC
;;;85     ****************************************************************************/
;;;86     void cmd_ir_learn(char *par)
0000a8  b510              PUSH     {r4,lr}
;;;87     {
;;;88     	char j;
;;;89     
;;;90     	/*Chama função que retorna se o endereço e a porta do IR estão corretos*/
;;;91     	if(get_addr_channel(par))
0000aa  f7fffffe          BL       get_addr_channel
0000ae  b1c8              CBZ      r0,|L1.228|
;;;92     	{
;;;93     		/*Endereço e porta corretos. Chama função para lê o IR. A função retornará valor que indicará
;;;94     		  se houve erro na leitura do IR*/
;;;95     		j = learn_ir(rcv_addr_ir,rcv_port_ir,FILE_INDEX_INFRARED);	
0000b0  4c6f              LDR      r4,|L1.624|
0000b2  2200              MOVS     r2,#0
0000b4  7821              LDRB     r1,[r4,#0]  ; rcv_port_ir
0000b6  8860              LDRH     r0,[r4,#2]  ; rcv_addr_ir
0000b8  f7fffffe          BL       learn_ir
0000bc  4602              MOV      r2,r0
;;;96     		if(j == ERROR_TIMEOUT || j == ERROR_RECEIVER_IR || j == ERROR_OVERFLOW_PULSES_IR || j == ERROR_OVERFLOW_FLASH || j == ERROR_NOT_SAVED)
0000be  2803              CMP      r0,#3
0000c0  d00e              BEQ      |L1.224|
0000c2  2a04              CMP      r2,#4
0000c4  d00c              BEQ      |L1.224|
0000c6  2a05              CMP      r2,#5
0000c8  d00a              BEQ      |L1.224|
0000ca  2a06              CMP      r2,#6
0000cc  d008              BEQ      |L1.224|
0000ce  2a0b              CMP      r2,#0xb
0000d0  d006              BEQ      |L1.224|
;;;97     			sprintf(buf_tx,"ERROR %u",j);
;;;98     		else
;;;99     			sprintf(buf_tx,"OK %u",rcv_addr_ir);	/*IR salvo na memoria flash*/			
0000d2  8862              LDRH     r2,[r4,#2]  ; rcv_addr_ir
0000d4  a167              ADR      r1,|L1.628|
                  |L1.214|
;;;100    	}else
;;;101    		sprintf(buf_tx,"ERROR %u",ERROR_PARAMETER);			 				
0000d6  e8bd4010          POP      {r4,lr}
0000da  4868              LDR      r0,|L1.636|
0000dc  f7ffbffe          B.W      __2sprintf
                  |L1.224|
0000e0  a167              ADR      r1,|L1.640|
0000e2  e7f8              B        |L1.214|
                  |L1.228|
0000e4  2207              MOVS     r2,#7
0000e6  e7fb              B        |L1.224|
;;;102    }
;;;103    /****************************************************************************
                          ENDP

                  cmd_irl_scene PROC
;;;106    ****************************************************************************/
;;;107    void cmd_irl_scene(char *par)
0000e8  b510              PUSH     {r4,lr}
;;;108    {
;;;109    	char j;
;;;110    
;;;111    	/*Chama função que retorna se o endereço e a porta do IR estão corretos*/
;;;112    	if(get_addr_channel(par))
0000ea  f7fffffe          BL       get_addr_channel
0000ee  b1d8              CBZ      r0,|L1.296|
;;;113    	{
;;;114    		/*Endereço e porta corretos. Chama função para lê o IR. A função retornará valor que indicará
;;;115    		  se houve erro na leitura do IR*/
;;;116    		if(rcv_addr_ir >= NUM_SCENE)	/*Endereços de 0 a 7 referente as cenas*/
0000f0  4c5f              LDR      r4,|L1.624|
0000f2  8860              LDRH     r0,[r4,#2]  ; rcv_addr_ir
0000f4  2804              CMP      r0,#4
0000f6  d217              BCS      |L1.296|
;;;117    		{
;;;118    			sprintf(buf_tx,"ERROR %u",ERROR_PARAMETER);
;;;119    	   		return;
;;;120    		}
;;;121    
;;;122    		j = learn_ir(rcv_addr_ir,rcv_port_ir,FILE_INDEX_CMDIR);	
0000f8  2201              MOVS     r2,#1
0000fa  7821              LDRB     r1,[r4,#0]  ; rcv_port_ir
0000fc  f7fffffe          BL       learn_ir
000100  4602              MOV      r2,r0
;;;123    		if(j == ERROR_TIMEOUT || j == ERROR_RECEIVER_IR || j == ERROR_OVERFLOW_PULSES_IR || j == ERROR_OVERFLOW_FLASH || j == ERROR_NOT_SAVED)
000102  2803              CMP      r0,#3
000104  d00e              BEQ      |L1.292|
000106  2a04              CMP      r2,#4
000108  d00c              BEQ      |L1.292|
00010a  2a05              CMP      r2,#5
00010c  d00a              BEQ      |L1.292|
00010e  2a06              CMP      r2,#6
000110  d008              BEQ      |L1.292|
000112  2a0b              CMP      r2,#0xb
000114  d006              BEQ      |L1.292|
;;;124    			sprintf(buf_tx,"ERROR %u",j);
;;;125    		else
;;;126    			sprintf(buf_tx,"OK %u",rcv_addr_ir);	/*IR salvo na memoria flash*/			
000116  8862              LDRH     r2,[r4,#2]  ; rcv_addr_ir
000118  a156              ADR      r1,|L1.628|
                  |L1.282|
;;;127    	}else
;;;128    		sprintf(buf_tx,"ERROR %u",ERROR_PARAMETER);			 				
00011a  e8bd4010          POP      {r4,lr}
00011e  4857              LDR      r0,|L1.636|
000120  f7ffbffe          B.W      __2sprintf
                  |L1.292|
000124  a156              ADR      r1,|L1.640|
000126  e7f8              B        |L1.282|
                  |L1.296|
000128  2207              MOVS     r2,#7
00012a  e7fb              B        |L1.292|
;;;129    }
;;;130    /****************************************************************************
                          ENDP

                  cmd_ir_learn_app PROC
;;;132    ****************************************************************************/
;;;133    void cmd_ir_learn_app(char *par)
00012c  b510              PUSH     {r4,lr}
;;;134    {
;;;135    	char j;
;;;136    
;;;137    	j = learn_ir(0,7,FILE_INDEX_RAIZ);	
00012e  2202              MOVS     r2,#2
000130  2107              MOVS     r1,#7
000132  2000              MOVS     r0,#0
000134  f7fffffe          BL       learn_ir
000138  4602              MOV      r2,r0
;;;138    	if(j == ERROR_TIMEOUT || j == ERROR_RECEIVER_IR || j == ERROR_OVERFLOW_PULSES_IR || j == ERROR_OVERFLOW_FLASH || j == ERROR_NOT_SAVED)
00013a  2803              CMP      r0,#3
00013c  d00d              BEQ      |L1.346|
00013e  2a04              CMP      r2,#4
000140  d00b              BEQ      |L1.346|
000142  2a05              CMP      r2,#5
000144  d009              BEQ      |L1.346|
000146  2a06              CMP      r2,#6
000148  d007              BEQ      |L1.346|
00014a  2a0b              CMP      r2,#0xb
00014c  d005              BEQ      |L1.346|
;;;139    		sprintf(buf_tx,"ERROR %u",j);
;;;140    	else
;;;141    		sprintf(buf_tx,"OK");	/*IR salvo na raiz do SD*/				 				
00014e  e8bd4010          POP      {r4,lr}
000152  a14e              ADR      r1,|L1.652|
000154  4849              LDR      r0,|L1.636|
000156  f7ffbffe          B.W      __2sprintf
                  |L1.346|
00015a  e8bd4010          POP      {r4,lr}               ;139
00015e  a148              ADR      r1,|L1.640|
000160  4846              LDR      r0,|L1.636|
000162  f7ffbffe          B.W      __2sprintf
;;;142    }
;;;143    
                          ENDP

                  cmd_ir_send_app PROC
;;;146    ****************************************************************************/
;;;147    void cmd_ir_send_app(char *par)
000166  b510              PUSH     {r4,lr}
;;;148    {
;;;149    	if(send_ir(0, FILE_INDEX_RAIZ))
000168  2102              MOVS     r1,#2
00016a  2000              MOVS     r0,#0
00016c  f7fffffe          BL       send_ir
000170  b128              CBZ      r0,|L1.382|
;;;150    		sprintf(buf_tx,"OK");	/*IR salvo na raiz do SD reproduido*/
000172  e8bd4010          POP      {r4,lr}
000176  a145              ADR      r1,|L1.652|
000178  4840              LDR      r0,|L1.636|
00017a  f7ffbffe          B.W      __2sprintf
                  |L1.382|
;;;151    	else
;;;152    		sprintf(buf_tx,"ERROR %u",ERROR_IR_NOT_SEND);
00017e  e8bd4010          POP      {r4,lr}
000182  220a              MOVS     r2,#0xa
000184  a13e              ADR      r1,|L1.640|
000186  483d              LDR      r0,|L1.636|
000188  f7ffbffe          B.W      __2sprintf
;;;153    
;;;154    //	if(send_ir(0, FILE_INDEX_RAIZ, START_IR_DEF, STOP_IR_DEF))
;;;155    //		sprintf(buf_tx,"OK");	/*IR salvo na raiz do SD reproduido*/
;;;156    //	else
;;;157    //		sprintf(buf_tx,"ERROR %u",ERROR_IR_NOT_SEND);					 				
;;;158    }
;;;159    
                          ENDP

                  cmd_ir_send PROC
;;;162    ****************************************************************************/
;;;163    void cmd_ir_send(char *par)
00018c  b510              PUSH     {r4,lr}
;;;164    {
;;;165    	rcv_addr_ir = atoi(par);
00018e  f7fffffe          BL       atoi
000192  4c37              LDR      r4,|L1.624|
000194  b280              UXTH     r0,r0
;;;166    	if(rcv_addr_ir < MAX_QTD_IR)		/*Endereço é maior que a quantidade maxima?*/
000196  f5b06f1b          CMP      r0,#0x9b0
00019a  8060              STRH     r0,[r4,#2]            ;165
00019c  d20d              BCS      |L1.442|
;;;167    	{
;;;168    		/*Chama função que reproduz o IR salvo no endereço pasado como parametro.
;;;169    		  A função retorna __TRUE se o IR foi reproduzido com sucesso*/
;;;170    
;;;171    		if(send_ir(rcv_addr_ir, FILE_INDEX_INFRARED))
00019e  2100              MOVS     r1,#0
0001a0  f7fffffe          BL       send_ir
0001a4  b110              CBZ      r0,|L1.428|
;;;172    			sprintf(buf_tx,"OK %u",rcv_addr_ir);	/*IR reproduzido*/									
0001a6  8862              LDRH     r2,[r4,#2]  ; rcv_addr_ir
0001a8  a132              ADR      r1,|L1.628|
0001aa  e001              B        |L1.432|
                  |L1.428|
;;;173    		else	
;;;174    			sprintf(buf_tx,"ERROR %u",ERROR_IR_NOT_SEND);	/*IR não reproduzido*/
0001ac  220a              MOVS     r2,#0xa
                  |L1.430|
;;;175    		
;;;176    //		if(send_ir(rcv_addr_ir, FILE_INDEX_INFRARED, START_IR_DEF, STOP_IR_DEF))
;;;177    //			sprintf(buf_tx,"OK %u",rcv_addr_ir);	/*IR reproduzido*/									
;;;178    //		else	
;;;179    //			sprintf(buf_tx,"ERROR %u",ERROR_IR_NOT_SEND);	/*IR não reproduzido*/
;;;180    
;;;181    		return;	
;;;182    	}
;;;183    	sprintf(buf_tx,"ERROR %u",ERROR_ADDR_OVERFLOW);	/*Overflow addr*/					
0001ae  a134              ADR      r1,|L1.640|
                  |L1.432|
0001b0  e8bd4010          POP      {r4,lr}
0001b4  4831              LDR      r0,|L1.636|
0001b6  f7ffbffe          B.W      __2sprintf
                  |L1.442|
0001ba  2208              MOVS     r2,#8
;;;184    }
0001bc  e7f7              B        |L1.430|
;;;185    /****************************************************************************
                          ENDP

                  cmd_ir_erase PROC
;;;187    ****************************************************************************/
;;;188    void cmd_ir_erase(char *par)
0001be  b510              PUSH     {r4,lr}
;;;189    {
;;;190    	rcv_addr_ir = atoi(par);
0001c0  f7fffffe          BL       atoi
0001c4  4c2a              LDR      r4,|L1.624|
0001c6  b282              UXTH     r2,r0
;;;191    	if(rcv_addr_ir >= MAX_QTD_IR)			/*Endereço é maior que a quantidade maxima?*/
0001c8  f5b26f1b          CMP      r2,#0x9b0
0001cc  8062              STRH     r2,[r4,#2]            ;190
0001ce  d306              BCC      |L1.478|
;;;192    		sprintf(buf_tx,"ERROR %u",ERROR_ADDR_OVERFLOW);	/*Overflow addr*/
0001d0  e8bd4010          POP      {r4,lr}
0001d4  2208              MOVS     r2,#8
0001d6  a12a              ADR      r1,|L1.640|
0001d8  4828              LDR      r0,|L1.636|
0001da  f7ffbffe          B.W      __2sprintf
                  |L1.478|
0001de  4613              MOV      r3,r2
;;;193    	else
;;;194    	{	
;;;195    		/*Chama função que deletará IR localizado no endereço passado para função como parametro*/
;;;196    		sprintf(buf_tx,"OK %u [Erase infrared in address: %u]",rcv_addr_ir,rcv_addr_ir);
0001e0  a12b              ADR      r1,|L1.656|
0001e2  4826              LDR      r0,|L1.636|
0001e4  f7fffffe          BL       __2sprintf
;;;197    		erase_ir(rcv_addr_ir);		
0001e8  8860              LDRH     r0,[r4,#2]  ; rcv_addr_ir
0001ea  e8bd4010          POP      {r4,lr}
0001ee  f7ffbffe          B.W      erase_ir
;;;198    	}			
;;;199    }
;;;200    /*****************************************************************************
                          ENDP

                  cmd_ir_erase_all PROC
;;;202    *****************************************************************************/
;;;203    void cmd_ir_erase_all(char *par)
0001f2  b510              PUSH     {r4,lr}
;;;204    {
;;;205    	erase_all_ir();
0001f4  f7fffffe          BL       erase_all_ir
;;;206    	sprintf(buf_tx,"OK 1 [Erase all infrared of memory]"); 
0001f8  e8bd4010          POP      {r4,lr}
0001fc  a12e              ADR      r1,|L1.696|
0001fe  481f              LDR      r0,|L1.636|
000200  f7ffbffe          B.W      __2sprintf
;;;207    }
;;;208    /*****************************************************************************
                          ENDP

                  cmd_ir_read PROC
;;;211    *****************************************************************************/
;;;212    void cmd_ir_read(char *par)
000204  e92d41f0          PUSH     {r4-r8,lr}
;;;213    {
;;;214    	short i;
;;;215    	rcv_addr_ir = atoi(par);
000208  f7fffffe          BL       atoi
00020c  4d18              LDR      r5,|L1.624|
00020e  b280              UXTH     r0,r0
;;;216    	if(rcv_addr_ir >= MAX_QTD_IR)
000210  f5b06f1b          CMP      r0,#0x9b0
000214  8068              STRH     r0,[r5,#2]            ;215
000216  d301              BCC      |L1.540|
;;;217    		sprintf(buf_tx,"ERROR %u",ERROR_ADDR_OVERFLOW);	/*Overflow addr*/
000218  2208              MOVS     r2,#8
00021a  e005              B        |L1.552|
                  |L1.540|
;;;218    	else
;;;219    	{
;;;220    		if(read_ir(rcv_addr_ir, FILE_INDEX_INFRARED) == NO_ERROR)	/*Função que lê IR localizado no endereço passado como parametro para função*/
00021c  2100              MOVS     r1,#0
00021e  f7fffffe          BL       read_ir
000222  280f              CMP      r0,#0xf
000224  d006              BEQ      |L1.564|
;;;221    		{
;;;222    			printf("Addr IR:%u...\r",rcv_addr_ir);
;;;223    
;;;224    			/*IR no formato DEC*/
;;;225    			for(i=0;i<MAX_QTD_PULSOS;i++)
;;;226    				printf("[%03u]:%u\r",i,ir[i]);
;;;227    			
;;;228    			fflush(stdout);
;;;229    			sprintf(buf_tx,"OK %u [Read infrared in address: %u]",rcv_addr_ir,rcv_addr_ir);
;;;230    		}else
;;;231    			sprintf(buf_tx,"ERROR %u",ERROR_READ);	
000226  2209              MOVS     r2,#9
                  |L1.552|
000228  e8bd41f0          POP      {r4-r8,lr}
00022c  a114              ADR      r1,|L1.640|
00022e  4813              LDR      r0,|L1.636|
000230  f7ffbffe          B.W      __2sprintf
                  |L1.564|
000234  8869              LDRH     r1,[r5,#2]            ;222  ; rcv_addr_ir
000236  a029              ADR      r0,|L1.732|
000238  f7fffffe          BL       __2printf
00023c  4e2b              LDR      r6,|L1.748|
00023e  2400              MOVS     r4,#0                 ;225
000240  f44f77c8          MOV      r7,#0x190             ;225
                  |L1.580|
000244  f8362014          LDRH     r2,[r6,r4,LSL #1]     ;226
000248  4621              MOV      r1,r4                 ;226
00024a  a029              ADR      r0,|L1.752|
00024c  f7fffffe          BL       __2printf
000250  1c64              ADDS     r4,r4,#1              ;225
000252  b224              SXTH     r4,r4                 ;225
000254  42bc              CMP      r4,r7                 ;225
000256  dbf5              BLT      |L1.580|
000258  4828              LDR      r0,|L1.764|
00025a  f7fffffe          BL       fflush
00025e  886b              LDRH     r3,[r5,#2]            ;229  ; rcv_addr_ir
000260  e8bd41f0          POP      {r4-r8,lr}            ;229
000264  461a              MOV      r2,r3                 ;229
000266  a126              ADR      r1,|L1.768|
000268  4804              LDR      r0,|L1.636|
00026a  f7ffbffe          B.W      __2sprintf
;;;232    	}	
;;;233    }
;;;234    #endif
                          ENDP

00026e  0000              DCW      0x0000
                  |L1.624|
                          DCD      ||.data||
                  |L1.628|
000274  4f4b2025          DCB      "OK %u",0
000278  7500    
00027a  00                DCB      0
00027b  00                DCB      0
                  |L1.636|
                          DCD      buf_tx
                  |L1.640|
000280  4552524f          DCB      "ERROR %u",0
000284  52202575
000288  00      
000289  00                DCB      0
00028a  00                DCB      0
00028b  00                DCB      0
                  |L1.652|
00028c  4f4b00            DCB      "OK",0
00028f  00                DCB      0
                  |L1.656|
000290  4f4b2025          DCB      "OK %u [Erase infrared in address: %u]",0
000294  75205b45
000298  72617365
00029c  20696e66
0002a0  72617265
0002a4  6420696e
0002a8  20616464
0002ac  72657373
0002b0  3a202575
0002b4  5d00    
0002b6  00                DCB      0
0002b7  00                DCB      0
                  |L1.696|
0002b8  4f4b2031          DCB      "OK 1 [Erase all infrared of memory]",0
0002bc  205b4572
0002c0  61736520
0002c4  616c6c20
0002c8  696e6672
0002cc  61726564
0002d0  206f6620
0002d4  6d656d6f
0002d8  72795d00
                  |L1.732|
0002dc  41646472          DCB      "Addr IR:%u...\r",0
0002e0  2049523a
0002e4  25752e2e
0002e8  2e0d00  
0002eb  00                DCB      0
                  |L1.748|
                          DCD      ||ir||
                  |L1.752|
0002f0  5b253033          DCB      "[%03u]:%u\r",0
0002f4  755d3a25
0002f8  750d00  
0002fb  00                DCB      0
                  |L1.764|
                          DCD      __stdout
                  |L1.768|
000300  4f4b2025          DCB      "OK %u [Read infrared in address: %u]",0
000304  75205b52
000308  65616420
00030c  696e6672
000310  61726564
000314  20696e20
000318  61646472
00031c  6573733a
000320  2025755d
000324  00      
000325  00                DCB      0
000326  00                DCB      0
000327  00                DCB      0

                          AREA ||.data||, DATA, ALIGN=1

                  rcv_port_ir
000000  0000              DCB      0x00,0x00
                  rcv_addr_ir
000002  0000              DCB      0x00,0x00
