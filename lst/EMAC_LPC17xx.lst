L 1 "src\tcpip\EMAC_LPC17xx.c"
N/*----------------------------------------------------------------------------
N *      RL-ARM - TCPnet
N *----------------------------------------------------------------------------
N *      Name:    EMAC_LPC17xx.c
N *      Purpose: Driver for NXP LPC1768 EMAC Ethernet Controller
N *      Rev.:    V4.20 (Modificado para SMSC9720) 24/01/2014
N *----------------------------------------------------------------------------
N *      This code is part of the RealView Run-Time Library.
N *      Copyright (c) 2004-2011 KEIL - An ARM Company. All rights reserved.
N *---------------------------------------------------------------------------*/
N#include <stdio.h>
L 1 "C:\Keil\ARM\RV31\INC\stdio.h" 1
N/* stdio.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.9 */
N/* Copyright (C) Codemist Ltd., 1988-1993                       */
N/* Copyright 1991-1998 ARM Limited. All rights reserved.        */
N
N/*
N * RCS $Revision: 137287 $
N * Checkin $Date: 2008-08-27 13:36:52 +0100 (Wed, 27 Aug 2008) $
N * Revising $Author: sdouglas $
N */
N
N/*
N * stdio.h declares two types, several macros, and many functions for
N * performing input and output. For a discussion on Streams and Files
N * refer to sections 4.9.2 and 4.9.3 in the above ANSI draft, or to a
N * modern textbook on C.
N */
N
N#ifndef __stdio_h
N#define __stdio_h
N
N#define _ARMABI __declspec(__nothrow)
N
N  #ifndef __STDIO_DECLS
N  #define __STDIO_DECLS
N
N    #undef __CLIBNS
N    #ifdef __cplusplus
S      namespace std {
S      #define __CLIBNS ::std::
S        extern "C" {
N    #else /* ndef __cplusplus */
N      #define __CLIBNS
N    #endif /* ndef __cplusplus */
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__) || !defined(__size_t)
X#if 0L || !0L || !0L
N /* always defined in C++ and non-strict C for consistency of debug info */
N  typedef unsigned int size_t;   /* see <stddef.h> */
N  #if !defined(__cplusplus) && defined(__STRICT_ANSI__)
X  #if !0L && 0L
S    #define __size_t 1
N  #endif
N#endif
N
N#undef NULL
N#define NULL 0                   /* see <stddef.h> */
N
N/* ANSI forbids va_list to be defined here */
N/* keep in step with <stdarg.h> and <wchar.h> */
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__) || !defined(__va_list_defined)
X#if 0L || !0L || !0L
N/* always defined in C++ and non-strict C for consistency of debug info */
N  typedef struct __va_list __va_list;
N  #if !defined(__cplusplus) && defined(__STRICT_ANSI__)
X  #if !0L && 0L
S    #define __va_list_defined 1
N  #endif
N#endif
N
N   /*
N    * If the compiler supports signalling nans as per N965 then it
N    * will define __SUPPORT_SNAN__, in which case a user may define
N    * _WANT_SNAN in order to obtain compliant versions of the printf
N    * and scanf families of functions
N    */
N#if defined(__SUPPORT_SNAN__) && defined(_WANT_SNAN)
X#if 0L && 0L
S#pragma import(__use_snan)
N#endif
N
Ntypedef struct __fpos_t_struct {
N    unsigned __int64 __pos;
N    /*
N     * this structure is equivalent to an mbstate_t, but we're not
N     * allowed to actually define the type name `mbstate_t' within
N     * stdio.h
N     */
N    struct {
N        unsigned int __state1, __state2;
N    } __mbstate;
N} fpos_t;
N   /*
N    * fpos_t is an object capable of recording all information needed to
N    * specify uniquely every position within a file.
N    */
N
N#define _SYS_OPEN 16
N   /* _SYS_OPEN defines a limit on the number of open files that is imposed
N    * by this C library
N    */
N
Ntypedef struct __FILE FILE;
N   /*
N    * FILE is an object capable of recording all information needed to control
N    * a stream, such as its file position indicator, a pointer to its
N    * associated buffer, an error indicator that records whether a read/write
N    * error has occurred and an end-of-file indicator that records whether the
N    * end-of-file has been reached.
N    * Its structure is not made known to library clients.
N    */
N
Nextern FILE __stdin, __stdout, __stderr;
Nextern FILE *__aeabi_stdin, *__aeabi_stdout, *__aeabi_stderr;
N
N#if _AEABI_PORTABILITY_LEVEL != 0 || (!defined _AEABI_PORTABILITY_LEVEL && __DEFAULT_AEABI_PORTABILITY_LEVEL != 0)
X#if _AEABI_PORTABILITY_LEVEL != 0 || (!0L && __DEFAULT_AEABI_PORTABILITY_LEVEL != 0)
S#define stdin  (__CLIBNS __aeabi_stdin)
S   /* pointer to a FILE object associated with standard input stream */
S#define stdout (__CLIBNS __aeabi_stdout)
S   /* pointer to a FILE object associated with standard output stream */
S#define stderr (__CLIBNS __aeabi_stderr)
S   /* pointer to a FILE object associated with standard error stream */
Sextern const int __aeabi_IOFBF;
S#define _IOFBF (__CLIBNS __aeabi_IOFBF)
Sextern const int __aeabi_IONBF;
S#define _IONBF (__CLIBNS __aeabi_IONBF)
Sextern const int __aeabi_IOLBF;
S#define _IOLBF (__CLIBNS __aeabi_IOLBF)
Sextern const int __aeabi_BUFSIZ;
S#define BUFSIZ (__CLIBNS __aeabi_BUFSIZ)
Sextern const int __aeabi_FOPEN_MAX;
S#define FOPEN_MAX (__CLIBNS __aeabi_FOPEN_MAX)
Sextern const int __aeabi_TMP_MAX;
S#define TMP_MAX (__CLIBNS __aeabi_TMP_MAX)
Sextern const int __aeabi_FILENAME_MAX;
S#define FILENAME_MAX (__CLIBNS __aeabi_FILENAME_MAX)
Sextern const int __aeabi_L_tmpnam;
S#define L_tmpnam (__CLIBNS __aeabi_L_tmpnam)
N#else
N#define stdin  (&__CLIBNS __stdin)
N   /* pointer to a FILE object associated with standard input stream */
N#define stdout (&__CLIBNS __stdout)
N   /* pointer to a FILE object associated with standard output stream */
N#define stderr (&__CLIBNS __stderr)
N   /* pointer to a FILE object associated with standard error stream */
N
N#define _IOFBF           0x100 /* fully buffered IO */
N#define _IOLBF           0x200 /* line buffered IO */
N#define _IONBF           0x400 /* unbuffered IO */
N
N    /* Various default file IO buffer sizes */
N#define BUFSIZ       (512)  /* system buffer size (as used by setbuf) */
N
N#define FOPEN_MAX _SYS_OPEN
N   /*
N    * an integral constant expression that is the minimum number of files that
N    * this implementation guarantees can be open simultaneously.
N    */
N
N#define FILENAME_MAX 256
N   /*
N    * an integral constant expression that is the size of an array of char
N    * large enough to hold the longest filename string
N    */
N#define L_tmpnam FILENAME_MAX
N   /*
N    * an integral constant expression that is the size of an array of char
N    * large enough to hold a temporary file name string generated by the
N    * tmpnam function.
N    */
N#define TMP_MAX 256
N   /*
N    * an integral constant expression that is the minimum number of unique
N    * file names that shall be generated by the tmpnam function.
N    */
N
N#endif
N
N#define EOF      (-1)
N   /*
N    * negative integral constant, indicates end-of-file, that is, no more input
N    * from a stream.
N    */
N
N#define SEEK_SET 0 /* start of stream (see fseek) */
N#define SEEK_CUR 1 /* current position in stream (see fseek) */
N#define SEEK_END 2 /* end of stream (see fseek) */
N
N    /*
N     * _IOBIN is the flag passed to _sys_write to denote a binary
N     * file.
N     */
N#define _IOBIN            0x04     /* binary stream */
N
N#define STDIN_BUFSIZ  (64)  /* default stdin buffer size */
N#define STDOUT_BUFSIZ (64)  /* default stdout buffer size */
N#define STDERR_BUFSIZ (16)  /* default stderr buffer size */
N
Nextern _ARMABI int remove(const char * /*filename*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int remove(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * causes the file whose name is the string pointed to by filename to be
N    * removed. Subsequent attempts to open the file will fail, unless it is
N    * created anew. If the file is open, the behaviour of the remove function
N    * is implementation-defined.
N    * Returns: zero if the operation succeeds, nonzero if it fails.
N    */
Nextern _ARMABI int rename(const char * /*old*/, const char * /*new*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int rename(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * causes the file whose name is the string pointed to by old to be
N    * henceforth known by the name given by the string pointed to by new. The
N    * file named old is effectively removed. If a file named by the string
N    * pointed to by new exists prior to the call of the rename function, the
N    * behaviour is implementation-defined.
N    * Returns: zero if the operation succeeds, nonzero if it fails, in which
N    *          case if the file existed previously it is still known by its
N    *          original name.
N    */
Nextern _ARMABI FILE *tmpfile(void);
Xextern __declspec(__nothrow) FILE *tmpfile(void);
N   /*
N    * creates a temporary binary file that will be automatically removed when
N    * it is closed or at program termination. The file is opened for update.
N    * Returns: a pointer to the stream of the file that it created. If the file
N    *          cannot be created, a null pointer is returned.
N    */
Nextern _ARMABI char *tmpnam(char * /*s*/);
Xextern __declspec(__nothrow) char *tmpnam(char *  );
N   /*
N    * generates a string that is not the same as the name of an existing file.
N    * The tmpnam function generates a different string each time it is called,
N    * up to TMP_MAX times. If it is called more than TMP_MAX times, the
N    * behaviour is implementation-defined.
N    * Returns: If the argument is a null pointer, the tmpnam function leaves
N    *          its result in an internal static object and returns a pointer to
N    *          that object. Subsequent calls to the tmpnam function may modify
N    *          the same object. if the argument is not a null pointer, it is
N    *          assumed to point to an array of at least L_tmpnam characters;
N    *          the tmpnam function writes its result in that array and returns
N    *          the argument as its value.
N    */
N
Nextern _ARMABI int fclose(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int fclose(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * causes the stream pointed to by stream to be flushed and the associated
N    * file to be closed. Any unwritten buffered data for the stream are
N    * delivered to the host environment to be written to the file; any unread
N    * buffered data are discarded. The stream is disassociated from the file.
N    * If the associated buffer was automatically allocated, it is deallocated.
N    * Returns: zero if the stream was succesfully closed, or nonzero if any
N    *          errors were detected or if the stream was already closed.
N    */
Nextern _ARMABI int fflush(FILE * /*stream*/);
Xextern __declspec(__nothrow) int fflush(FILE *  );
N   /*
N    * If the stream points to an output or update stream in which the most
N    * recent operation was output, the fflush function causes any unwritten
N    * data for that stream to be delivered to the host environment to be
N    * written to the file. If the stream points to an input or update stream,
N    * the fflush function undoes the effect of any preceding ungetc operation
N    * on the stream.
N    * Returns: nonzero if a write error occurs.
N    */
Nextern _ARMABI FILE *fopen(const char * __restrict /*filename*/,
Xextern __declspec(__nothrow) FILE *fopen(const char * __restrict  ,
N                           const char * __restrict /*mode*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * opens the file whose name is the string pointed to by filename, and
N    * associates a stream with it.
N    * The argument mode points to a string beginning with one of the following
N    * sequences:
N    * "r"         open text file for reading
N    * "w"         create text file for writing, or truncate to zero length
N    * "a"         append; open text file or create for writing at eof
N    * "rb"        open binary file for reading
N    * "wb"        create binary file for writing, or truncate to zero length
N    * "ab"        append; open binary file or create for writing at eof
N    * "r+"        open text file for update (reading and writing)
N    * "w+"        create text file for update, or truncate to zero length
N    * "a+"        append; open text file or create for update, writing at eof
N    * "r+b"/"rb+" open binary file for update (reading and writing)
N    * "w+b"/"wb+" create binary file for update, or truncate to zero length
N    * "a+b"/"ab+" append; open binary file or create for update, writing at eof
N    *
N    * Opening a file with read mode ('r' as the first character in the mode
N    * argument) fails if the file does not exist or cannot be read.
N    * Opening a file with append mode ('a' as the first character in the mode
N    * argument) causes all subsequent writes to be forced to the current end of
N    * file, regardless of intervening calls to the fseek function. In some
N    * implementations, opening a binary file with append mode ('b' as the
N    * second or third character in the mode argument) may initially position
N    * the file position indicator beyond the last data written, because of the
N    * NUL padding.
N    * When a file is opened with update mode ('+' as the second or third
N    * character in the mode argument), both input and output may be performed
N    * on the associated stream. However, output may not be directly followed
N    * by input without an intervening call to the fflush fuction or to a file
N    * positioning function (fseek, fsetpos, or rewind), and input be not be
N    * directly followed by output without an intervening call to the fflush
N    * fuction or to a file positioning function, unless the input operation
N    * encounters end-of-file. Opening a file with update mode may open or
N    * create a binary stream in some implementations. When opened, a stream
N    * is fully buffered if and only if it does not refer to an interactive
N    * device. The error and end-of-file indicators for the stream are
N    * cleared.
N    * Returns: a pointer to the object controlling the stream. If the open
N    *          operation fails, fopen returns a null pointer.
N    */
Nextern _ARMABI FILE *freopen(const char * __restrict /*filename*/,
Xextern __declspec(__nothrow) FILE *freopen(const char * __restrict  ,
N                    const char * __restrict /*mode*/,
N                    FILE * __restrict /*stream*/) __attribute__((__nonnull__(2,3)));
N   /*
N    * opens the file whose name is the string pointed to by filename and
N    * associates the stream pointed to by stream with it. The mode argument is
N    * used just as in the fopen function.
N    * The freopen function first attempts to close any file that is associated
N    * with the specified stream. Failure to close the file successfully is
N    * ignored. The error and end-of-file indicators for the stream are cleared.
N    * Returns: a null pointer if the operation fails. Otherwise, freopen
N    *          returns the value of the stream.
N    */
Nextern _ARMABI void setbuf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) void setbuf(FILE * __restrict  ,
N                    char * __restrict /*buf*/) __attribute__((__nonnull__(1)));
N   /*
N    * Except that it returns no value, the setbuf function is equivalent to the
N    * setvbuf function invoked with the values _IOFBF for mode and BUFSIZ for
N    * size, or (if buf is a null pointer), with the value _IONBF for mode.
N    * Returns: no value.
N    */
Nextern _ARMABI int setvbuf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int setvbuf(FILE * __restrict  ,
N                   char * __restrict /*buf*/,
N                   int /*mode*/, size_t /*size*/) __attribute__((__nonnull__(1)));
N   /*
N    * may be used after the stream pointed to by stream has been associated
N    * with an open file but before it is read or written. The argument mode
N    * determines how stream will be buffered, as follows: _IOFBF causes
N    * input/output to be fully buffered; _IOLBF causes output to be line
N    * buffered (the buffer will be flushed when a new-line character is
N    * written, when the buffer is full, or when input is requested); _IONBF
N    * causes input/output to be completely unbuffered. If buf is not the null
N    * pointer, the array it points to may be used instead of an automatically
N    * allocated buffer (the buffer must have a lifetime at least as great as
N    * the open stream, so the stream should be closed before a buffer that has
N    * automatic storage duration is deallocated upon block exit). The argument
N    * size specifies the size of the array. The contents of the array at any
N    * time are indeterminate.
N    * Returns: zero on success, or nonzero if an invalid value is given for
N    *          mode or size, or if the request cannot be honoured.
N    */
N#pragma __printf_args
Nextern _ARMABI int fprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int fprintf(FILE * __restrict  ,
N                    const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * writes output to the stream pointed to by stream, under control of the
N    * string pointed to by format that specifies how subsequent arguments are
N    * converted for output. If there are insufficient arguments for the format,
N    * the behaviour is undefined. If the format is exhausted while arguments
N    * remain, the excess arguments are evaluated but otherwise ignored. The
N    * fprintf function returns when the end of the format string is reached.
N    * The format shall be a multibyte character sequence, beginning and ending
N    * in its initial shift state. The format is composed of zero or more
N    * directives: ordinary multibyte characters (not %), which are copied
N    * unchanged to the output stream; and conversion specifiers, each of which
N    * results in fetching zero or more subsequent arguments. Each conversion
N    * specification is introduced by the character %. For a description of the
N    * available conversion specifiers refer to section 4.9.6.1 in the ANSI
N    * draft mentioned at the start of this file or to any modern textbook on C.
N    * The minimum value for the maximum number of characters producable by any
N    * single conversion is at least 509.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
N#pragma __printf_args
Nextern _ARMABI int _fprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int _fprintf(FILE * __restrict  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fprintf, but does not support floating-point formats.
N    * You can use instead of fprintf to improve code size.
N    * Returns: as fprintf.
N    */
N#pragma __printf_args
Nextern _ARMABI int printf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int printf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to fprintf with the argument stdout interposed before the
N    * arguments to printf.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
N#pragma __printf_args
Nextern _ARMABI int _printf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _printf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to printf, but does not support floating-point formats.
N    * You can use instead of printf to improve code size.
N    * Returns: as printf.
N    */
N#pragma __printf_args
Nextern _ARMABI int sprintf(char * __restrict /*s*/, const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int sprintf(char * __restrict  , const char * __restrict  , ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fprintf, except that the argument s specifies an array
N    * into which the generated output is to be written, rather than to a
N    * stream. A null character is written at the end of the characters written;
N    * it is not counted as part of the returned sum.
N    * Returns: the number of characters written to the array, not counting the
N    *          terminating null character.
N    */
N#pragma __printf_args
Nextern _ARMABI int _sprintf(char * __restrict /*s*/, const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int _sprintf(char * __restrict  , const char * __restrict  , ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to sprintf, but does not support floating-point formats.
N    * You can use instead of sprintf to improve code size.
N    * Returns: as sprintf.
N    */
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__)
X#if !0L || (1L && 199901L <= 199409L)
N#pragma __printf_args
Nextern _ARMABI int snprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int snprintf(char * __restrict  , size_t  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to fprintf, except that the argument s specifies an array
N    * into which the generated output is to be written, rather than to a
N    * stream. The argument n specifies the size of the output array, so as to
N    * avoid overflowing the buffer.
N    * A null character is written at the end of the characters written, even
N    * if the formatting was not completed; it is not counted as part of the
N    * returned sum. At most n characters of the output buffer are used,
N    * _including_ the null character.
N    * Returns: the number of characters that would have been written to the
N    *          array, not counting the terminating null character, if the
N    *          array had been big enough. So if the return is >=0 and <n, then
N    *          the entire string was successfully formatted; if the return is
N    *          >=n, the string was truncated (but there is still a null char
N    *          at the end of what was written); if the return is <0, there was
N    *          an error.
N    */
N#endif
N#pragma __printf_args
Nextern _ARMABI int _snprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int _snprintf(char * __restrict  , size_t  ,
N                      const char * __restrict /*format*/, ...) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to snprintf, but does not support floating-point formats.
N    * You can use instead of snprintf to improve code size.
N    * Returns: as snprintf.
N    */
N#pragma __scanf_args
Nextern _ARMABI int fscanf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int fscanf(FILE * __restrict  ,
N                    const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * reads input from the stream pointed to by stream, under control of the
N    * string pointed to by format that specifies the admissible input sequences
N    * and how thay are to be converted for assignment, using subsequent
N    * arguments as pointers to the objects to receive the converted input. If
N    * there are insufficient arguments for the format, the behaviour is
N    * undefined. If the format is exhausted while arguments remain, the excess
N    * arguments are evaluated but otherwise ignored.
N    * The format is composed of zero or more directives: one or more
N    * white-space characters; an ordinary character (not %); or a conversion
N    * specification. Each conversion specification is introduced by the
N    * character %. For a description of the available conversion specifiers
N    * refer to section 4.9.6.2 in the ANSI draft mentioned at the start of this
N    * file, or to any modern textbook on C.
N    * If end-of-file is encountered during input, conversion is terminated. If
N    * end-of-file occurs before any characters matching the current directive
N    * have been read (other than leading white space, where permitted),
N    * execution of the current directive terminates with an input failure;
N    * otherwise, unless execution of the current directive is terminated with a
N    * matching failure, execution of the following directive (if any) is
N    * terminated with an input failure.
N    * If conversions terminates on a conflicting input character, the offending
N    * input character is left unread in the input strem. Trailing white space
N    * (including new-line characters) is left unread unless matched by a
N    * directive. The success of literal matches and suppressed asignments is
N    * not directly determinable other than via the %n directive.
N    * Returns: the value of the macro EOF if an input failure occurs before any
N    *          conversion. Otherwise, the fscanf function returns the number of
N    *          input items assigned, which can be fewer than provided for, or
N    *          even zero, in the event of an early conflict between an input
N    *          character and the format.
N    */
N#pragma __scanf_args
Nextern _ARMABI int _fscanf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int _fscanf(FILE * __restrict  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fscanf, but does not support floating-point formats.
N    * You can use instead of fscanf to improve code size.
N    * Returns: as fscanf.
N    */
N#pragma __scanf_args
Nextern _ARMABI int scanf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int scanf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to fscanf with the argument stdin interposed before the
N    * arguments to scanf.
N    * Returns: the value of the macro EOF if an input failure occurs before any
N    *          conversion. Otherwise, the scanf function returns the number of
N    *          input items assigned, which can be fewer than provided for, or
N    *          even zero, in the event of an early matching failure.
N    */
N#pragma __scanf_args
Nextern _ARMABI int _scanf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _scanf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to scanf, but does not support floating-point formats.
N    * You can use instead of scanf to improve code size.
N    * Returns: as scanf.
N    */
N#pragma __scanf_args
Nextern _ARMABI int sscanf(const char * __restrict /*s*/,
Xextern __declspec(__nothrow) int sscanf(const char * __restrict  ,
N                    const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fscanf except that the argument s specifies a string
N    * from which the input is to be obtained, rather than from a stream.
N    * Reaching the end of the string is equivalent to encountering end-of-file
N    * for the fscanf function.
N    * Returns: the value of the macro EOF if an input failure occurs before any
N    *          conversion. Otherwise, the scanf function returns the number of
N    *          input items assigned, which can be fewer than provided for, or
N    *          even zero, in the event of an early matching failure.
N    */
N#pragma __scanf_args
Nextern _ARMABI int _sscanf(const char * __restrict /*s*/,
Xextern __declspec(__nothrow) int _sscanf(const char * __restrict  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to sscanf, but does not support floating-point formats.
N    * You can use instead of sscanf to improve code size.
N    * Returns: as sscanf.
N    */
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__)
X#if !0L || (1L && 199901L <= 199409L)
N/* C99 additions */
Nextern _ARMABI int vfscanf(FILE * __restrict /*stream*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int vfscanf(FILE * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI int vscanf(const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int vscanf(const char * __restrict  , __va_list) __attribute__((__nonnull__(1)));
Nextern _ARMABI int vsscanf(const char * __restrict /*s*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int vsscanf(const char * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
N#endif
Nextern _ARMABI int _vfscanf(FILE * __restrict /*stream*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int _vfscanf(FILE * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI int _vscanf(const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _vscanf(const char * __restrict  , __va_list) __attribute__((__nonnull__(1)));
Nextern _ARMABI int _vsscanf(const char * __restrict /*s*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int _vsscanf(const char * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
N
Nextern _ARMABI int vprintf(const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int vprintf(const char * __restrict  , __va_list  ) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to printf, with the variable argument list replaced by arg,
N    * which has been initialised by the va_start macro (and possibly subsequent
N    * va_arg calls). The vprintf function does not invoke the va_end function.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
Nextern _ARMABI int _vprintf(const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _vprintf(const char * __restrict  , __va_list  ) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to vprintf, but does not support floating-point formats.
N    * You can use instead of vprintf to improve code size.
N    * Returns: as vprintf.
N    */
Nextern _ARMABI int vfprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int vfprintf(FILE * __restrict  ,
N                    const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fprintf, with the variable argument list replaced by
N    * arg, which has been initialised by the va_start macro (and possibly
N    * subsequent va_arg calls). The vfprintf function does not invoke the
N    * va_end function.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
Nextern _ARMABI int vsprintf(char * __restrict /*s*/,
Xextern __declspec(__nothrow) int vsprintf(char * __restrict  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to sprintf, with the variable argument list replaced by
N    * arg, which has been initialised by the va_start macro (and possibly
N    * subsequent va_arg calls). The vsprintf function does not invoke the
N    * va_end function.
N    * Returns: the number of characters written in the array, not counting the
N    *          terminating null character.
N    */
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__)
X#if !0L || (1L && 199901L <= 199409L)
Nextern _ARMABI int vsnprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int vsnprintf(char * __restrict  , size_t  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to snprintf, with the variable argument list replaced by
N    * arg, which has been initialised by the va_start macro (and possibly
N    * subsequent va_arg calls). The vsprintf function does not invoke the
N    * va_end function.
N    * Returns: the number of characters that would have been written in the
N    *          array, not counting the terminating null character. As
N    *          snprintf.
N    */
N#endif
Nextern _ARMABI int _vsprintf(char * __restrict /*s*/,
Xextern __declspec(__nothrow) int _vsprintf(char * __restrict  ,
N                      const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to vsprintf, but does not support floating-point formats.
N    * You can use instead of vsprintf to improve code size.
N    * Returns: as vsprintf.
N    */
Nextern _ARMABI int _vfprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int _vfprintf(FILE * __restrict  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to vfprintf, but does not support floating-point formats.
N    * You can use instead of vfprintf to improve code size.
N    * Returns: as vfprintf.
N    */
Nextern _ARMABI int _vsnprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int _vsnprintf(char * __restrict  , size_t  ,
N                      const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to vsnprintf, but does not support floating-point formats.
N    * You can use instead of vsnprintf to improve code size.
N    * Returns: as vsnprintf.
N    */
Nextern _ARMABI int fgetc(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int fgetc(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * obtains the next character (if present) as an unsigned char converted to
N    * an int, from the input stream pointed to by stream, and advances the
N    * associated file position indicator (if defined).
N    * Returns: the next character from the input stream pointed to by stream.
N    *          If the stream is at end-of-file, the end-of-file indicator is
N    *          set and fgetc returns EOF. If a read error occurs, the error
N    *          indicator is set and fgetc returns EOF.
N    */
Nextern _ARMABI char *fgets(char * __restrict /*s*/, int /*n*/,
Xextern __declspec(__nothrow) char *fgets(char * __restrict  , int  ,
N                    FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,3)));
N   /*
N    * reads at most one less than the number of characters specified by n from
N    * the stream pointed to by stream into the array pointed to by s. No
N    * additional characters are read after a new-line character (which is
N    * retained) or after end-of-file. A null character is written immediately
N    * after the last character read into the array.
N    * Returns: s if successful. If end-of-file is encountered and no characters
N    *          have been read into the array, the contents of the array remain
N    *          unchanged and a null pointer is returned. If a read error occurs
N    *          during the operation, the array contents are indeterminate and a
N    *          null pointer is returned.
N    */
Nextern _ARMABI int fputc(int /*c*/, FILE * /*stream*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int fputc(int  , FILE *  ) __attribute__((__nonnull__(2)));
N   /*
N    * writes the character specified by c (converted to an unsigned char) to
N    * the output stream pointed to by stream, at the position indicated by the
N    * asociated file position indicator (if defined), and advances the
N    * indicator appropriately. If the file position indicator is not defined,
N    * the character is appended to the output stream.
N    * Returns: the character written. If a write error occurs, the error
N    *          indicator is set and fputc returns EOF.
N    */
Nextern _ARMABI int fputs(const char * __restrict /*s*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int fputs(const char * __restrict  , FILE * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * writes the string pointed to by s to the stream pointed to by stream.
N    * The terminating null character is not written.
N    * Returns: EOF if a write error occurs; otherwise it returns a nonnegative
N    *          value.
N    */
Nextern _ARMABI int getc(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int getc(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to fgetc except that it may be implemented as an unsafe
N    * macro (stream may be evaluated more than once, so the argument should
N    * never be an expression with side-effects).
N    * Returns: the next character from the input stream pointed to by stream.
N    *          If the stream is at end-of-file, the end-of-file indicator is
N    *          set and getc returns EOF. If a read error occurs, the error
N    *          indicator is set and getc returns EOF.
N    */
N#ifdef __cplusplus
S    inline int getchar() { return getc(stdin); }
N#else
N    #define getchar() getc(stdin)
N    extern _ARMABI int (getchar)(void);
X    extern __declspec(__nothrow) int (getchar)(void);
N#endif
N   /*
N    * is equivalent to getc with the argument stdin.
N    * Returns: the next character from the input stream pointed to by stdin.
N    *          If the stream is at end-of-file, the end-of-file indicator is
N    *          set and getchar returns EOF. If a read error occurs, the error
N    *          indicator is set and getchar returns EOF.
N    */
Nextern _ARMABI char *gets(char * /*s*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *gets(char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * reads characters from the input stream pointed to by stdin into the array
N    * pointed to by s, until end-of-file is encountered or a new-line character
N    * is read. Any new-line character is discarded, and a null character is
N    * written immediately after the last character read into the array.
N    * Returns: s if successful. If end-of-file is encountered and no characters
N    *          have been read into the array, the contents of the array remain
N    *          unchanged and a null pointer is returned. If a read error occurs
N    *          during the operation, the array contents are indeterminate and a
N    *          null pointer is returned.
N    */
Nextern _ARMABI int putc(int /*c*/, FILE * /*stream*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int putc(int  , FILE *  ) __attribute__((__nonnull__(2)));
N   /*
N    * is equivalent to fputc except that it may be implemented as aan unsafe
N    * macro (stream may be evaluated more than once, so the argument should
N    * never be an expression with side-effects).
N    * Returns: the character written. If a write error occurs, the error
N    *          indicator is set and putc returns EOF.
N    */
N#ifdef __cplusplus
S    inline int putchar(int __c) { return putc(__c, stdout); }
N#else
N    #define putchar(c) putc(c, stdout)
N    extern _ARMABI int (putchar)(int /*c*/);
X    extern __declspec(__nothrow) int (putchar)(int  );
N#endif
N   /*
N    * is equivalent to putc with the second argument stdout.
N    * Returns: the character written. If a write error occurs, the error
N    *          indicator is set and putc returns EOF.
N    */
Nextern _ARMABI int puts(const char * /*s*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int puts(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * writes the string pointed to by s to the stream pointed to by stdout, and
N    * appends a new-line character to the output. The terminating null
N    * character is not written.
N    * Returns: EOF if a write error occurs; otherwise it returns a nonnegative
N    *          value.
N    */
Nextern _ARMABI int ungetc(int /*c*/, FILE * /*stream*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int ungetc(int  , FILE *  ) __attribute__((__nonnull__(2)));
N   /*
N    * pushes the character specified by c (converted to an unsigned char) back
N    * onto the input stream pointed to by stream. The character will be
N    * returned by the next read on that stream. An intervening call to the
N    * fflush function or to a file positioning function (fseek, fsetpos,
N    * rewind) discards any pushed-back characters. The extern _ARMABIal storage
N    * corresponding to the stream is unchanged.
N    * One character pushback is guaranteed. If the unget function is called too
N    * many times on the same stream without an intervening read or file
N    * positioning operation on that stream, the operation may fail.
N    * If the value of c equals that of the macro EOF, the operation fails and
N    * the input stream is unchanged.
N    * A successful call to the ungetc function clears the end-of-file
N    * indicator. The value of the file position indicator after reading or
N    * discarding all pushed-back characters shall be the same as it was before
N    * the characters were pushed back. For a text stream, the value of the file
N    * position indicator after a successful call to the ungetc function is
N    * unspecified until all pushed-back characters are read or discarded. For a
N    * binary stream, the file position indicator is decremented by each
N    * successful call to the ungetc function; if its value was zero before a
N    * call, it is indeterminate after the call.
N    * Returns: the character pushed back after conversion, or EOF if the
N    *          operation fails.
N    */
N
Nextern _ARMABI size_t fread(void * __restrict /*ptr*/,
Xextern __declspec(__nothrow) size_t fread(void * __restrict  ,
N                    size_t /*size*/, size_t /*nmemb*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,4)));
N   /*
N    * reads into the array pointed to by ptr, up to nmemb members whose size is
N    * specified by size, from the stream pointed to by stream. The file
N    * position indicator (if defined) is advanced by the number of characters
N    * successfully read. If an error occurs, the resulting value of the file
N    * position indicator is indeterminate. If a partial member is read, its
N    * value is indeterminate. The ferror or feof function shall be used to
N    * distinguish between a read error and end-of-file.
N    * Returns: the number of members successfully read, which may be less than
N    *          nmemb if a read error or end-of-file is encountered. If size or
N    *          nmemb is zero, fread returns zero and the contents of the array
N    *          and the state of the stream remain unchanged.
N    */
N
Nextern _ARMABI size_t __fread_bytes_avail(void * __restrict /*ptr*/,
Xextern __declspec(__nothrow) size_t __fread_bytes_avail(void * __restrict  ,
N                    size_t /*count*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,3)));
N   /*
N    * reads into the array pointed to by ptr, up to count characters from the
N    * stream pointed to by stream. The file position indicator (if defined)
N    * is advanced by the number of characters successfully read. If an error
N    * occurs, the resulting value of the file position indicator is
N    * indeterminate. The ferror or feof function shall be used to
N    * distinguish between a read error and end-of-file.  The call will block
N    * only if no characters are available.
N    * Returns: the number of characters successfully read, which may be less than
N    *          count. If count is zero, __fread_bytes_avail returns zero and
N    *          the contents of the array and the state of the stream remain
N    *          unchanged.
N    */
N
Nextern _ARMABI size_t fwrite(const void * __restrict /*ptr*/,
Xextern __declspec(__nothrow) size_t fwrite(const void * __restrict  ,
N                    size_t /*size*/, size_t /*nmemb*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,4)));
N   /*
N    * writes, from the array pointed to by ptr up to nmemb members whose size
N    * is specified by size, to the stream pointed to by stream. The file
N    * position indicator (if defined) is advanced by the number of characters
N    * successfully written. If an error occurs, the resulting value of the file
N    * position indicator is indeterminate.
N    * Returns: the number of members successfully written, which will be less
N    *          than nmemb only if a write error is encountered.
N    */
N
Nextern _ARMABI int fgetpos(FILE * __restrict /*stream*/, fpos_t * __restrict /*pos*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int fgetpos(FILE * __restrict  , fpos_t * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * stores the current value of the file position indicator for the stream
N    * pointed to by stream in the object pointed to by pos. The value stored
N    * contains unspecified information usable by the fsetpos function for
N    * repositioning the stream to its position at the time  of the call to the
N    * fgetpos function.
N    * Returns: zero, if successful. Otherwise nonzero is returned and the
N    *          integer expression errno is set to an implementation-defined
N    *          nonzero value.
N    */
Nextern _ARMABI int fseek(FILE * /*stream*/, long int /*offset*/, int /*whence*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int fseek(FILE *  , long int  , int  ) __attribute__((__nonnull__(1)));
N   /*
N    * sets the file position indicator for the stream pointed to by stream.
N    * For a binary stream, the new position is at the signed number of
N    * characters specified by offset away from the point specified by whence.
N    * The specified point is the beginning of the file for SEEK_SET, the
N    * current position in the file for SEEK_CUR, or end-of-file for SEEK_END.
N    * A binary stream need not meaningfully support fseek calls with a whence
N    * value of SEEK_END.
N    * For a text stream, either offset shall be zero, or offset shall be a
N    * value returned by an earlier call to the ftell function on the same
N    * stream and whence shall be SEEK_SET.
N    * The fseek function clears the end-of-file indicator and undoes any
N    * effects of the ungetc function on the same stream. After an fseek call,
N    * the next operation on an update stream may be either input or output.
N    * Returns: nonzero only for a request that cannot be satisfied.
N    */
Nextern _ARMABI int fsetpos(FILE * __restrict /*stream*/, const fpos_t * __restrict /*pos*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int fsetpos(FILE * __restrict  , const fpos_t * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * sets  the file position indicator for the stream pointed to by stream
N    * according to the value of the object pointed to by pos, which shall be a
N    * value returned by an earlier call to the fgetpos function on the same
N    * stream.
N    * The fsetpos function clears the end-of-file indicator and undoes any
N    * effects of the ungetc function on the same stream. After an fsetpos call,
N    * the next operation on an update stream may be either input or output.
N    * Returns: zero, if successful. Otherwise nonzero is returned and the
N    *          integer expression errno is set to an implementation-defined
N    *          nonzero value.
N    */
Nextern _ARMABI long int ftell(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) long int ftell(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * obtains the current value of the file position indicator for the stream
N    * pointed to by stream. For a binary stream, the value is the number of
N    * characters from the beginning of the file. For a text stream, the file
N    * position indicator contains unspecified information, usable by the fseek
N    * function for returning the file position indicator to its position at the
N    * time of the ftell call; the difference between two such return values is
N    * not necessarily a meaningful measure of the number of characters written
N    * or read.
N    * Returns: if successful, the current value of the file position indicator.
N    *          On failure, the ftell function returns -1L and sets the integer
N    *          expression errno to an implementation-defined nonzero value.
N    */
Nextern _ARMABI void rewind(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void rewind(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * sets the file position indicator for the stream pointed to by stream to
N    * the beginning of the file. It is equivalent to
N    *          (void)fseek(stream, 0L, SEEK_SET)
N    * except that the error indicator for the stream is also cleared.
N    * Returns: no value.
N    */
N
Nextern _ARMABI void clearerr(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void clearerr(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * clears the end-of-file and error indicators for the stream pointed to by
N    * stream. These indicators are cleared only when the file is opened or by
N    * an explicit call to the clearerr function or to the rewind function.
N    * Returns: no value.
N    */
N
Nextern _ARMABI int feof(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int feof(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * tests the end-of-file indicator for the stream pointed to by stream.
N    * Returns: nonzero iff the end-of-file indicator is set for stream.
N    */
Nextern _ARMABI int ferror(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int ferror(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * tests the error indicator for the stream pointed to by stream.
N    * Returns: nonzero iff the error indicator is set for stream.
N    */
Nextern _ARMABI void perror(const char * /*s*/);
Xextern __declspec(__nothrow) void perror(const char *  );
N   /*
N    * maps the error number  in the integer expression errno to an error
N    * message. It writes a sequence of characters to the standard error stream
N    * thus: first (if s is not a null pointer and the character pointed to by
N    * s is not the null character), the string pointed to by s followed by a
N    * colon and a space; then an appropriate error message string followed by
N    * a new-line character. The contents of the error message strings are the
N    * same as those returned by the strerror function with argument errno,
N    * which are implementation-defined.
N    * Returns: no value.
N    */
N
Nextern _ARMABI int _fisatty(FILE * /*stream*/ ) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _fisatty(FILE *   ) __attribute__((__nonnull__(1)));
N    /* Returns 1 if the stream is tty (stdin), 0 otherwise. Not ANSI compliant.
N     */
N
Nextern _ARMABI void __use_no_semihosting_swi(void);
Xextern __declspec(__nothrow) void __use_no_semihosting_swi(void);
Nextern _ARMABI void __use_no_semihosting(void);
Xextern __declspec(__nothrow) void __use_no_semihosting(void);
N    /*
N     * Referencing either of these symbols will cause a link-time
N     * error if any library functions that use semihosting SWI
N     * calls are also present in the link, i.e. you define it if
N     * you want to make sure you haven't accidentally used any such
N     * SWIs.
N     */
N
N    #ifdef __cplusplus
S        }  /* extern "C" */
S      }  /* namespace std */
N    #endif
N  #endif /* __STDIO_DECLS */
N
N  #if _AEABI_PORTABILITY_LEVEL != 0 && !defined _AEABI_PORTABLE
X  #if _AEABI_PORTABILITY_LEVEL != 0 && !0L
S    #define _AEABI_PORTABLE
N  #endif
N
N  #if defined(__cplusplus) && !defined(__STDIO_NO_EXPORTS)
X  #if 0L && !0L
S    using ::std::size_t;
S    using ::std::fpos_t;
S    using ::std::FILE;
S    using ::std::remove;
S    using ::std::rename;
S    using ::std::tmpfile;
S    using ::std::tmpnam;
S    using ::std::fclose;
S    using ::std::fflush;
S    using ::std::fopen;
S    using ::std::freopen;
S    using ::std::setbuf;
S    using ::std::setvbuf;
S    using ::std::fprintf;
S    using ::std::_fprintf;
S    using ::std::printf;
S    using ::std::_printf;
S    using ::std::sprintf;
S    using ::std::_sprintf;
S    #if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__)
S      using ::std::snprintf;
S      using ::std::vsnprintf;
S      using ::std::vfscanf;
S      using ::std::vscanf;
S      using ::std::vsscanf;
S    #endif
S    using ::std::_snprintf;
S    using ::std::_vsnprintf;
S    using ::std::fscanf;
S    using ::std::_fscanf;
S    using ::std::scanf;
S    using ::std::_scanf;
S    using ::std::sscanf;
S    using ::std::_sscanf;
S    using ::std::_vfscanf;
S    using ::std::_vscanf;
S    using ::std::_vsscanf;
S    using ::std::vprintf;
S    using ::std::_vprintf;
S    using ::std::vfprintf;
S    using ::std::_vfprintf;
S    using ::std::vsprintf;
S    using ::std::_vsprintf;
S    using ::std::fgetc;
S    using ::std::fgets;
S    using ::std::fputc;
S    using ::std::fputs;
S    using ::std::getc;
S    using ::std::getchar;
S    using ::std::gets;
S    using ::std::putc;
S    using ::std::putchar;
S    using ::std::puts;
S    using ::std::ungetc;
S    using ::std::fread;
S    using ::std::__fread_bytes_avail;
S    using ::std::fwrite;
S    using ::std::fgetpos;
S    using ::std::fseek;
S    using ::std::fsetpos;
S    using ::std::ftell;
S    using ::std::rewind;
S    using ::std::clearerr;
S    using ::std::feof;
S    using ::std::ferror;
S    using ::std::perror;
S    using ::std::_fisatty;
S    using ::std::__use_no_semihosting_swi;
S    using ::std::__use_no_semihosting;
N  #endif
N
N#endif /* ndef __stdio_h */
N
N/* end of stdio.h */
L 12 "src\tcpip\EMAC_LPC17xx.c" 2
N#include <Net_Config.h>
L 1 "C:\Keil\ARM\RV31\INC\Net_Config.h" 1
N/*----------------------------------------------------------------------------
N *      RL-ARM - TCPnet
N *----------------------------------------------------------------------------
N *      Name:    NET_CONFIG.H
N *      Purpose: Common TCPnet Definitions
N *      Rev.:    V4.20
N *----------------------------------------------------------------------------
N *      This code is part of the RealView Run-Time Library.
N *      Copyright (c) 2004-2011 KEIL - An ARM Company. All rights reserved.
N *---------------------------------------------------------------------------*/
N
N#ifndef __NET_CONFIG_H__
N#define __NET_CONFIG_H__
N
N#include <RTL.h>
L 1 "C:\Keil\ARM\RV31\INC\RTL.h" 1
N/*----------------------------------------------------------------------------
N *      RL-ARM - A P I 
N *----------------------------------------------------------------------------
N *      Name:    RTL.H 
N *      Purpose: Application Programming Interface. 
N *      Rev.:    V4.20
N *----------------------------------------------------------------------------
N *      This code is part of the RealView Run-Time Library.
N *      Copyright (c) 2004-2011 KEIL - An ARM Company. All rights reserved.
N *---------------------------------------------------------------------------*/
N
N#ifndef __RTL_H__
N#define __RTL_H__
N
N/* RL-ARM version number. */
N#define __RL_ARM_VER    420
N 
N#define __task          __declspec(noreturn)
N
N#ifndef NULL
S #ifdef __cplusplus              // EC++
S  #define NULL          0
S #else
S  #define NULL          ((void *) 0)
S #endif
N#endif
N
N#ifndef EOF
S #define EOF            -1
N#endif
N
N#ifndef __size_t
N #define __size_t       1
N typedef unsigned int   size_t;
N#endif
N
Ntypedef signed char     S8;
Ntypedef unsigned char   U8;
Ntypedef short           S16;
Ntypedef unsigned short  U16;
Ntypedef int             S32;
Ntypedef unsigned int    U32;
Ntypedef long long       S64;
Ntypedef unsigned long long U64;
Ntypedef unsigned char   BIT;
Ntypedef unsigned int    BOOL;
N
N#ifndef __TRUE
N #define __TRUE         1
N#endif
N#ifndef __FALSE
N #define __FALSE        0
N#endif
N
N#ifdef __BIG_ENDIAN
S #define U32_LE(v) (__rev(v))
S #define U16_LE(v) (__rev(v) >> 16) 
S #define U32_BE(v)       (v)
S #define U16_BE(v)       (v)
N#else
N #define U32_BE(v) (__rev(v))
N #define U16_BE(v) (__rev(v) >> 16) 
N #define U32_LE(v)       (v)
N #define U16_LE(v)       (v)
N#endif
N
N/*----------------------------------------------------------------------------
N *                             RTX Kernel API
N *---------------------------------------------------------------------------*/
N
N#ifdef __cplusplus               // EC++
Sextern "C"  {
N#endif
N
N/* Definition of Semaphore type */
Ntypedef U32 OS_SEM[2];
N
N/* Definition of Mailbox type */
N#define os_mbx_declare(name,cnt)    U32 name [4 + cnt]
Ntypedef U32 OS_MBX[];
N
N/* Definition of Mutex type */
Ntypedef U32 OS_MUT[3];
N
N/* Task Identification number. */
Ntypedef U32 OS_TID;
N
N/* Function return of system calls returning an object identification */
Ntypedef void *OS_ID;
N
N/* Function return of system calls indicating an event or completion state */
Ntypedef U32 OS_RESULT;
N
N/* Return codes */
N#define OS_R_TMO        0x01
N#define OS_R_EVT        0x02
N#define OS_R_SEM        0x03
N#define OS_R_MBX        0x04
N#define OS_R_MUT        0x05
N
N#define OS_R_OK         0x00
N#define OS_R_NOK        0xff
N
N#define OS_TCB_SIZE     48
N#define OS_TMR_SIZE     8
N
N/* Error Codes */
N#define OS_ERR_STK_OVF  1
N#define OS_ERR_FIFO_OVF 2
N#define OS_ERR_MBX_OVF  3
N
N#if !(defined(__TARGET_ARCH_6S_M) || defined(__TARGET_ARCH_7_M) || defined(__TARGET_ARCH_7E_M))
X#if !(0L || 1L || 0L)
S
S/*----------------------------------------------------------------------------
S *      Functions ARM
S *---------------------------------------------------------------------------*/
S
S/* Task Management */
S#define os_sys_init(tsk)              os_sys_init0(tsk,0,NULL)
S#define os_sys_init_prio(tsk,prio)    os_sys_init0(tsk,prio,NULL)
S#define os_sys_init_user(tsk,prio,stk,size)                                   \
S                                      os_sys_init0(tsk,prio|(size<<8),stk)
X#define os_sys_init_user(tsk,prio,stk,size)                                                                         os_sys_init0(tsk,prio|(size<<8),stk)
S#define os_tsk_create(tsk,prio)       os_tsk_create0(tsk,prio,NULL,NULL)
S#define os_tsk_create_user(tsk,prio,stk,size)                                 \
S                                      os_tsk_create0(tsk,prio|(size<<8),stk,NULL)
X#define os_tsk_create_user(tsk,prio,stk,size)                                                                       os_tsk_create0(tsk,prio|(size<<8),stk,NULL)
S#define os_tsk_create_ex(tsk,prio,argv) os_tsk_create_ex0(tsk,prio,NULL,argv)
S#define os_tsk_create_user_ex(tsk,prio,stk,size,argv)                         \
S                                      os_tsk_create_ex0(tsk,prio|(size<<8),stk,argv)
X#define os_tsk_create_user_ex(tsk,prio,stk,size,argv)                                                               os_tsk_create_ex0(tsk,prio|(size<<8),stk,argv)
S#define os_tsk_delete_self()          os_tsk_delete(0)
S#define os_tsk_prio_self(prio)        os_tsk_prio(0,prio)
S#define isr_tsk_get()                 os_tsk_self()
S
Sextern void      os_sys_init0 (void (*task)(void), U32 prio_stksz, void *stk);
Sextern OS_TID    os_tsk_create0 (void (*task)(void), U32 prio_stksz, 
S                                 void *stk, void *argv);
Sextern OS_TID    os_tsk_create_ex0 (void (*task)(void *), U32 prio_stksz, 
S                                    void *stk, void *argv);
Sextern OS_TID    os_tsk_self (void);
Sextern void      os_tsk_pass (void);
Sextern OS_RESULT os_tsk_prio (OS_TID task_id, U8 new_prio);
Sextern OS_RESULT os_tsk_delete (OS_TID task_id);
S
S/* Event flag Management */
S#define os_evt_wait_or(wflags,tmo)      os_evt_wait(wflags,tmo,__FALSE)
S#define os_evt_wait_and(wflags,tmo)     os_evt_wait(wflags,tmo,__TRUE)
S
Sextern OS_RESULT os_evt_wait (U16 wait_flags, U16 timeout, BOOL and_wait);
Sextern void      os_evt_set (U16 event_flags, OS_TID task_id);
Sextern void      os_evt_clr (U16 clear_flags, OS_TID task_id);
Sextern void      isr_evt_set (U16 event_flags, OS_TID task_id);
Sextern U16       os_evt_get (void);
S
S/* Semaphore Management */
Sextern void      os_sem_init (OS_ID semaphore, U16 token_count);
Sextern OS_RESULT os_sem_send (OS_ID semaphore);
Sextern OS_RESULT os_sem_wait (OS_ID semaphore, U16 timeout);
Sextern void      isr_sem_send (OS_ID semaphore);
S
S/* Mailbox Management */
S#define isr_mbx_check(mbx)              os_mbx_check(mbx)
S
Sextern void      os_mbx_init (OS_ID mailbox, U16 mbx_size);
Sextern OS_RESULT os_mbx_send (OS_ID mailbox, void *message_ptr, U16 timeout);
Sextern OS_RESULT os_mbx_wait (OS_ID mailbox, void  **message, U16 timeout);
Sextern OS_RESULT os_mbx_check (OS_ID mailbox);
Sextern void      isr_mbx_send (OS_ID mailbox, void *message_ptr);
Sextern OS_RESULT isr_mbx_receive (OS_ID mailbox, void **message);
S
S/* Mutex Management */
Sextern void      os_mut_init (OS_ID mutex);
Sextern OS_RESULT os_mut_release (OS_ID mutex);
Sextern OS_RESULT os_mut_wait (OS_ID mutex, U16 timeout);
S
S/* Time Management */
Sextern void      os_dly_wait (U16 delay_time);
Sextern void      os_itv_set (U16 interval_time);
Sextern void      os_itv_wait (void);
S
S/* User Timer Management */
Sextern OS_ID     os_tmr_create (U16 tcnt, U16 info);
Sextern OS_ID     os_tmr_kill (OS_ID timer);
S
S/* System Functions */
Sextern void      tsk_lock (void) __swi (5);
Sextern void      tsk_unlock (void);
S
S/* Fixed Memory Block Management Functions */
Sextern int       _init_box (void *box_mem, U32 box_size, U32 blk_size);
Sextern void     *_alloc_box (void *box_mem) __swi (1);
Sextern void     *_calloc_box (void *box_mem);
Sextern int       _free_box (void *box_mem, void *box) __swi (2);
S
N#else
N
N/*----------------------------------------------------------------------------
N *      Functions Cortex-M
N *---------------------------------------------------------------------------*/
N
N#define __SVC_0         __svc_indirect(0)
N
N/* Task Management */
Nextern void      os_set_env    (void);
Nextern void      rt_sys_init   (void (*task)(void), U8 priority, void *stk);
Nextern void      rt_tsk_pass   (void);
Nextern OS_TID    rt_tsk_self   (void);
Nextern OS_RESULT rt_tsk_prio   (OS_TID task_id, U8 new_prio);
Nextern OS_TID    rt_tsk_create (void (*task)(void), U8 priority, void *stk, void *argv);
Nextern OS_RESULT rt_tsk_delete (OS_TID task_id);
N
N#define os_sys_init(tsk)              os_set_env();                           \
N                                      _os_sys_init((U32)rt_sys_init,tsk,0,NULL)
X#define os_sys_init(tsk)              os_set_env();                                                                 _os_sys_init((U32)rt_sys_init,tsk,0,NULL)
N#define os_sys_init_user(tsk,prio,stk,size)                                   \
N                                      os_set_env();                           \
N                                      _os_sys_init((U32)rt_sys_init,tsk,prio|(size<<8),stk)
X#define os_sys_init_user(tsk,prio,stk,size)                                                                         os_set_env();                                                                 _os_sys_init((U32)rt_sys_init,tsk,prio|(size<<8),stk)
N#define os_sys_init_prio(tsk,prio)    os_set_env();                           \
N                                      _os_sys_init((U32)rt_sys_init,tsk,prio,NULL)
X#define os_sys_init_prio(tsk,prio)    os_set_env();                                                                 _os_sys_init((U32)rt_sys_init,tsk,prio,NULL)
N#define os_tsk_create(tsk,prio)       _os_tsk_create((U32)rt_tsk_create,tsk,prio,NULL,NULL)
N#define os_tsk_create_user(tsk,prio,stk,size)                                 \
N                                      _os_tsk_create((U32)rt_tsk_create,tsk,prio|(size<<8),stk,NULL)
X#define os_tsk_create_user(tsk,prio,stk,size)                                                                       _os_tsk_create((U32)rt_tsk_create,tsk,prio|(size<<8),stk,NULL)
N#define os_tsk_create_ex(tsk,prio,argv) _os_tsk_create_ex((U32)rt_tsk_create,tsk,prio,NULL,argv)
N#define os_tsk_create_user_ex(tsk,prio,stk,size,argv)                         \
N                                      _os_tsk_create_ex((U32)rt_tsk_create,tsk,prio|(size<<8),stk,argv)
X#define os_tsk_create_user_ex(tsk,prio,stk,size,argv)                                                               _os_tsk_create_ex((U32)rt_tsk_create,tsk,prio|(size<<8),stk,argv)
N#define os_tsk_self()                 _os_tsk_self((U32)rt_tsk_self)
N#define os_tsk_pass()                 _os_tsk_pass((U32)rt_tsk_pass)
N#define os_tsk_prio(task_id,new_prio) _os_tsk_prio((U32)rt_tsk_prio,task_id,new_prio)
N#define os_tsk_prio_self(prio)        _os_tsk_prio((U32)rt_tsk_prio,0,prio)
N#define os_tsk_delete(task_id)        _os_tsk_delete((U32)rt_tsk_delete,task_id)
N#define os_tsk_delete_self()          _os_tsk_delete((U32)rt_tsk_delete, 0)
N#define isr_tsk_get()                 rt_tsk_self()
N
Nextern void      _os_sys_init(U32 p, void (*task)(void), U32 prio_stksz,
N                                     void *stk)                        __SVC_0;
X                                     void *stk)                        __svc_indirect(0);
Nextern OS_TID    _os_tsk_create (U32 p, void (*task)(void), U32 prio_stksz,
N                                        void *stk, void *argv)         __SVC_0;
X                                        void *stk, void *argv)         __svc_indirect(0);
Nextern OS_TID    _os_tsk_create_ex (U32 p, void (*task)(void *), U32 prio_stksz,
N                                           void *stk, void *argv)      __SVC_0;
X                                           void *stk, void *argv)      __svc_indirect(0);
Nextern OS_TID    _os_tsk_self (U32 p)                                  __SVC_0;
Xextern OS_TID    _os_tsk_self (U32 p)                                  __svc_indirect(0);
Nextern void      _os_tsk_pass (U32 p)                                  __SVC_0;
Xextern void      _os_tsk_pass (U32 p)                                  __svc_indirect(0);
Nextern OS_RESULT _os_tsk_prio (U32 p, OS_TID task_id, U8 new_prio)     __SVC_0;
Xextern OS_RESULT _os_tsk_prio (U32 p, OS_TID task_id, U8 new_prio)     __svc_indirect(0);
Nextern OS_RESULT _os_tsk_delete (U32 p, OS_TID task_id)                __SVC_0;
Xextern OS_RESULT _os_tsk_delete (U32 p, OS_TID task_id)                __svc_indirect(0);
N
N/* Event flag Management */
Nextern OS_RESULT rt_evt_wait (U16 wait_flags,  U16 timeout, BOOL and_wait);
Nextern void      rt_evt_set  (U16 event_flags, OS_TID task_id);
Nextern void      rt_evt_clr  (U16 clear_flags, OS_TID task_id);
Nextern U16       rt_evt_get  (void);
N
N#define os_evt_wait_or(wflags,tmo)    _os_evt_wait((U32)rt_evt_wait,wflags,tmo,__FALSE)
N#define os_evt_wait_and(wflags,tmo)   _os_evt_wait((U32)rt_evt_wait,wflags,tmo,__TRUE)
N#define os_evt_set(evt_flags,task_id) _os_evt_set((U32)rt_evt_set,evt_flags,task_id)
N#define os_evt_clr(clr_flags,task_id) _os_evt_clr((U32)rt_evt_clr,clr_flags,task_id)
N#define os_evt_get()                  _os_evt_get((U32)rt_evt_get)
N
Nextern OS_RESULT _os_evt_wait(U32 p, U16 wait_flags, U16 timeout,
N                                     BOOL and_wait)                    __SVC_0;
X                                     BOOL and_wait)                    __svc_indirect(0);
Nextern void      _os_evt_set (U32 p, U16 event_flags, OS_TID task_id)  __SVC_0;
Xextern void      _os_evt_set (U32 p, U16 event_flags, OS_TID task_id)  __svc_indirect(0);
Nextern void      _os_evt_clr (U32 p, U16 clear_flags, OS_TID task_id)  __SVC_0;
Xextern void      _os_evt_clr (U32 p, U16 clear_flags, OS_TID task_id)  __svc_indirect(0);
Nextern U16       _os_evt_get (U32 p)                                   __SVC_0;
Xextern U16       _os_evt_get (U32 p)                                   __svc_indirect(0);
Nextern void      isr_evt_set (U16 event_flags, OS_TID task_id);
N
N/* Semaphore Management */
Nextern void      rt_sem_init (OS_ID semaphore, U16 token_count);
Nextern OS_RESULT rt_sem_send (OS_ID semaphore);
Nextern OS_RESULT rt_sem_wait (OS_ID semaphore, U16 timeout);
N
N#define os_sem_init(sem,t_count)     _os_sem_init((U32)rt_sem_init,sem,t_count)
N#define os_sem_send(sem)             _os_sem_send((U32)rt_sem_send,sem)
N#define os_sem_wait(sem,tmo)         _os_sem_wait((U32)rt_sem_wait,sem,tmo)
N
Nextern void      _os_sem_init (U32 p, OS_ID semaphore, 
N                                      U16 token_count)                 __SVC_0;
X                                      U16 token_count)                 __svc_indirect(0);
Nextern OS_RESULT _os_sem_send (U32 p, OS_ID semaphore)                 __SVC_0;
Xextern OS_RESULT _os_sem_send (U32 p, OS_ID semaphore)                 __svc_indirect(0);
Nextern OS_RESULT _os_sem_wait (U32 p, OS_ID semaphore, U16 timeout)    __SVC_0;
Xextern OS_RESULT _os_sem_wait (U32 p, OS_ID semaphore, U16 timeout)    __svc_indirect(0);
Nextern void      isr_sem_send (OS_ID semaphore);
N
N/* Mailbox Management */
Nextern void      rt_mbx_init  (OS_ID mailbox, U16 mbx_size);
Nextern OS_RESULT rt_mbx_send  (OS_ID mailbox, void *p_msg,    U16 timeout);
Nextern OS_RESULT rt_mbx_wait  (OS_ID mailbox, void **message, U16 timeout);
Nextern OS_RESULT rt_mbx_check (OS_ID mailbox);
N
N#define os_mbx_init(mbx,mbx_size)     _os_mbx_init((U32)rt_mbx_init,mbx,mbx_size)
N#define os_mbx_send(mbx,p_msg,tmo)    _os_mbx_send((U32)rt_mbx_send,mbx,p_msg,tmo)
N#define os_mbx_wait(mbx,message,tmo)  _os_mbx_wait((U32)rt_mbx_wait,mbx,message,tmo)
N#define os_mbx_check(mbx)             _os_mbx_check((U32)rt_mbx_check,mbx)
N#define isr_mbx_check(mbx)            rt_mbx_check(mbx)
N
Nextern void      _os_mbx_init (U32 p, OS_ID mailbox, U16 mbx_size)     __SVC_0;
Xextern void      _os_mbx_init (U32 p, OS_ID mailbox, U16 mbx_size)     __svc_indirect(0);
Nextern OS_RESULT _os_mbx_send (U32 p, OS_ID mailbox, void *message_ptr,
N                                      U16 timeout)                     __SVC_0;
X                                      U16 timeout)                     __svc_indirect(0);
Nextern OS_RESULT _os_mbx_wait (U32 p, OS_ID mailbox, void  **message,
N                                      U16 timeout)                     __SVC_0;
X                                      U16 timeout)                     __svc_indirect(0);
Nextern OS_RESULT _os_mbx_check (U32 p, OS_ID mailbox)                  __SVC_0;
Xextern OS_RESULT _os_mbx_check (U32 p, OS_ID mailbox)                  __svc_indirect(0);
Nextern void      isr_mbx_send (OS_ID mailbox, void *message_ptr);
Nextern OS_RESULT isr_mbx_receive (OS_ID mailbox, void **message);
N
N/* Mutex Management */
Nextern void      rt_mut_init    (OS_ID mutex);
Nextern OS_RESULT rt_mut_release (OS_ID mutex);
Nextern OS_RESULT rt_mut_wait    (OS_ID mutex, U16 timeout);
N
N#define os_mut_init(mutex)         _os_mut_init((U32)rt_mut_init,mutex)
N#define os_mut_release(mutex)      _os_mut_release((U32)rt_mut_release,mutex)
N#define os_mut_wait(mutex,timeout) _os_mut_wait((U32)rt_mut_wait,mutex,timeout)
N
Nextern void      _os_mut_init (U32 p, OS_ID mutex)                     __SVC_0;
Xextern void      _os_mut_init (U32 p, OS_ID mutex)                     __svc_indirect(0);
Nextern OS_RESULT _os_mut_release (U32 p, OS_ID mutex)                  __SVC_0;
Xextern OS_RESULT _os_mut_release (U32 p, OS_ID mutex)                  __svc_indirect(0);
Nextern OS_RESULT _os_mut_wait (U32 p, OS_ID mutex, U16 timeout)        __SVC_0;
Xextern OS_RESULT _os_mut_wait (U32 p, OS_ID mutex, U16 timeout)        __svc_indirect(0);
N
N/* Time Management */
Nextern void      rt_dly_wait (U16 delay_time);
Nextern void      rt_itv_set  (U16 interval_time);
Nextern void      rt_itv_wait (void);
N
N#define os_dly_wait(delay_time)    _os_dly_wait((U32)rt_dly_wait,delay_time)
N#define os_itv_set(interval_time)  _os_itv_set((U32)rt_itv_set,interval_time)
N#define os_itv_wait()              _os_itv_wait((U32)rt_itv_wait)
N
Nextern void      _os_dly_wait (U32 p, U16 delay_time)                  __SVC_0;
Xextern void      _os_dly_wait (U32 p, U16 delay_time)                  __svc_indirect(0);
Nextern void      _os_itv_set (U32 p, U16 interval_time)                __SVC_0;
Xextern void      _os_itv_set (U32 p, U16 interval_time)                __svc_indirect(0);
Nextern void      _os_itv_wait (U32 p)                                  __SVC_0;
Xextern void      _os_itv_wait (U32 p)                                  __svc_indirect(0);
N
N/* User Timer Management */
Nextern OS_ID     rt_tmr_create (U16 tcnt, U16 info);
Nextern OS_ID     rt_tmr_kill   (OS_ID timer);
N
N#define os_tmr_create(tcnt,info)   _os_tmr_create((U32)rt_tmr_create,tcnt,info)
N#define os_tmr_kill(timer)         _os_tmr_kill((U32)rt_tmr_kill,timer)
N
Nextern OS_ID     _os_tmr_create (U32 p, U16 tcnt, U16 info)            __SVC_0;
Xextern OS_ID     _os_tmr_create (U32 p, U16 tcnt, U16 info)            __svc_indirect(0);
Nextern OS_ID     _os_tmr_kill (U32 p, OS_ID timer)                     __SVC_0;
Xextern OS_ID     _os_tmr_kill (U32 p, OS_ID timer)                     __svc_indirect(0);
N
N/* System Functions */
Nextern void      rt_tsk_lock   (void);
Nextern void      rt_tsk_unlock (void);
N
N#define tsk_lock()                 _os_tsk_lock((U32)rt_tsk_lock)
N#define tsk_unlock()               _os_tsk_unlock((U32)rt_tsk_unlock)
N
Nextern void      _os_tsk_lock (U32 p)                                  __SVC_0;
Xextern void      _os_tsk_lock (U32 p)                                  __svc_indirect(0);
Nextern void      _os_tsk_unlock (U32 p)                                __SVC_0;
Xextern void      _os_tsk_unlock (U32 p)                                __svc_indirect(0);
N
N/* Fixed Memory Block Management Functions */
Nextern int       _init_box (void *box_mem, U32 box_size, U32 blk_size);
Nextern void     *_alloc_box (void *box_mem);
Nextern void     *_calloc_box (void *box_mem);
Nextern int       _free_box (void *box_mem, void *box);
N
N#endif
N
N#define BOX_ALIGN_8     0x80000000
N#define _declare_box(pool,size,cnt)   U32 pool[(((size)+3)/4)*(cnt) + 3]
N#define _declare_box8(pool,size,cnt)  U64 pool[(((size)+7)/8)*(cnt) + 2]
N#define _init_box8(pool,size,bsize)   _init_box (pool,size,bsize | BOX_ALIGN_8)
N
N/* For compatibility with older configurations.*/
N#define os_stk_overflow         os_error
N
N/*----------------------------------------------------------------------------
N *                        Flash File System API
N *---------------------------------------------------------------------------*/
N
Ntypedef struct {                        /* RL Time format (FFS, TCPnet)      */
N  U8  hr;                               /* Hours    [0..23]                  */
N  U8  min;                              /* Minutes  [0..59]                  */
N  U8  sec;                              /* Seconds  [0..59]                  */
N  U8  day;                              /* Day      [1..31]                  */
N  U8  mon;                              /* Month    [1..12]                  */
N  U16 year;                             /* Year     [1980..2107]             */
N} RL_TIME;
N
Ntypedef struct {                        /* Search info record                */
N  S8  name[256];                        /* Name                              */
N  U32 size;                             /* File size in bytes                */
N  U16 fileID;                           /* System Identification             */
N  U8  attrib;                           /* Attributes                        */
N  RL_TIME time;                         /* Create/Modify Time                */
N} FINFO;
N
Nextern int finit (const char *drive);
Nextern int funinit (const char *drive);
Nextern int fdelete (const char *filename);
Nextern int frename (const char *oldname, const char *newname);
Nextern int ffind (const char *pattern, FINFO *info);
Nextern U64 ffree (const char *drive);
Nextern int fformat (const char *drive);
Nextern int fanalyse (const char *drive);
Nextern int fcheck (const char *drive);
Nextern int fdefrag (const char *drive);
N
N/* The following macros provide for common functions */
N#define unlink(fn)      fdelete(fn);
N
N/*----------------------------------------------------------------------------
N *                             TCPnet API
N *---------------------------------------------------------------------------*/
N
N/* UDP Options */
N#define UDP_OPT_SEND_CS    0x01   /* Calculate Checksum for UDP send frames  */
N#define UDP_OPT_CHK_CS     0x02   /* Verify Checksum for received UDP frames */
N
N/* TCP Socket Types */
N#define TCP_TYPE_SERVER    0x01   /* Socket Type Server (open for listening) */
N#define TCP_TYPE_CLIENT    0x02   /* Socket Type Client (initiate connect)   */
N#define TCP_TYPE_DELAY_ACK 0x04   /* Socket Type Delayed Acknowledge         */
N#define TCP_TYPE_FLOW_CTRL 0x08   /* Socket Type Flow Control                */
N#define TCP_TYPE_KEEP_ALIVE 0x10  /* Socket Type Keep Alive                  */
N#define TCP_TYPE_CLIENT_SERVER (TCP_TYPE_SERVER | TCP_TYPE_CLIENT)
N
N/* TCP Callback Events */
N#define TCP_EVT_CONREQ     0      /* Connect request received event          */
N#define TCP_EVT_CONNECT    1      /* Connection established event            */
N#define TCP_EVT_CLOSE      2      /* Connection was properly closed          */
N#define TCP_EVT_ABORT      3      /* Connection is for some reason aborted   */
N#define TCP_EVT_ACK        4      /* Previously send data acknowledged       */
N#define TCP_EVT_DATA       5      /* Data received event                     */
N
N/* TCP States */
N#define TCP_STATE_FREE     0      /* Entry is free and unused                */
N#define TCP_STATE_CLOSED   1      /* Entry allocated, socket still closed    */
N#define TCP_STATE_LISTEN   2      /* Socket waiting for incoming connection  */
N#define TCP_STATE_SYN_REC  3      /* SYN frame received                      */
N#define TCP_STATE_SYN_SENT 4      /* SYN packet sent to establish a connect. */
N#define TCP_STATE_FINW1    5      /* Tcp_close started FIN packet was sent   */
N#define TCP_STATE_FINW2    6      /* Our FIN ack-ed, waiting for remote FIN  */
N#define TCP_STATE_CLOSING  7      /* Received FIN independently of our FIN   */
N#define TCP_STATE_LAST_ACK 8      /* Waiting for last ACK for our FIN        */
N#define TCP_STATE_TWAIT    9      /* Timed waiting for 2MSL                  */
N#define TCP_STATE_CONNECT  10     /* TCP Connection established              */
N
N/* DNS Callback Events */
N#define DNS_EVT_SUCCESS    0      /* Host name successfully resolved         */
N#define DNS_EVT_NONAME     1      /* DNS Error, no such name                 */
N#define DNS_EVT_TIMEOUT    2      /* Timeout resolving host                  */
N#define DNS_EVT_ERROR      3      /* Erroneous response packet               */
N
N/* DNS 'get_host_by_name()' result codes */
N#define DNS_RES_OK         0      /* Function finished OK                    */
N#define DNS_ERROR_BUSY     1      /* DNS Client busy, can't process request  */
N#define DNS_ERROR_LABEL    2      /* Host name Label too long                */
N#define DNS_ERROR_NAME     3      /* Host name loo long                      */
N#define DNS_ERROR_NOSRV    4      /* Prim. DNS server not specified (0.0.0.0)*/
N#define DNS_ERROR_UDPSEND  5      /* UDP Send frame error                    */
N
N/* SMTP Callback Events */
N#define SMTP_EVT_SUCCESS   0      /* Email successfully sent                 */
N#define SMTP_EVT_TIMEOUT   1      /* Timeout sending email                   */
N#define SMTP_EVT_ERROR     2      /* Error when sending email                */
N
N/* ARP Cache Entry types */
N#define ARP_FIXED_IP       0      /* Fixed IP adrs is refreshed after tout   */
N#define ARP_TEMP_IP        1      /* Temp adrs is removed after timeout      */
N
Nextern void init_TcpNet (void);
Nextern void main_TcpNet (void);
Nextern void timer_tick (void);
Nextern U8   udp_get_socket (U8 tos, U8 opt, 
N                            U16 (*listener)(U8 socket, U8 *remip, U16 port, U8 *buf, U16 len));
Nextern BOOL udp_release_socket (U8 socket);
Nextern BOOL udp_open (U8 socket, U16 locport);
Nextern BOOL udp_close (U8 socket);
Nextern BOOL udp_mcast_ttl (U8 socket, U8 ttl);
Nextern U8  *udp_get_buf (U16 size);
Nextern BOOL udp_send (U8 socket, U8 *remip, U16 remport, U8 *buf, U16 dlen);
Nextern U8   tcp_get_socket (U8 type, U8 tos, U16 tout,
N                            U16 (*listener)(U8 socket, U8 event, U8 *buf, U16 len));
Nextern BOOL tcp_release_socket (U8 socket);
Nextern BOOL tcp_listen (U8 socket, U16 locport);
Nextern BOOL tcp_connect (U8 socket, U8 *remip, U16 remport, U16 locport);
Nextern U8  *tcp_get_buf (U16 size);
Nextern U16  tcp_max_dsize (U8 socket);
Nextern BOOL tcp_check_send (U8 socket);
Nextern U8   tcp_get_state (U8 socket);
Nextern BOOL tcp_send (U8 socket, U8 *buf, U16 dlen);
Nextern BOOL tcp_close (U8 socket);
Nextern BOOL tcp_abort (U8 socket);
Nextern void tcp_reset_window (U8 socket);
Nextern BOOL arp_cache_ip (U8 *ipadr, U8 type);
Nextern void ppp_listen (char const *user, char const *passw);
Nextern void ppp_connect (char const *dialnum, char const *user, char const *passw);
Nextern void ppp_close (void);
Nextern BOOL ppp_is_up (void);
Nextern void slip_listen (void);
Nextern void slip_connect (char const *dialnum);
Nextern void slip_close (void);
Nextern BOOL slip_is_up (void);
Nextern U8   get_host_by_name (U8 *hostn, void (*cbfunc)(U8 event, U8 *host_ip));
Nextern BOOL smtp_connect (U8 *ipadr, U16 port, void (*cbfunc)(U8 event));
Nextern void dhcp_disable (void);
Nextern BOOL igmp_join (U8 *group_ip);
Nextern BOOL igmp_leave (U8 *group_ip);
Nextern BOOL snmp_trap (U8 *manager_ip, U8 gen_trap, U8 spec_trap, U16 *obj_list);
Nextern BOOL snmp_set_community (const char *community);
N#ifdef __cplusplus               // EC++
S}
N#endif
N
N/*----------------------------------------------------------------------------
N * end of file
N *---------------------------------------------------------------------------*/
N  
N#endif
N 
L 16 "C:\Keil\ARM\RV31\INC\Net_Config.h" 2
N
N/* Definitions */
N#define ETH_ADRLEN      6         /* Ethernet Address Length in bytes        */
N#define IP_ADRLEN       4         /* IP Address Length in bytes              */
N#define OS_HEADER_LEN   4         /* TCPnet 'os_frame' header size           */
N                                  /* Frame Header length common for all      */
N#define PHY_HEADER_LEN  (2*ETH_ADRLEN + 2) /* network interfaces.            */
N#define ETH_MTU         1514      /* Ethernet Frame Max Transfer Unit        */
N#define PPP_PROT_IP     0x0021    /* PPP Protocol type: IP                   */
N#define TCP_DEF_WINSIZE 4380      /* TCP default window size                 */
N
N/* Network Interfaces */
N#define NETIF_ETH       0         /* Network interface: Ethernet             */
N#define NETIF_PPP       1         /* Network interface: PPP                  */
N#define NETIF_SLIP      2         /* Network interface: Slip                 */
N
N/* Telnet Definitions */
N#define TNET_LBUFSZ     96        /* Command Line buffer size (bytes)        */
N#define TNET_HISTSZ     128       /* Command History buffer size (bytes)     */
N#define TNET_FIFOSZ     128       /* Input character Fifo buffer (bytes)     */
N
N/* SNMP-MIB Definitions */
N#define MIB_INTEGER     0x02      /* MIB entry type INTEGER                  */
N#define MIB_OCTET_STR   0x04      /* MIB entry type OCTET_STRING             */
N#define MIB_OBJECT_ID   0x06      /* MIB entry type OBJECT_IDENTIFIER        */
N#define MIB_IP_ADDR     0x40      /* MIB entry type IP ADDRESS (U8[4])       */
N#define MIB_COUNTER     0x41      /* MIB entry type COUNTER (U32)            */
N#define MIB_GAUGE       0x42      /* MIB entry type GAUGE (U32)              */
N#define MIB_TIME_TICKS  0x43      /* MIB entry type TIME_TICKS               */
N#define MIB_ATR_RO      0x80      /* MIB entry attribute READ_ONLY           */
N#define MIB_OIDSZ       13        /* Max.size of Object ID value             */
N#define MIB_STRSZ       110       /* Max.size of Octet String variable       */
N#define MIB_READ        0         /* MIB entry Read access                   */
N#define MIB_WRITE       1         /* MIB entry Write access                  */
N
N/* SNMP-MIB Macros */
N#define MIB_STR(s)      sizeof(s)-1, s
N#define MIB_INT(o)      sizeof(o), (void *)&o
N#define MIB_IP(ip)      4, (void *)&ip 
N#define OID0(f,s)       (f*40 + s) 
N
N/* Debug Module Definitions */
N#define MODULE_MEM      0         /* Dynamic Memory Module ID                */
N#define MODULE_ETH      1         /* Ethernet Module ID                      */
N#define MODULE_PPP      2         /* PPP Module ID                           */
N#define MODULE_SLIP     3         /* SLIP Module ID                          */
N#define MODULE_ARP      4         /* ARP Module ID                           */
N#define MODULE_IP       5         /* IP Module ID                            */
N#define MODULE_ICMP     6         /* ICMP Module ID                          */
N#define MODULE_IGMP     7         /* IGMP Module ID                          */
N#define MODULE_UDP      8         /* UDP Module ID                           */
N#define MODULE_TCP      9         /* TCP Module ID                           */
N#define MODULE_NBNS     10        /* NBNS Module ID                          */
N#define MODULE_DHCP     11        /* DHCP Module ID                          */
N#define MODULE_DNS      12        /* DNS Module ID                           */
N#define MODULE_SNMP     13        /* SNMP Module ID                          */
N#define MODULE_APP      14        /* Application Modules ID                  */
N
N/*---------------------------------------------------------------------------*/
N
N#ifdef __cplusplus               // EC++
Sextern "C"  {
N#endif
N
Ntypedef struct os_frame {         /* << TCPnet system frame buffer struct >> */
N  U16 length;                     /* Total Length of data in frame           */
N  U16 index;                      /* Buffer Position Index                   */
N  U8  data[1];                    /* Buffer data (protocol headers + data)   */
N} OS_FRAME;
N
N
Ntypedef struct arp_info {         /* << ARP Cache Entry info >>              */
N  U8  State;                      /* ARP Cache entry current state           */
N  U8  Type;                       /* Cache Entry type                        */
N  U8  Retries;                    /* Number of Retries left                  */
N  U8  Tout;                       /* Cache Entry Timeout                     */
N  U8  HwAdr[ETH_ADRLEN];          /* Ethernet Hardware Address               */
X  U8  HwAdr[6];           
N  U8  IpAdr[IP_ADRLEN];           /* Ethernet IP Address                     */
X  U8  IpAdr[4];            
N} ARP_INFO;
N
N
Ntypedef struct igmp_info {        /* << IGMP Group info >>                   */
N  U8  State;                      /* Group membership current state          */
N  U8  Tout;                       /* Timeout Timer for sending reports       */
N  U8  GrpIpAdr[IP_ADRLEN];        /* Group IP address                        */
X  U8  GrpIpAdr[4];         
N} IGMP_INFO;
N
N
Ntypedef struct udp_info {         /* << UDP Socket info >>                   */
N  U8  State;                      /* UDP Socket entry current state          */
N  U8  McastTtl;                   /* MultiCast Time To Live                  */
N  U16 LocPort;                    /* Local UDP port of Socket                */
N  U8  Tos;                        /* UDP Type of Service                     */
N  U8  Opt;                        /* UDP Socket Options                      */
N                                  /* Application Event CallBack function     */
N  U16 (*cb_func)(U8 socket, U8 *rem_ip, U16 port, U8 *buf, U16 len);
N} UDP_INFO;
N
N
Ntypedef struct tcp_info {         /* << TCP Socket info >>                   */
N  U8  State;                      /* TCP Socket entry current state          */
N  U8  Type;                       /* TCP Socket type                         */
N  U8  Flags;                      /* State machine flags                     */
N  U8  Tos;                        /* Type of service allocated               */
N  U8  RemIpAdr[IP_ADRLEN];        /* Remote IP address                       */
X  U8  RemIpAdr[4];         
N  U16 RemPort;                    /* Remote TCP port                         */
N  U16 LocPort;                    /* Local TCP port                          */
N  U16 MaxSegSize;                 /* Transmit Max. Segment Size              */
N  U16 WinSize;                    /* Receive Window Size                     */
N  U32 SendSeq;                    /* Current Send Sequence Number not acked  */
N  U32 SendSeqNext;                /* Next Send Sequence Number               */
N  U32 RecSeqNext;                 /* Next Receive Sequence Number            */
N  U16 Tout;                       /* Socket idle timeout (in seconds)        */
N  U16 AliveTimer;                 /* Keep Alive timer value                  */
N  U16 RetryTimer;                 /* Retransmission timer value              */
N  U8  TxFlags;                    /* TCP Transmit Flags                      */
N  U8  Retries;                    /* Number of retries left before aborting  */
N  OS_FRAME *ReTransFrm;           /* Retransmission frame                    */
N                                  /* Application Event-CallBack function     */
N  U16 (*cb_func)(U8 socket, U8 event, U8 *p1, U16 p2);
N} TCP_INFO;
N
N
Ntypedef struct http_info {        /* << HTTP Session info >>                 */
N  U8  State;                      /* HTTP Session current state              */
N  U8  Socket;                     /* binded TCP Socket                       */
N  U16 Flags;                      /* State machine Flags                     */
N  U8  FType;                      /* File Type: html, jpeg, gif,...          */
N  U8  PostSt;                     /* POST method Processing Status           */
N  U16 DelimSz;                    /* Boundary delimiter size                 */
N  U32 CGIvar;                     /* CGI session private variable (cgi_func) */
N  U32 DLen;                       /* Data length (number of bytes to send)   */
N  U32 Count;                      /* Total number of bytes sent              */
N  U16 BCnt;                       /* Number of bytes sent in last packet     */
N  U8  Lang[6];                    /* Selected Web Language: en-us, de, fr .. */
N  U32 LMDate;                     /* Last Modified Date (UTC format)         */
N  U8 *Script;                     /* Script Buffer pointer                   */
N  U8 *pDelim;                     /* Multipart Boundary delimiter value      */
N  void *sFile;                    /* Script Interpreter File pointer         */
N  void *dFile;                    /* Data File pointer                       */
N} HTTP_INFO;
N
N
Ntypedef struct http_file {        /* << HTTP Internal File info >>           */
N  const U32 Id;                   /* File Name Id (CRC32 value of file name) */
N  const U8 *Start;                /* File Start Address in ROM               */
N} HTTP_FILE;
N
N
Ntypedef struct tnet_info {        /* << Telnet Session info >>               */
N  U8  State;                      /* Telnet Session current state            */
N  U8  Socket;                     /* binded TCP Socket                       */
N  U8  Flags;                      /* State machine Flags                     */
N  U8  BCnt;                       /* Received Data byte count                */
N  U16 Tout;                       /* Timeout delay counter                   */
N  U8  Widx;                       /* Fifo buffer Write index                 */
N  U8  Ridx;                       /* Fifo buffer Read index                  */
N  U32 SVar;                       /* Session private var. (tnet_process_cmd) */
N  U8  LBuf[TNET_LBUFSZ];          /* Data Line Buffer                        */
X  U8  LBuf[96];           
N  U8  Fifo[TNET_FIFOSZ];          /* Fifo Buffer for received line/keycodes  */
X  U8  Fifo[128];           
N  U8  hNext;                      /* History command next position           */
N  U8  hCurr;                      /* History command current position        */
N  U8  Hist[TNET_HISTSZ];          /* Command History buffer                  */
X  U8  Hist[128];           
N} TNET_INFO;
N
N
Ntypedef struct tftp_info {        /* << TFTP Session info >>                 */
N  U8  State;                      /* TFTP Session current state              */
N  U8  Retries;                    /* Number of retries                       */
N  U8  Flags;                      /* State machine Flags                     */
N  U16 Timer;                      /* Timeout Timer value                     */
N  U8  RemIpAdr[IP_ADRLEN];        /* Remote IP address                       */
X  U8  RemIpAdr[4];         
N  U16 RemPort;                    /* Remote UDP port                         */
N  U16 BlockNr;                    /* Block Number                            */
N  void *File;                     /* File Handle pointer                     */
N  U32 FPos;                       /* File Position indicator                 */
N} TFTP_INFO;
N
N
Ntypedef struct ftp_info {         /* << FTP Session info >>                  */
N  U8  State;                      /* FTP Session current state               */
N  U8  Socket;                     /* binded TCP Control Socket               */
N  U8  Flags;                      /* State machine Flags                     */
N  U8  Resp;                       /* FTP Server Response Code                */
N  U8  RemIpAdr[IP_ADRLEN];        /* Client IP address                       */
X  U8  RemIpAdr[4];         
N  U16 DPort;                      /* TCP Data port (Server or Client)        */
N  U8  DSocket;                    /* TCP Data Socket                         */
N  U8  PathLen;                    /* Size of the Path string                 */
N  U8 *Path;                       /* Current Working Directory               */
N  U8 *Name;                       /* Absolute File/Folder Path Name          */
N  void *File;                     /* File Handle pointer                     */
N} FTP_INFO;
N
N
Ntypedef struct dns_cache {        /* << DNS Cache Entry info >>              */
N  U32 HostId;                     /* Host Id (CRC32 value of host name)      */
N  U32 Ttl;                        /* Cache Entry Time To Live                */
N  U8  IpAdr[IP_ADRLEN];           /* Ethernet IP Address                     */
X  U8  IpAdr[4];            
N} DNS_CACHE;
N
N
Ntypedef struct localm {           /* << Local Machine info >>                */
N  U8 IpAdr[IP_ADRLEN];            /* Local IP Address                        */
X  U8 IpAdr[4];             
N  U8 DefGW[IP_ADRLEN];            /* Default GateWay                         */
X  U8 DefGW[4];             
N  U8 NetMask[IP_ADRLEN];          /* Net Mask                                */
X  U8 NetMask[4];           
N  U8 PriDNS[IP_ADRLEN];           /* Primary DNS Server                      */
X  U8 PriDNS[4];            
N  U8 SecDNS[IP_ADRLEN];           /* Secondary DNS Server                    */
X  U8 SecDNS[4];            
N} LOCALM;
N
N
Ntypedef struct remotem {          /* << Remote Machine Info >>               */
N  U8 IpAdr[IP_ADRLEN];            /* Remote IP address                       */
X  U8 IpAdr[4];             
N  U8 HwAdr[ETH_ADRLEN];           /* Remote Hardware Address                 */
X  U8 HwAdr[6];            
N} REMOTEM;
N
N
Ntypedef struct mib_entry {        /* << SNMP-MIB Entry Info >>               */
N  U8   Type;                      /* Object Type                             */
N  U8   OidLen;                    /* Object ID length                        */
N  U8   Oid[MIB_OIDSZ];            /* Object ID value                         */
X  U8   Oid[13];             
N  U8   ValSz;                     /* Size of a Variable                      */
N  void *Val;                      /* Pointer to a variable                   */
N  void (*cb_func)(int mode);      /* Write/Read event callback function      */
N} MIB_ENTRY;
N
N
Ntypedef enum {                    /* << Fatal System Error Codes >>          */
N  ERR_MEM_ALLOC,
N  ERR_MEM_FREE,
N  ERR_MEM_CORRUPT,
N  ERR_UDP_ALLOC,
N  ERR_TCP_ALLOC,
N  ERR_TCP_STATE
N} ERROR_CODE;
N
N
N/*----------------------------------------------------------------------------
N *      Functions
N *---------------------------------------------------------------------------*/
N
N/* Net_Config.c */
Nextern void init_system (void);
Nextern void run_system (void);
Nextern void process_hl_igmp (OS_FRAME *frame);
Nextern void process_hl_udp (OS_FRAME *frame);
Nextern void process_hl_tcp (OS_FRAME *frame);
Nextern BOOL dispatch_frame (OS_FRAME *frame, U8 netif);
Nextern BOOL eth_chk_adr (OS_FRAME *frame);
Nextern U8  *eth_get_adr (U8 *ipadr);
N__weak void arp_notify (void);
Nextern void sys_error (ERROR_CODE code);
N
N/* at_Mem.c */
Nextern OS_FRAME *alloc_mem (U32 byte_size);
Nextern void free_mem (OS_FRAME *mem_ptr);
N
N/* at_Ethernet.c */
Nextern void init_eth_link (void);
Nextern void run_eth_link (void);
Nextern void put_in_queue (OS_FRAME *frame);
Nextern BOOL eth_send_frame (OS_FRAME *frame);
N
N/* at_Ppp.c */
Nextern void init_ppp_link (void);
Nextern void run_ppp_link (void);
Nextern BOOL ppp_send_frame (OS_FRAME *frame, U16 prot);
N
N/* at_Slip.c */
Nextern void init_slip_link (void);
Nextern void run_slip_link (void);
Nextern BOOL slip_send_frame (OS_FRAME *frame);
N
N/* at_Lib.c */
Nextern int  mem_copy (void *dp, void *sp, int len);
Nextern void mem_rcopy (void *dp, void *sp, int len);
Nextern BOOL mem_comp (void *sp1, void *sp2, int len);
Nextern void mem_set (void *dp, U8 val, int len);
Nextern BOOL mem_test (void *sp, U8 val, int len);
Nextern BOOL str_scomp (U8 *sp, U8 const *cp);
Nextern int  str_copy (U8 *dp, U8 *sp);
Nextern void str_up_case (U8 *dp, U8 *sp);
Nextern U16  SwapB (U16 w16);
Nextern U16  get_u16 (U8 *p16);
Nextern U32  get_u32 (U8 *p32);
Nextern void set_u32 (U8 *p32, U32 val);
N
N/* at_Arp.c */
Nextern void arp_send_req (U32 entry);
N
N/* at_Igmp.c */
Nextern void init_igmp (void);
Nextern void run_igmp_host (void);
Nextern void process_igmp (OS_FRAME *frame);
N
N/* at_Udp.c */
Nextern void init_udp (void);
Nextern void process_udp (OS_FRAME *frame);
N
N/* at_Tcp.c */
Nextern void init_tcp (void);
Nextern void tcp_poll_sockets (void);
Nextern void process_tcp (OS_FRAME *frame_r);
N
N/* at_Http.c */
Nextern void init_http (void);
Nextern void run_http_server (void);
Nextern void *http_fopen (U8 *name);
Nextern void http_fclose (void *file);
Nextern U16  http_fread (void *file, U8 *buf, U16 len);
Nextern BOOL http_fgets (void *file, U8 *buf, U16 size);
Nextern U32  http_finfo (U8 *name);
Nextern void cgi_process_var (U8 *qstr);
Nextern void cgi_process_data (U8 code, U8 *dat, U16 len);
Nextern U16  cgi_func (U8 *env, U8 *buf, U16 buflen, U32 *pcgi);
Nextern U8  *cgx_content_type (void);
Nextern BOOL http_accept_host (U8 *rem_ip, U16 rem_port);
Nextern U8  *http_get_var (U8 *env, void *ansi, U16 maxlen);
Nextern U8  *http_get_lang (void);
Nextern void http_get_info (REMOTEM *info);
Nextern U8   http_get_session (void);
Nextern U8  *http_get_content_type (void);
Nextern U32  http_date (RL_TIME *time);
N
N/* at_Telnet.c */
Nextern void init_tnet (void);
Nextern void run_tnet_server (void);
Nextern U16  tnet_cbfunc (U8 code, U8 *buf, U16 buflen);
Nextern U16  tnet_process_cmd (U8 *cmd, U8 *buf, U16 buflen, U32 *pvar);
Nextern BOOL tnet_ccmp (U8 *buf, U8 *cmd);
Nextern void tnet_set_delay (U16 cnt);
Nextern void tnet_get_info (REMOTEM *info);
Nextern U8   tnet_get_session (void);
Nextern BOOL tnet_msg_poll (U8 session);
N
N/* at_Tftp.c */
Nextern void init_tftp (void);
Nextern void run_tftp_server (void);
Nextern void *tftp_fopen (U8 *fname, U8 *mode);
Nextern void tftp_fclose (void *file);
Nextern U16  tftp_fread (void *file, U32 fpos, U8 *buf);
Nextern U16  tftp_fwrite (void *file, U8 *buf, U16 len);
N
N/* at_Ftp.c */
Nextern void init_ftp (void);
Nextern void run_ftp_server (void);
Nextern void *ftp_fopenftp_fopen (U8 *fname, U8 *mode);
Nextern void ftp_fclose (void *file);
Nextern U16  ftp_fread (void *file, U8 *buf, U16 len);
Nextern U16  ftp_fwrite (void *file, U8 *buf, U16 len);
Nextern BOOL ftp_fdelete (U8 *fname);
Nextern BOOL ftp_frename (U8 *fname, U8 *newn);
Nextern U16  ftp_ffind (U8 code, U8 *buf, U8 *mask, U16 len);
N
N/* at_Dhcp.c */
Nextern void init_dhcp (void);
Nextern void run_dhcp_client (void);
N
N/* at_Nbns.c */
Nextern void init_nbns (void);
N
N/* at_Dns.c */
Nextern void init_dns (void);
Nextern void run_dns_client (void);
Nextern U8   get_host_by_name (U8 *hostn, void (*cbfunc)(U8, U8 *));
N
N/* at_Smtp.c */
Nextern void init_smtp (void);
Nextern void run_smtp_client (void);
Nextern U16  smtp_cbfunc (U8 code, U8 *buf, U16 buflen, U32 *pvar);
Nextern BOOL smtp_accept_auth (U8 *srv_ip);
N
N/* Ethernet Device Driver */
Nextern void init_ethernet (void);
Nextern void send_frame (OS_FRAME *frame);
Nextern void poll_ethernet (void);
Nextern void int_enable_eth (void);
Nextern void int_disable_eth (void);
N
N/* Serial Device Driver */
Nextern void init_serial (void);
Nextern int  com_getchar (void);
Nextern BOOL com_putchar (U8 c);
Nextern BOOL com_tx_active (void);
N
N/* Modem Device Driver */
Nextern void init_modem (void);
Nextern void modem_dial (U8 *dialnum);
Nextern void modem_hangup (void);
Nextern void modem_listen (void);
Nextern BOOL modem_online (void);
Nextern BOOL modem_process (U8 ch);
Nextern void modem_run (void);
N
N#ifdef __cplusplus               // EC++
S}
N#endif
N
N/*----------------------------------------------------------------------------
N * end of file
N *---------------------------------------------------------------------------*/
N
N#endif
N
L 13 "src\tcpip\EMAC_LPC17xx.c" 2
N#include "EMAC_LPC17xx.h"
L 1 "C:\Keil\ARM\RL\TCPnet\Drivers\EMAC_LPC17xx.h" 1
N/*----------------------------------------------------------------------------
N *      RL-ARM - TCPnet
N *----------------------------------------------------------------------------
N *      Name:    EMAC_LPC17xx.h
N *      Purpose: NXP LPC1768 EMAC Ethernet Controller Driver definitions
N *      Rev.:    V4.13
N *----------------------------------------------------------------------------
N *      This code is part of the RealView Run-Time Library.
N *      Copyright (c) 2004-2010 KEIL - An ARM Company. All rights reserved.
N *---------------------------------------------------------------------------*/
N
N#ifndef __EMAC_LPC17XX_H
N#define __EMAC_LPC17XX_H
N
N#define MDIO    0x00000200
N#define MDC     0x00000100
N
N/* EMAC Memory Buffer configuration for 16K Ethernet RAM. */
N#define NUM_RX_FRAG         4           /* Num.of RX Fragments 4*1536= 6.0kB */
N#define NUM_TX_FRAG         3           /* Num.of TX Fragments 3*1536= 4.6kB */
N#define ETH_FRAG_SIZE       1536        /* Packet Fragment size 1536 Bytes   */
N
N#define ETH_MAX_FLEN        1536        /* Max. Ethernet Frame Size          */
N
Ntypedef struct {                        /* RX Descriptor struct              */
N  U32 Packet;
N  U32 Ctrl;
N} RX_Desc;
N
Ntypedef struct {                        /* RX Status struct                  */
N  U32 Info;
N  U32 HashCRC;
N} RX_Stat;
N
Ntypedef struct {                        /* TX Descriptor struct              */
N  U32 Packet;
N  U32 Ctrl;
N} TX_Desc;
N
Ntypedef struct {                        /* TX Status struct                  */
N  U32 Info;
N} TX_Stat;
N
N
N/* MAC Configuration Register 1 */
N#define MAC1_REC_EN         0x00000001  /* Receive Enable                    */
N#define MAC1_PASS_ALL       0x00000002  /* Pass All Receive Frames           */
N#define MAC1_RX_FLOWC       0x00000004  /* RX Flow Control                   */
N#define MAC1_TX_FLOWC       0x00000008  /* TX Flow Control                   */
N#define MAC1_LOOPB          0x00000010  /* Loop Back Mode                    */
N#define MAC1_RES_TX         0x00000100  /* Reset TX Logic                    */
N#define MAC1_RES_MCS_TX     0x00000200  /* Reset MAC TX Control Sublayer     */
N#define MAC1_RES_RX         0x00000400  /* Reset RX Logic                    */
N#define MAC1_RES_MCS_RX     0x00000800  /* Reset MAC RX Control Sublayer     */
N#define MAC1_SIM_RES        0x00004000  /* Simulation Reset                  */
N#define MAC1_SOFT_RES       0x00008000  /* Soft Reset MAC                    */
N
N/* MAC Configuration Register 2 */
N#define MAC2_FULL_DUP       0x00000001  /* Full Duplex Mode                  */
N#define MAC2_FRM_LEN_CHK    0x00000002  /* Frame Length Checking             */
N#define MAC2_HUGE_FRM_EN    0x00000004  /* Huge Frame Enable                 */
N#define MAC2_DLY_CRC        0x00000008  /* Delayed CRC Mode                  */
N#define MAC2_CRC_EN         0x00000010  /* Append CRC to every Frame         */
N#define MAC2_PAD_EN         0x00000020  /* Pad all Short Frames              */
N#define MAC2_VLAN_PAD_EN    0x00000040  /* VLAN Pad Enable                   */
N#define MAC2_ADET_PAD_EN    0x00000080  /* Auto Detect Pad Enable            */
N#define MAC2_PPREAM_ENF     0x00000100  /* Pure Preamble Enforcement         */
N#define MAC2_LPREAM_ENF     0x00000200  /* Long Preamble Enforcement         */
N#define MAC2_NO_BACKOFF     0x00001000  /* No Backoff Algorithm              */
N#define MAC2_BACK_PRESSURE  0x00002000  /* Backoff Presurre / No Backoff     */
N#define MAC2_EXCESS_DEF     0x00004000  /* Excess Defer                      */
N
N/* Back-to-Back Inter-Packet-Gap Register */
N#define IPGT_FULL_DUP       0x00000015  /* Recommended value for Full Duplex */
N#define IPGT_HALF_DUP       0x00000012  /* Recommended value for Half Duplex */
N
N/* Non Back-to-Back Inter-Packet-Gap Register */
N#define IPGR_DEF            0x00000012  /* Recommended value                 */
N
N/* Collision Window/Retry Register */
N#define CLRT_DEF            0x0000370F  /* Default value                     */
N
N/* PHY Support Register */
N#define SUPP_SPEED          0x00000100  /* Reduced MII Logic Current Speed   */
N#define SUPP_RES_RMII       0x00000800  /* Reset Reduced MII Logic           */
N
N/* Test Register */
N#define TEST_SHCUT_PQUANTA  0x00000001  /* Shortcut Pause Quanta             */
N#define TEST_TST_PAUSE      0x00000002  /* Test Pause                        */
N#define TEST_TST_BACKP      0x00000004  /* Test Back Pressure                */
N
N/* MII Management Configuration Register */
N#define MCFG_SCAN_INC       0x00000001  /* Scan Increment PHY Address        */
N#define MCFG_SUPP_PREAM     0x00000002  /* Suppress Preamble                 */
N#define MCFG_CLK_SEL        0x0000003C  /* Clock Select Mask                 */
N#define MCFG_RES_MII        0x00008000  /* Reset MII Management Hardware     */
N
N/* MII Management Command Register */
N#define MCMD_READ           0x00000001  /* MII Read                          */
N#define MCMD_SCAN           0x00000002  /* MII Scan continuously             */
N
N#define MII_WR_TOUT         0x00050000  /* MII Write timeout count           */
N#define MII_RD_TOUT         0x00050000  /* MII Read timeout count            */
N
N/* MII Management Address Register */
N#define MADR_REG_ADR        0x0000001F  /* MII Register Address Mask         */
N#define MADR_PHY_ADR        0x00001F00  /* PHY Address Mask                  */
N
N/* MII Management Indicators Register */
N#define MIND_BUSY           0x00000001  /* MII is Busy                       */
N#define MIND_SCAN           0x00000002  /* MII Scanning in Progress          */
N#define MIND_NOT_VAL        0x00000004  /* MII Read Data not valid           */
N#define MIND_MII_LINK_FAIL  0x00000008  /* MII Link Failed                   */
N
N/* Command Register */
N#define CR_RX_EN            0x00000001  /* Enable Receive                    */
N#define CR_TX_EN            0x00000002  /* Enable Transmit                   */
N#define CR_REG_RES          0x00000008  /* Reset Host Registers              */
N#define CR_TX_RES           0x00000010  /* Reset Transmit Datapath           */
N#define CR_RX_RES           0x00000020  /* Reset Receive Datapath            */
N#define CR_PASS_RUNT_FRM    0x00000040  /* Pass Runt Frames                  */
N#define CR_PASS_RX_FILT     0x00000080  /* Pass RX Filter                    */
N#define CR_TX_FLOW_CTRL     0x00000100  /* TX Flow Control                   */
N#define CR_RMII             0x00000200  /* Reduced MII Interface             */
N#define CR_FULL_DUP         0x00000400  /* Full Duplex                       */
N
N/* Status Register */
N#define SR_RX_EN            0x00000001  /* Enable Receive                    */
N#define SR_TX_EN            0x00000002  /* Enable Transmit                   */
N
N/* Transmit Status Vector 0 Register */
N#define TSV0_CRC_ERR        0x00000001  /* CRC error                         */
N#define TSV0_LEN_CHKERR     0x00000002  /* Length Check Error                */
N#define TSV0_LEN_OUTRNG     0x00000004  /* Length Out of Range               */
N#define TSV0_DONE           0x00000008  /* Tramsmission Completed            */
N#define TSV0_MCAST          0x00000010  /* Multicast Destination             */
N#define TSV0_BCAST          0x00000020  /* Broadcast Destination             */
N#define TSV0_PKT_DEFER      0x00000040  /* Packet Deferred                   */
N#define TSV0_EXC_DEFER      0x00000080  /* Excessive Packet Deferral         */
N#define TSV0_EXC_COLL       0x00000100  /* Excessive Collision               */
N#define TSV0_LATE_COLL      0x00000200  /* Late Collision Occured            */
N#define TSV0_GIANT          0x00000400  /* Giant Frame                       */
N#define TSV0_UNDERRUN       0x00000800  /* Buffer Underrun                   */
N#define TSV0_BYTES          0x0FFFF000  /* Total Bytes Transferred           */
N#define TSV0_CTRL_FRAME     0x10000000  /* Control Frame                     */
N#define TSV0_PAUSE          0x20000000  /* Pause Frame                       */
N#define TSV0_BACK_PRESS     0x40000000  /* Backpressure Method Applied       */
N#define TSV0_VLAN           0x80000000  /* VLAN Frame                        */
N
N/* Transmit Status Vector 1 Register */
N#define TSV1_BYTE_CNT       0x0000FFFF  /* Transmit Byte Count               */
N#define TSV1_COLL_CNT       0x000F0000  /* Transmit Collision Count          */
N
N/* Receive Status Vector Register */
N#define RSV_BYTE_CNT        0x0000FFFF  /* Receive Byte Count                */
N#define RSV_PKT_IGNORED     0x00010000  /* Packet Previously Ignored         */
N#define RSV_RXDV_SEEN       0x00020000  /* RXDV Event Previously Seen        */
N#define RSV_CARR_SEEN       0x00040000  /* Carrier Event Previously Seen     */
N#define RSV_REC_CODEV       0x00080000  /* Receive Code Violation            */
N#define RSV_CRC_ERR         0x00100000  /* CRC Error                         */
N#define RSV_LEN_CHKERR      0x00200000  /* Length Check Error                */
N#define RSV_LEN_OUTRNG      0x00400000  /* Length Out of Range               */
N#define RSV_REC_OK          0x00800000  /* Frame Received OK                 */
N#define RSV_MCAST           0x01000000  /* Multicast Frame                   */
N#define RSV_BCAST           0x02000000  /* Broadcast Frame                   */
N#define RSV_DRIB_NIBB       0x04000000  /* Dribble Nibble                    */
N#define RSV_CTRL_FRAME      0x08000000  /* Control Frame                     */
N#define RSV_PAUSE           0x10000000  /* Pause Frame                       */
N#define RSV_UNSUPP_OPC      0x20000000  /* Unsupported Opcode                */
N#define RSV_VLAN            0x40000000  /* VLAN Frame                        */
N
N/* Flow Control Counter Register */
N#define FCC_MIRR_CNT        0x0000FFFF  /* Mirror Counter                    */
N#define FCC_PAUSE_TIM       0xFFFF0000  /* Pause Timer                       */
N
N/* Flow Control Status Register */
N#define FCS_MIRR_CNT        0x0000FFFF  /* Mirror Counter Current            */
N
N/* Receive Filter Control Register */
N#define RFC_UCAST_EN        0x00000001  /* Accept Unicast Frames Enable      */
N#define RFC_BCAST_EN        0x00000002  /* Accept Broadcast Frames Enable    */
N#define RFC_MCAST_EN        0x00000004  /* Accept Multicast Frames Enable    */
N#define RFC_UCAST_HASH_EN   0x00000008  /* Accept Unicast Hash Filter Frames */
N#define RFC_MCAST_HASH_EN   0x00000010  /* Accept Multicast Hash Filter Fram.*/
N#define RFC_PERFECT_EN      0x00000020  /* Accept Perfect Match Enable       */
N#define RFC_MAGP_WOL_EN     0x00001000  /* Magic Packet Filter WoL Enable    */
N#define RFC_PFILT_WOL_EN    0x00002000  /* Perfect Filter WoL Enable         */
N
N/* Receive Filter WoL Status/Clear Registers */
N#define WOL_UCAST           0x00000001  /* Unicast Frame caused WoL          */
N#define WOL_BCAST           0x00000002  /* Broadcast Frame caused WoL        */
N#define WOL_MCAST           0x00000004  /* Multicast Frame caused WoL        */
N#define WOL_UCAST_HASH      0x00000008  /* Unicast Hash Filter Frame WoL     */
N#define WOL_MCAST_HASH      0x00000010  /* Multicast Hash Filter Frame WoL   */
N#define WOL_PERFECT         0x00000020  /* Perfect Filter WoL                */
N#define WOL_RX_FILTER       0x00000080  /* RX Filter caused WoL              */
N#define WOL_MAG_PACKET      0x00000100  /* Magic Packet Filter caused WoL    */
N
N/* Interrupt Status/Enable/Clear/Set Registers */
N#define INT_RX_OVERRUN      0x00000001  /* Overrun Error in RX Queue         */
N#define INT_RX_ERR          0x00000002  /* Receive Error                     */
N#define INT_RX_FIN          0x00000004  /* RX Finished Process Descriptors   */
N#define INT_RX_DONE         0x00000008  /* Receive Done                      */
N#define INT_TX_UNDERRUN     0x00000010  /* Transmit Underrun                 */
N#define INT_TX_ERR          0x00000020  /* Transmit Error                    */
N#define INT_TX_FIN          0x00000040  /* TX Finished Process Descriptors   */
N#define INT_TX_DONE         0x00000080  /* Transmit Done                     */
N#define INT_SOFT_INT        0x00001000  /* Software Triggered Interrupt      */
N#define INT_WAKEUP          0x00002000  /* Wakeup Event Interrupt            */
N
N/* Power Down Register */
N#define PD_POWER_DOWN       0x80000000  /* Power Down MAC                    */
N
N/* RX Descriptor Control Word */
N#define RCTRL_SIZE          0x000007FF  /* Buffer size mask                  */
N#define RCTRL_INT           0x80000000  /* Generate RxDone Interrupt         */
N
N/* RX Status Hash CRC Word */
N#define RHASH_SA            0x000001FF  /* Hash CRC for Source Address       */
N#define RHASH_DA            0x001FF000  /* Hash CRC for Destination Address  */
N
N/* RX Status Information Word */
N#define RINFO_SIZE          0x000007FF  /* Data size in bytes                */
N#define RINFO_CTRL_FRAME    0x00040000  /* Control Frame                     */
N#define RINFO_VLAN          0x00080000  /* VLAN Frame                        */
N#define RINFO_FAIL_FILT     0x00100000  /* RX Filter Failed                  */
N#define RINFO_MCAST         0x00200000  /* Multicast Frame                   */
N#define RINFO_BCAST         0x00400000  /* Broadcast Frame                   */
N#define RINFO_CRC_ERR       0x00800000  /* CRC Error in Frame                */
N#define RINFO_SYM_ERR       0x01000000  /* Symbol Error from PHY             */
N#define RINFO_LEN_ERR       0x02000000  /* Length Error                      */
N#define RINFO_RANGE_ERR     0x04000000  /* Range Error (exceeded max. size)  */
N#define RINFO_ALIGN_ERR     0x08000000  /* Alignment Error                   */
N#define RINFO_OVERRUN       0x10000000  /* Receive overrun                   */
N#define RINFO_NO_DESCR      0x20000000  /* No new Descriptor available       */
N#define RINFO_LAST_FLAG     0x40000000  /* Last Fragment in Frame            */
N#define RINFO_ERR           0x80000000  /* Error Occured (OR of all errors)  */
N
N#define RINFO_ERR_MASK     (RINFO_FAIL_FILT | RINFO_CRC_ERR   | RINFO_SYM_ERR | \
N                            RINFO_LEN_ERR   | RINFO_ALIGN_ERR | RINFO_OVERRUN)
X#define RINFO_ERR_MASK     (RINFO_FAIL_FILT | RINFO_CRC_ERR   | RINFO_SYM_ERR |                             RINFO_LEN_ERR   | RINFO_ALIGN_ERR | RINFO_OVERRUN)
N
N/* TX Descriptor Control Word */
N#define TCTRL_SIZE          0x000007FF  /* Size of data buffer in bytes      */
N#define TCTRL_OVERRIDE      0x04000000  /* Override Default MAC Registers    */
N#define TCTRL_HUGE          0x08000000  /* Enable Huge Frame                 */
N#define TCTRL_PAD           0x10000000  /* Pad short Frames to 64 bytes      */
N#define TCTRL_CRC           0x20000000  /* Append a hardware CRC to Frame    */
N#define TCTRL_LAST          0x40000000  /* Last Descriptor for TX Frame      */
N#define TCTRL_INT           0x80000000  /* Generate TxDone Interrupt         */
N
N/* TX Status Information Word */
N#define TINFO_COL_CNT       0x01E00000  /* Collision Count                   */
N#define TINFO_DEFER         0x02000000  /* Packet Deferred (not an error)    */
N#define TINFO_EXCESS_DEF    0x04000000  /* Excessive Deferral                */
N#define TINFO_EXCESS_COL    0x08000000  /* Excessive Collision               */
N#define TINFO_LATE_COL      0x10000000  /* Late Collision Occured            */
N#define TINFO_UNDERRUN      0x20000000  /* Transmit Underrun                 */
N#define TINFO_NO_DESCR      0x40000000  /* No new Descriptor available       */
N#define TINFO_ERR           0x80000000  /* Error Occured (OR of all errors)  */
N
N/* ENET Device Revision ID */
N#define OLD_EMAC_MODULE_ID  0x39022000  /* Rev. ID for first rev '-'         */
N
N/* DP83848C PHY Registers */
N#define PHY_REG_BMCR        0x00        /* Basic Mode Control Register       */
N#define PHY_REG_BMSR        0x01        /* Basic Mode Status Register        */
N#define PHY_REG_IDR1        0x02        /* PHY Identifier 1                  */
N#define PHY_REG_IDR2        0x03        /* PHY Identifier 2                  */
N#define PHY_REG_ANAR        0x04        /* Auto-Negotiation Advertisement    */
N#define PHY_REG_ANLPAR      0x05        /* Auto-Neg. Link Partner Abitily    */
N#define PHY_REG_ANER        0x06        /* Auto-Neg. Expansion Register      */
N#define PHY_REG_ANNPTR      0x07        /* Auto-Neg. Next Page TX            */
N
N/* PHY Extended Registers */
N#define PHY_REG_STS         0x10        /* Status Register                   */
N#define PHY_REG_MICR        0x11        /* MII Interrupt Control Register    */
N#define PHY_REG_MISR        0x12        /* MII Interrupt Status Register     */
N#define PHY_REG_FCSCR       0x14        /* False Carrier Sense Counter       */
N#define PHY_REG_RECR        0x15        /* Receive Error Counter             */
N#define PHY_REG_PCSR        0x16        /* PCS Sublayer Config. and Status   */
N#define PHY_REG_RBR         0x17        /* RMII and Bypass Register          */
N#define PHY_REG_LEDCR       0x18        /* LED Direct Control Register       */
N#define PHY_REG_PHYCR       0x19        /* PHY Control Register              */
N#define PHY_REG_10BTSCR     0x1A        /* 10Base-T Status/Control Register  */
N#define PHY_REG_CDCTRL1     0x1B        /* CD Test Control and BIST Extens.  */
N#define PHY_REG_EDCR        0x1D        /* Energy Detect Control Register    */
N
N#define PHY_FULLD_100M      0x2100      /* Full Duplex 100Mbit               */
N#define PHY_HALFD_100M      0x2000      /* Half Duplex 100Mbit               */
N#define PHY_FULLD_10M       0x0100      /* Full Duplex 10Mbit                */
N#define PHY_HALFD_10M       0x0000      /* Half Duplex 10MBit                */
N#define PHY_AUTO_NEG        0x3000      /* Select Auto Negotiation           */
N
N#define DP83848C_DEF_ADR    0x0100      /* Default PHY device address        */
N#define DP83848C_ID         0x20005C90  /* PHY Identifier                    */
N
N#endif
N
N/*----------------------------------------------------------------------------
N * end of file
N *---------------------------------------------------------------------------*/
L 14 "src\tcpip\EMAC_LPC17xx.c" 2
N#include <LPC17xx.h>                    /* LPC17xx definitions               */
L 1 "C:\Keil\ARM\INC\NXP\LPC17xx\LPC17xx.h" 1
N/******************************************************************************
N * @file:    LPC17xx.h
N * @purpose: CMSIS Cortex-M3 Core Peripheral Access Layer Header File for 
N *           NXP LPC17xx Device Series 
N * @version: V1.09
N * @date:    17. March 2010
N *----------------------------------------------------------------------------
N *
N * Copyright (C) 2008 ARM Limited. All rights reserved.
N *
N * ARM Limited (ARM) is supplying this software for use with Cortex-M3 
N * processor based microcontrollers.  This file can be freely distributed 
N * within development tools that are supporting such ARM based processors. 
N *
N * THIS SOFTWARE IS PROVIDED "AS IS".  NO WARRANTIES, WHETHER EXPRESS, IMPLIED
N * OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF
N * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.
N * ARM SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR
N * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
N *
N ******************************************************************************/
N
N
N#ifndef __LPC17xx_H__
N#define __LPC17xx_H__
N
N/*
N * ==========================================================================
N * ---------- Interrupt Number Definition -----------------------------------
N * ==========================================================================
N */
N
Ntypedef enum IRQn
N{
N/******  Cortex-M3 Processor Exceptions Numbers ***************************************************/
N  NonMaskableInt_IRQn           = -14,      /*!< 2 Non Maskable Interrupt                         */
N  MemoryManagement_IRQn         = -12,      /*!< 4 Cortex-M3 Memory Management Interrupt          */
N  BusFault_IRQn                 = -11,      /*!< 5 Cortex-M3 Bus Fault Interrupt                  */
N  UsageFault_IRQn               = -10,      /*!< 6 Cortex-M3 Usage Fault Interrupt                */
N  SVCall_IRQn                   = -5,       /*!< 11 Cortex-M3 SV Call Interrupt                   */
N  DebugMonitor_IRQn             = -4,       /*!< 12 Cortex-M3 Debug Monitor Interrupt             */
N  PendSV_IRQn                   = -2,       /*!< 14 Cortex-M3 Pend SV Interrupt                   */
N  SysTick_IRQn                  = -1,       /*!< 15 Cortex-M3 System Tick Interrupt               */
N
N/******  LPC17xx Specific Interrupt Numbers *******************************************************/
N  WDT_IRQn                      = 0,        /*!< Watchdog Timer Interrupt                         */
N  TIMER0_IRQn                   = 1,        /*!< Timer0 Interrupt                                 */
N  TIMER1_IRQn                   = 2,        /*!< Timer1 Interrupt                                 */
N  TIMER2_IRQn                   = 3,        /*!< Timer2 Interrupt                                 */
N  TIMER3_IRQn                   = 4,        /*!< Timer3 Interrupt                                 */
N  UART0_IRQn                    = 5,        /*!< UART0 Interrupt                                  */
N  UART1_IRQn                    = 6,        /*!< UART1 Interrupt                                  */
N  UART2_IRQn                    = 7,        /*!< UART2 Interrupt                                  */
N  UART3_IRQn                    = 8,        /*!< UART3 Interrupt                                  */
N  PWM1_IRQn                     = 9,        /*!< PWM1 Interrupt                                   */
N  I2C0_IRQn                     = 10,       /*!< I2C0 Interrupt                                   */
N  I2C1_IRQn                     = 11,       /*!< I2C1 Interrupt                                   */
N  I2C2_IRQn                     = 12,       /*!< I2C2 Interrupt                                   */
N  SPI_IRQn                      = 13,       /*!< SPI Interrupt                                    */
N  SSP0_IRQn                     = 14,       /*!< SSP0 Interrupt                                   */
N  SSP1_IRQn                     = 15,       /*!< SSP1 Interrupt                                   */
N  PLL0_IRQn                     = 16,       /*!< PLL0 Lock (Main PLL) Interrupt                   */
N  RTC_IRQn                      = 17,       /*!< Real Time Clock Interrupt                        */
N  EINT0_IRQn                    = 18,       /*!< External Interrupt 0 Interrupt                   */
N  EINT1_IRQn                    = 19,       /*!< External Interrupt 1 Interrupt                   */
N  EINT2_IRQn                    = 20,       /*!< External Interrupt 2 Interrupt                   */
N  EINT3_IRQn                    = 21,       /*!< External Interrupt 3 Interrupt                   */
N  ADC_IRQn                      = 22,       /*!< A/D Converter Interrupt                          */
N  BOD_IRQn                      = 23,       /*!< Brown-Out Detect Interrupt                       */
N  USB_IRQn                      = 24,       /*!< USB Interrupt                                    */
N  CAN_IRQn                      = 25,       /*!< CAN Interrupt                                    */
N  DMA_IRQn                      = 26,       /*!< General Purpose DMA Interrupt                    */
N  I2S_IRQn                      = 27,       /*!< I2S Interrupt                                    */
N  ENET_IRQn                     = 28,       /*!< Ethernet Interrupt                               */
N  RIT_IRQn                      = 29,       /*!< Repetitive Interrupt Timer Interrupt             */
N  MCPWM_IRQn                    = 30,       /*!< Motor Control PWM Interrupt                      */
N  QEI_IRQn                      = 31,       /*!< Quadrature Encoder Interface Interrupt           */
N  PLL1_IRQn                     = 32,       /*!< PLL1 Lock (USB PLL) Interrupt                    */
N  USBActivity_IRQn              = 33,       /* USB Activity interrupt                             */
N  CANActivity_IRQn              = 34,       /* CAN Activity interrupt                             */
N} IRQn_Type;
N
N
N/*
N * ==========================================================================
N * ----------- Processor and Core Peripheral Section ------------------------
N * ==========================================================================
N */
N
N/* Configuration of the Cortex-M3 Processor and Core Peripherals */
N#define __MPU_PRESENT             1         /*!< MPU present or not                               */
N#define __NVIC_PRIO_BITS          5         /*!< Number of Bits used for Priority Levels          */
N#define __Vendor_SysTickConfig    0         /*!< Set to 1 if different SysTick Config is used     */
N
N
N#include <core_cm3.h>                       /* Cortex-M3 processor and core peripherals           */
L 1 "C:\Keil\ARM\RV31\INC\core_cm3.h" 1
N/******************************************************************************
N * @file:    core_cm3.h
N * @purpose: CMSIS Cortex-M3 Core Peripheral Access Layer Header File
N * @version: V1.20
N * @date:    22. May 2009
N *----------------------------------------------------------------------------
N *
N * Copyright (C) 2009 ARM Limited. All rights reserved.
N *
N * ARM Limited (ARM) is supplying this software for use with Cortex-Mx 
N * processor based microcontrollers.  This file can be freely distributed 
N * within development tools that are supporting such ARM based processors. 
N *
N * THIS SOFTWARE IS PROVIDED "AS IS".  NO WARRANTIES, WHETHER EXPRESS, IMPLIED
N * OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF
N * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.
N * ARM SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR
N * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
N *
N ******************************************************************************/
N
N#ifndef __CM3_CORE_H__
N#define __CM3_CORE_H__
N
N#ifdef __cplusplus
S extern "C" {
N#endif 
N
N#define __CM3_CMSIS_VERSION_MAIN  (0x01)                                                       /*!< [31:16] CMSIS HAL main version */
N#define __CM3_CMSIS_VERSION_SUB   (0x20)                                                       /*!< [15:0]  CMSIS HAL sub version  */
N#define __CM3_CMSIS_VERSION       ((__CM3_CMSIS_VERSION_MAIN << 16) | __CM3_CMSIS_VERSION_SUB) /*!< CMSIS HAL version number       */
N
N#define __CORTEX_M                (0x03)                                                       /*!< Cortex core                    */
N
N/**
N *  Lint configuration \n
N *  ----------------------- \n
N *
N *  The following Lint messages will be suppressed and not shown: \n
N *  \n
N *    --- Error 10: --- \n
N *    register uint32_t __regBasePri         __asm("basepri"); \n
N *    Error 10: Expecting ';' \n
N *     \n
N *    --- Error 530: --- \n
N *    return(__regBasePri); \n
N *    Warning 530: Symbol '__regBasePri' (line 264) not initialized \n
N *     \n
N *    --- Error 550: --- \n
N *      __regBasePri = (basePri & 0x1ff); \n
N *    } \n
N *    Warning 550: Symbol '__regBasePri' (line 271) not accessed \n
N *     \n
N *    --- Error 754: --- \n
N *    uint32_t RESERVED0[24]; \n
N *    Info 754: local structure member '<some, not used in the HAL>' (line 109, file ./cm3_core.h) not referenced \n
N *     \n
N *    --- Error 750: --- \n
N *    #define __CM3_CORE_H__ \n
N *    Info 750: local macro '__CM3_CORE_H__' (line 43, file./cm3_core.h) not referenced \n
N *     \n
N *    --- Error 528: --- \n
N *    static __INLINE void NVIC_DisableIRQ(uint32_t IRQn) \n
N *    Warning 528: Symbol 'NVIC_DisableIRQ(unsigned int)' (line 419, file ./cm3_core.h) not referenced \n
N *     \n
N *    --- Error 751: --- \n
N *    } InterruptType_Type; \n
N *    Info 751: local typedef 'InterruptType_Type' (line 170, file ./cm3_core.h) not referenced \n
N * \n
N * \n
N *    Note:  To re-enable a Message, insert a space before 'lint' * \n
N *
N */
N
N/*lint -save */
N/*lint -e10  */
N/*lint -e530 */
N/*lint -e550 */
N/*lint -e754 */
N/*lint -e750 */
N/*lint -e528 */
N/*lint -e751 */
N
N
N#include <stdint.h>                           /* Include standard types */
L 1 "C:\Keil\ARM\RV31\INC\stdint.h" 1
N/* Copyright (C) ARM Ltd., 1999 */
N/* All rights reserved */
N
N/*
N * RCS $Revision: 137748 $
N * Checkin $Date: 2008-09-11 17:34:24 +0100 (Thu, 11 Sep 2008) $
N * Revising $Author: agrant $
N */
N
N#ifndef __stdint_h
N#define __stdint_h
N
N  #ifndef __STDINT_DECLS
N  #define __STDINT_DECLS
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S      namespace std {
S          #define __CLIBNS std::
S          extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N
N/*
N * 'signed' is redundant below, except for 'signed char' and if
N * the typedef is used to declare a bitfield.
N * '__int64' is used instead of 'long long' so that this header
N * can be used in --strict mode.
N */
N
N    /* 7.18.1.1 */
N
N    /* exact-width signed integer types */
Ntypedef   signed          char int8_t;
Ntypedef   signed short     int int16_t;
Ntypedef   signed           int int32_t;
Ntypedef   signed       __int64 int64_t;
N
N    /* exact-width unsigned integer types */
Ntypedef unsigned          char uint8_t;
Ntypedef unsigned short     int uint16_t;
Ntypedef unsigned           int uint32_t;
Ntypedef unsigned       __int64 uint64_t;
N
N    /* 7.18.1.2 */
N
N    /* smallest type of at least n bits */
N    /* minimum-width signed integer types */
Ntypedef   signed          char int_least8_t;
Ntypedef   signed short     int int_least16_t;
Ntypedef   signed           int int_least32_t;
Ntypedef   signed       __int64 int_least64_t;
N
N    /* minimum-width unsigned integer types */
Ntypedef unsigned          char uint_least8_t;
Ntypedef unsigned short     int uint_least16_t;
Ntypedef unsigned           int uint_least32_t;
Ntypedef unsigned       __int64 uint_least64_t;
N
N    /* 7.18.1.3 */
N
N    /* fastest minimum-width signed integer types */
Ntypedef   signed           int int_fast8_t;
Ntypedef   signed           int int_fast16_t;
Ntypedef   signed           int int_fast32_t;
Ntypedef   signed       __int64 int_fast64_t;
N
N    /* fastest minimum-width unsigned integer types */
Ntypedef unsigned           int uint_fast8_t;
Ntypedef unsigned           int uint_fast16_t;
Ntypedef unsigned           int uint_fast32_t;
Ntypedef unsigned       __int64 uint_fast64_t;
N
N    /* 7.18.1.4 integer types capable of holding object pointers */
Ntypedef   signed           int intptr_t;
Ntypedef unsigned           int uintptr_t;
N
N    /* 7.18.1.5 greatest-width integer types */
Ntypedef   signed       __int64 intmax_t;
Ntypedef unsigned       __int64 uintmax_t;
N
N
N#if !defined(__cplusplus) || defined(__STDC_LIMIT_MACROS)
X#if !0L || 0L
N
N    /* 7.18.2.1 */
N
N    /* minimum values of exact-width signed integer types */
N#define INT8_MIN                   -128
N#define INT16_MIN                -32768
N#define INT32_MIN          (~0x7fffffff)   /* -2147483648 is unsigned */
N#define INT64_MIN  __ESCAPE__(~0x7fffffffffffffffll) /* -9223372036854775808 is unsigned */
N
N    /* maximum values of exact-width signed integer types */
N#define INT8_MAX                    127
N#define INT16_MAX                 32767
N#define INT32_MAX            2147483647
N#define INT64_MAX  __ESCAPE__(9223372036854775807ll)
N
N    /* maximum values of exact-width unsigned integer types */
N#define UINT8_MAX                   255
N#define UINT16_MAX                65535
N#define UINT32_MAX           4294967295u
N#define UINT64_MAX __ESCAPE__(18446744073709551615ull)
N
N    /* 7.18.2.2 */
N
N    /* minimum values of minimum-width signed integer types */
N#define INT_LEAST8_MIN                   -128
N#define INT_LEAST16_MIN                -32768
N#define INT_LEAST32_MIN          (~0x7fffffff)
N#define INT_LEAST64_MIN  __ESCAPE__(~0x7fffffffffffffffll)
N
N    /* maximum values of minimum-width signed integer types */
N#define INT_LEAST8_MAX                    127
N#define INT_LEAST16_MAX                 32767
N#define INT_LEAST32_MAX            2147483647
N#define INT_LEAST64_MAX  __ESCAPE__(9223372036854775807ll)
N
N    /* maximum values of minimum-width unsigned integer types */
N#define UINT_LEAST8_MAX                   255
N#define UINT_LEAST16_MAX                65535
N#define UINT_LEAST32_MAX           4294967295u
N#define UINT_LEAST64_MAX __ESCAPE__(18446744073709551615ull)
N
N    /* 7.18.2.3 */
N
N    /* minimum values of fastest minimum-width signed integer types */
N#define INT_FAST8_MIN           (~0x7fffffff)
N#define INT_FAST16_MIN          (~0x7fffffff)
N#define INT_FAST32_MIN          (~0x7fffffff)
N#define INT_FAST64_MIN  __ESCAPE__(~0x7fffffffffffffffll)
N
N    /* maximum values of fastest minimum-width signed integer types */
N#define INT_FAST8_MAX             2147483647
N#define INT_FAST16_MAX            2147483647
N#define INT_FAST32_MAX            2147483647
N#define INT_FAST64_MAX  __ESCAPE__(9223372036854775807ll)
N
N    /* maximum values of fastest minimum-width unsigned integer types */
N#define UINT_FAST8_MAX            4294967295u
N#define UINT_FAST16_MAX           4294967295u
N#define UINT_FAST32_MAX           4294967295u
N#define UINT_FAST64_MAX __ESCAPE__(18446744073709551615ull)
N
N    /* 7.18.2.4 */
N
N    /* minimum value of pointer-holding signed integer type */
N#define INTPTR_MIN (~0x7fffffff)
N
N    /* maximum value of pointer-holding signed integer type */
N#define INTPTR_MAX   2147483647
N
N    /* maximum value of pointer-holding unsigned integer type */
N#define UINTPTR_MAX  4294967295u
N
N    /* 7.18.2.5 */
N
N    /* minimum value of greatest-width signed integer type */
N#define INTMAX_MIN  __ESCAPE__(~0x7fffffffffffffffll)
N
N    /* maximum value of greatest-width signed integer type */
N#define INTMAX_MAX  __ESCAPE__(9223372036854775807ll)
N
N    /* maximum value of greatest-width unsigned integer type */
N#define UINTMAX_MAX __ESCAPE__(18446744073709551615ull)
N
N    /* 7.18.3 */
N
N    /* limits of ptrdiff_t */
N#define PTRDIFF_MIN (~0x7fffffff)
N#define PTRDIFF_MAX   2147483647
N
N    /* limits of sig_atomic_t */
N#define SIG_ATOMIC_MIN (~0x7fffffff)
N#define SIG_ATOMIC_MAX   2147483647
N
N    /* limit of size_t */
N#define SIZE_MAX 4294967295u
N
N    /* limits of wchar_t */
N    /* NB we have to undef and redef because they're defined in both
N     * stdint.h and wchar.h */
N#undef WCHAR_MIN
N#undef WCHAR_MAX
N
N#if defined(__WCHAR32)
X#if 0L
S  #define WCHAR_MIN   0
S  #define WCHAR_MAX   0xffffffffU
N#else
N  #define WCHAR_MIN   0
N  #define WCHAR_MAX   65535
N#endif
N
N    /* limits of wint_t */
N#define WINT_MIN (~0x7fffffff)
N#define WINT_MAX 2147483647
N
N#endif /* __STDC_LIMIT_MACROS */
N
N#if !defined(__cplusplus) || defined(__STDC_CONSTANT_MACROS)
X#if !0L || 0L
N
N    /* 7.18.4.1 macros for minimum-width integer constants */
N#define INT8_C(x)   (x)
N#define INT16_C(x)  (x)
N#define INT32_C(x)  (x)
N#define INT64_C(x)  __ESCAPE__(x ## ll)
N
N#define UINT8_C(x)  (x ## u)
N#define UINT16_C(x) (x ## u)
N#define UINT32_C(x) (x ## u)
N#define UINT64_C(x) __ESCAPE__(x ## ull)
N
N    /* 7.18.4.2 macros for greatest-width integer constants */
N#define INTMAX_C(x)  __ESCAPE__(x ## ll)
N#define UINTMAX_C(x) __ESCAPE__(x ## ull)
N
N#endif /* __STDC_CONSTANT_MACROS */
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STDINT_DECLS */
N
N  #ifdef __cplusplus
S    #ifndef __STDINT_NO_EXPORTS
S      using ::std::int8_t;
S      using ::std::int16_t;
S      using ::std::int32_t;
S      using ::std::int64_t;
S      using ::std::uint8_t;
S      using ::std::uint16_t;
S      using ::std::uint32_t;
S      using ::std::uint64_t;
S      using ::std::int_least8_t;
S      using ::std::int_least16_t;
S      using ::std::int_least32_t;
S      using ::std::int_least64_t;
S      using ::std::uint_least8_t;
S      using ::std::uint_least16_t;
S      using ::std::uint_least32_t;
S      using ::std::uint_least64_t;
S      using ::std::int_fast8_t;
S      using ::std::int_fast16_t;
S      using ::std::int_fast32_t;
S      using ::std::int_fast64_t;
S      using ::std::uint_fast8_t;
S      using ::std::uint_fast16_t;
S      using ::std::uint_fast32_t;
S      using ::std::uint_fast64_t;
S      using ::std::intptr_t;
S      using ::std::uintptr_t;
S      using ::std::intmax_t;
S      using ::std::uintmax_t;
S    #endif 
N  #endif /* __cplusplus */
N
N#endif /* __stdint_h */
N
N/* end of stdint.h */
N
N
L 86 "C:\Keil\ARM\RV31\INC\core_cm3.h" 2
N
N#if defined (__ICCARM__)
X#if 0L
S  #include <intrinsics.h>                     /* IAR Intrinsics   */
N#endif
N
N
N#ifndef __NVIC_PRIO_BITS
S  #define __NVIC_PRIO_BITS    4               /*!< standard definition for NVIC Priority Bits */
N#endif
N
N
N
N
N/**
N * IO definitions
N *
N * define access restrictions to peripheral registers
N */
N
N#ifdef __cplusplus
S#define     __I     volatile                  /*!< defines 'read only' permissions      */
N#else
N#define     __I     volatile const            /*!< defines 'read only' permissions      */
N#endif
N#define     __O     volatile                  /*!< defines 'write only' permissions     */
N#define     __IO    volatile                  /*!< defines 'read / write' permissions   */
N
N
N
N/*******************************************************************************
N *                 Register Abstraction
N ******************************************************************************/
N
N
N/* System Reset */
N#define NVIC_VECTRESET              0         /*!< Vector Reset Bit             */
N#define NVIC_SYSRESETREQ            2         /*!< System Reset Request         */
N#define NVIC_AIRCR_VECTKEY    (0x5FA << 16)   /*!< AIRCR Key for write access   */
N#define NVIC_AIRCR_ENDIANESS        15        /*!< Endianess                    */
N
N/* Core Debug */
N#define CoreDebug_DEMCR_TRCENA (1 << 24)      /*!< DEMCR TRCENA enable          */
N#define ITM_TCR_ITMENA              1         /*!< ITM enable                   */
N
N
N
N
N/* memory mapping struct for Nested Vectored Interrupt Controller (NVIC) */
Ntypedef struct
N{
N  __IO uint32_t ISER[8];                      /*!< Interrupt Set Enable Register            */
X  volatile uint32_t ISER[8];                       
N       uint32_t RESERVED0[24];
N  __IO uint32_t ICER[8];                      /*!< Interrupt Clear Enable Register          */
X  volatile uint32_t ICER[8];                       
N       uint32_t RSERVED1[24];
N  __IO uint32_t ISPR[8];                      /*!< Interrupt Set Pending Register           */
X  volatile uint32_t ISPR[8];                       
N       uint32_t RESERVED2[24];
N  __IO uint32_t ICPR[8];                      /*!< Interrupt Clear Pending Register         */
X  volatile uint32_t ICPR[8];                       
N       uint32_t RESERVED3[24];
N  __IO uint32_t IABR[8];                      /*!< Interrupt Active bit Register            */
X  volatile uint32_t IABR[8];                       
N       uint32_t RESERVED4[56];
N  __IO uint8_t  IP[240];                      /*!< Interrupt Priority Register, 8Bit wide   */
X  volatile uint8_t  IP[240];                       
N       uint32_t RESERVED5[644];
N  __O  uint32_t STIR;                         /*!< Software Trigger Interrupt Register      */
X  volatile  uint32_t STIR;                          
N}  NVIC_Type;
N
N
N/* memory mapping struct for System Control Block */
Ntypedef struct
N{
N  __I  uint32_t CPUID;                        /*!< CPU ID Base Register                                     */
X  volatile const  uint32_t CPUID;                         
N  __IO uint32_t ICSR;                         /*!< Interrupt Control State Register                         */
X  volatile uint32_t ICSR;                          
N  __IO uint32_t VTOR;                         /*!< Vector Table Offset Register                             */
X  volatile uint32_t VTOR;                          
N  __IO uint32_t AIRCR;                        /*!< Application Interrupt / Reset Control Register           */
X  volatile uint32_t AIRCR;                         
N  __IO uint32_t SCR;                          /*!< System Control Register                                  */
X  volatile uint32_t SCR;                           
N  __IO uint32_t CCR;                          /*!< Configuration Control Register                           */
X  volatile uint32_t CCR;                           
N  __IO uint8_t  SHP[12];                      /*!< System Handlers Priority Registers (4-7, 8-11, 12-15)    */
X  volatile uint8_t  SHP[12];                       
N  __IO uint32_t SHCSR;                        /*!< System Handler Control and State Register                */
X  volatile uint32_t SHCSR;                         
N  __IO uint32_t CFSR;                         /*!< Configurable Fault Status Register                       */
X  volatile uint32_t CFSR;                          
N  __IO uint32_t HFSR;                         /*!< Hard Fault Status Register                               */
X  volatile uint32_t HFSR;                          
N  __IO uint32_t DFSR;                         /*!< Debug Fault Status Register                              */
X  volatile uint32_t DFSR;                          
N  __IO uint32_t MMFAR;                        /*!< Mem Manage Address Register                              */
X  volatile uint32_t MMFAR;                         
N  __IO uint32_t BFAR;                         /*!< Bus Fault Address Register                               */
X  volatile uint32_t BFAR;                          
N  __IO uint32_t AFSR;                         /*!< Auxiliary Fault Status Register                          */
X  volatile uint32_t AFSR;                          
N  __I  uint32_t PFR[2];                       /*!< Processor Feature Register                               */
X  volatile const  uint32_t PFR[2];                        
N  __I  uint32_t DFR;                          /*!< Debug Feature Register                                   */
X  volatile const  uint32_t DFR;                           
N  __I  uint32_t ADR;                          /*!< Auxiliary Feature Register                               */
X  volatile const  uint32_t ADR;                           
N  __I  uint32_t MMFR[4];                      /*!< Memory Model Feature Register                            */
X  volatile const  uint32_t MMFR[4];                       
N  __I  uint32_t ISAR[5];                      /*!< ISA Feature Register                                     */
X  volatile const  uint32_t ISAR[5];                       
N} SCB_Type;
N
N
N/* memory mapping struct for SysTick */
Ntypedef struct
N{
N  __IO uint32_t CTRL;                         /*!< SysTick Control and Status Register */
X  volatile uint32_t CTRL;                          
N  __IO uint32_t LOAD;                         /*!< SysTick Reload Value Register       */
X  volatile uint32_t LOAD;                          
N  __IO uint32_t VAL;                          /*!< SysTick Current Value Register      */
X  volatile uint32_t VAL;                           
N  __I  uint32_t CALIB;                        /*!< SysTick Calibration Register        */
X  volatile const  uint32_t CALIB;                         
N} SysTick_Type;
N
N
N/* memory mapping structur for ITM */
Ntypedef struct
N{
N  __O  union  
X  volatile  union  
N  {
N    __O  uint8_t    u8;                       /*!< ITM Stimulus Port 8-bit               */
X    volatile  uint8_t    u8;                        
N    __O  uint16_t   u16;                      /*!< ITM Stimulus Port 16-bit              */
X    volatile  uint16_t   u16;                       
N    __O  uint32_t   u32;                      /*!< ITM Stimulus Port 32-bit              */
X    volatile  uint32_t   u32;                       
N  }  PORT [32];                               /*!< ITM Stimulus Port Registers           */
N       uint32_t RESERVED0[864];
N  __IO uint32_t TER;                          /*!< ITM Trace Enable Register             */
X  volatile uint32_t TER;                           
N       uint32_t RESERVED1[15];
N  __IO uint32_t TPR;                          /*!< ITM Trace Privilege Register          */
X  volatile uint32_t TPR;                           
N       uint32_t RESERVED2[15];
N  __IO uint32_t TCR;                          /*!< ITM Trace Control Register            */
X  volatile uint32_t TCR;                           
N       uint32_t RESERVED3[29];
N  __IO uint32_t IWR;                          /*!< ITM Integration Write Register        */
X  volatile uint32_t IWR;                           
N  __IO uint32_t IRR;                          /*!< ITM Integration Read Register         */
X  volatile uint32_t IRR;                           
N  __IO uint32_t IMCR;                         /*!< ITM Integration Mode Control Register */
X  volatile uint32_t IMCR;                          
N       uint32_t RESERVED4[43];
N  __IO uint32_t LAR;                          /*!< ITM Lock Access Register              */
X  volatile uint32_t LAR;                           
N  __IO uint32_t LSR;                          /*!< ITM Lock Status Register              */
X  volatile uint32_t LSR;                           
N       uint32_t RESERVED5[6];
N  __I  uint32_t PID4;                         /*!< ITM Product ID Registers              */
X  volatile const  uint32_t PID4;                          
N  __I  uint32_t PID5;
X  volatile const  uint32_t PID5;
N  __I  uint32_t PID6;
X  volatile const  uint32_t PID6;
N  __I  uint32_t PID7;
X  volatile const  uint32_t PID7;
N  __I  uint32_t PID0;
X  volatile const  uint32_t PID0;
N  __I  uint32_t PID1;
X  volatile const  uint32_t PID1;
N  __I  uint32_t PID2;
X  volatile const  uint32_t PID2;
N  __I  uint32_t PID3;
X  volatile const  uint32_t PID3;
N  __I  uint32_t CID0;
X  volatile const  uint32_t CID0;
N  __I  uint32_t CID1;
X  volatile const  uint32_t CID1;
N  __I  uint32_t CID2;
X  volatile const  uint32_t CID2;
N  __I  uint32_t CID3;
X  volatile const  uint32_t CID3;
N} ITM_Type;
N
N
N/* memory mapped struct for Interrupt Type */
Ntypedef struct
N{
N       uint32_t RESERVED0;
N  __I  uint32_t ICTR;                         /*!< Interrupt Control Type Register  */
X  volatile const  uint32_t ICTR;                          
N#if ((defined __CM3_REV) && (__CM3_REV >= 0x200))
X#if ((0L) && (__CM3_REV >= 0x200))
S  __IO uint32_t ACTLR;                        /*!< Auxiliary Control Register       */
N#else
N       uint32_t RESERVED1;
N#endif
N} InterruptType_Type;
N
N
N/* Memory Protection Unit */
N#if defined (__MPU_PRESENT) && (__MPU_PRESENT == 1)
X#if 1L && (1 == 1)
Ntypedef struct
N{
N  __I  uint32_t TYPE;                         /*!< MPU Type Register                               */
X  volatile const  uint32_t TYPE;                          
N  __IO uint32_t CTRL;                         /*!< MPU Control Register                            */
X  volatile uint32_t CTRL;                          
N  __IO uint32_t RNR;                          /*!< MPU Region RNRber Register                      */
X  volatile uint32_t RNR;                           
N  __IO uint32_t RBAR;                         /*!< MPU Region Base Address Register                */
X  volatile uint32_t RBAR;                          
N  __IO uint32_t RASR;                         /*!< MPU Region Attribute and Size Register          */
X  volatile uint32_t RASR;                          
N  __IO uint32_t RBAR_A1;                      /*!< MPU Alias 1 Region Base Address Register        */
X  volatile uint32_t RBAR_A1;                       
N  __IO uint32_t RASR_A1;                      /*!< MPU Alias 1 Region Attribute and Size Register  */
X  volatile uint32_t RASR_A1;                       
N  __IO uint32_t RBAR_A2;                      /*!< MPU Alias 2 Region Base Address Register        */
X  volatile uint32_t RBAR_A2;                       
N  __IO uint32_t RASR_A2;                      /*!< MPU Alias 2 Region Attribute and Size Register  */
X  volatile uint32_t RASR_A2;                       
N  __IO uint32_t RBAR_A3;                      /*!< MPU Alias 3 Region Base Address Register        */
X  volatile uint32_t RBAR_A3;                       
N  __IO uint32_t RASR_A3;                      /*!< MPU Alias 3 Region Attribute and Size Register  */
X  volatile uint32_t RASR_A3;                       
N} MPU_Type;
N#endif
N
N
N/* Core Debug Register */
Ntypedef struct
N{
N  __IO uint32_t DHCSR;                        /*!< Debug Halting Control and Status Register       */
X  volatile uint32_t DHCSR;                         
N  __O  uint32_t DCRSR;                        /*!< Debug Core Register Selector Register           */
X  volatile  uint32_t DCRSR;                         
N  __IO uint32_t DCRDR;                        /*!< Debug Core Register Data Register               */
X  volatile uint32_t DCRDR;                         
N  __IO uint32_t DEMCR;                        /*!< Debug Exception and Monitor Control Register    */
X  volatile uint32_t DEMCR;                         
N} CoreDebug_Type;
N
N
N/* Memory mapping of Cortex-M3 Hardware */
N#define SCS_BASE            (0xE000E000)                              /*!< System Control Space Base Address    */
N#define ITM_BASE            (0xE0000000)                              /*!< ITM Base Address                     */
N#define CoreDebug_BASE      (0xE000EDF0)                              /*!< Core Debug Base Address              */
N#define SysTick_BASE        (SCS_BASE +  0x0010)                      /*!< SysTick Base Address                 */
N#define NVIC_BASE           (SCS_BASE +  0x0100)                      /*!< NVIC Base Address                    */
N#define SCB_BASE            (SCS_BASE +  0x0D00)                      /*!< System Control Block Base Address    */
N
N#define InterruptType       ((InterruptType_Type *) SCS_BASE)         /*!< Interrupt Type Register              */
N#define SCB                 ((SCB_Type *)           SCB_BASE)         /*!< SCB configuration struct             */
N#define SysTick             ((SysTick_Type *)       SysTick_BASE)     /*!< SysTick configuration struct         */
N#define NVIC                ((NVIC_Type *)          NVIC_BASE)        /*!< NVIC configuration struct            */
N#define ITM                 ((ITM_Type *)           ITM_BASE)         /*!< ITM configuration struct             */
N#define CoreDebug           ((CoreDebug_Type *)     CoreDebug_BASE)   /*!< Core Debug configuration struct      */
N
N#if defined (__MPU_PRESENT) && (__MPU_PRESENT == 1)
X#if 1L && (1 == 1)
N  #define MPU_BASE          (SCS_BASE +  0x0D90)                      /*!< Memory Protection Unit               */
N  #define MPU               ((MPU_Type*)            MPU_BASE)         /*!< Memory Protection Unit               */
N#endif
N
N
N
N/*******************************************************************************
N *                Hardware Abstraction Layer
N ******************************************************************************/
N
N
N#if defined ( __CC_ARM   )
X#if 1L
N  #define __ASM            __asm                                      /*!< asm keyword for ARM Compiler          */
N  #define __INLINE         __inline                                   /*!< inline keyword for ARM Compiler       */
N
N#elif defined ( __ICCARM__ )
S  #define __ASM           __asm                                       /*!< asm keyword for IAR Compiler           */
S  #define __INLINE        inline                                      /*!< inline keyword for IAR Compiler. Only avaiable in High optimization mode! */
S
S#elif defined   (  __GNUC__  )
S  #define __ASM            __asm                                      /*!< asm keyword for GNU Compiler          */
S  #define __INLINE         inline                                     /*!< inline keyword for GNU Compiler       */
S
S#elif defined   (  __TASKING__  )
S  #define __ASM            __asm                                      /*!< asm keyword for TASKING Compiler          */
S  #define __INLINE         inline                                     /*!< inline keyword for TASKING Compiler       */
S
N#endif
N
N
N/* ###################  Compiler specific Intrinsics  ########################### */
N
N#if defined ( __CC_ARM   ) /*------------------RealView Compiler -----------------*/
X#if 1L  
N/* ARM armcc specific functions */
N
N#define __enable_fault_irq                __enable_fiq
N#define __disable_fault_irq               __disable_fiq
N
N#define __NOP                             __nop
N#define __WFI                             __wfi
N#define __WFE                             __wfe
N#define __SEV                             __sev
N#define __ISB()                           __isb(0)
N#define __DSB()                           __dsb(0)
N#define __DMB()                           __dmb(0)
N#define __REV                             __rev
N#define __RBIT                            __rbit
N#define __LDREXB(ptr)                     ((unsigned char ) __ldrex(ptr))
N#define __LDREXH(ptr)                     ((unsigned short) __ldrex(ptr))
N#define __LDREXW(ptr)                     ((unsigned int  ) __ldrex(ptr))
N#define __STREXB(value, ptr)              __strex(value, ptr)
N#define __STREXH(value, ptr)              __strex(value, ptr)
N#define __STREXW(value, ptr)              __strex(value, ptr)
N
N
N/* intrinsic unsigned long long __ldrexd(volatile void *ptr) */
N/* intrinsic int __strexd(unsigned long long val, volatile void *ptr) */
N/* intrinsic void __enable_irq();     */
N/* intrinsic void __disable_irq();    */
N
N
N/**
N * @brief  Return the Process Stack Pointer
N *
N * @param  none
N * @return uint32_t ProcessStackPointer
N *
N * Return the actual process stack pointer
N */
Nextern uint32_t __get_PSP(void);
N
N/**
N * @brief  Set the Process Stack Pointer
N *
N * @param  uint32_t Process Stack Pointer
N * @return none
N *
N * Assign the value ProcessStackPointer to the MSP 
N * (process stack pointer) Cortex processor register
N */
Nextern void __set_PSP(uint32_t topOfProcStack);
N
N/**
N * @brief  Return the Main Stack Pointer
N *
N * @param  none
N * @return uint32_t Main Stack Pointer
N *
N * Return the current value of the MSP (main stack pointer)
N * Cortex processor register
N */
Nextern uint32_t __get_MSP(void);
N
N/**
N * @brief  Set the Main Stack Pointer
N *
N * @param  uint32_t Main Stack Pointer
N * @return none
N *
N * Assign the value mainStackPointer to the MSP 
N * (main stack pointer) Cortex processor register
N */
Nextern void __set_MSP(uint32_t topOfMainStack);
N
N/**
N * @brief  Reverse byte order in unsigned short value
N *
N * @param  uint16_t value to reverse
N * @return uint32_t reversed value
N *
N * Reverse byte order in unsigned short value
N */
Nextern uint32_t __REV16(uint16_t value);
N
N/*
N * @brief  Reverse byte order in signed short value with sign extension to integer
N *
N * @param  int16_t value to reverse
N * @return int32_t reversed value
N *
N * Reverse byte order in signed short value with sign extension to integer
N */
Nextern int32_t __REVSH(int16_t value);
N
N
N#if (__ARMCC_VERSION < 400000)
X#if (410644 < 400000)
S
S/**
S * @brief  Remove the exclusive lock created by ldrex
S *
S * @param  none
S * @return none
S *
S * Removes the exclusive lock which is created by ldrex.
S */
Sextern void __CLREX(void);
S
S/**
S * @brief  Return the Base Priority value
S *
S * @param  none
S * @return uint32_t BasePriority
S *
S * Return the content of the base priority register
S */
Sextern uint32_t __get_BASEPRI(void);
S
S/**
S * @brief  Set the Base Priority value
S *
S * @param  uint32_t BasePriority
S * @return none
S *
S * Set the base priority register
S */
Sextern void __set_BASEPRI(uint32_t basePri);
S
S/**
S * @brief  Return the Priority Mask value
S *
S * @param  none
S * @return uint32_t PriMask
S *
S * Return the state of the priority mask bit from the priority mask
S * register
S */
Sextern uint32_t __get_PRIMASK(void);
S
S/**
S * @brief  Set the Priority Mask value
S *
S * @param  uint32_t PriMask
S * @return none
S *
S * Set the priority mask bit in the priority mask register
S */
Sextern void __set_PRIMASK(uint32_t priMask);
S
S/**
S * @brief  Return the Fault Mask value
S *
S * @param  none
S * @return uint32_t FaultMask
S *
S * Return the content of the fault mask register
S */
Sextern uint32_t __get_FAULTMASK(void);
S
S/**
S * @brief  Set the Fault Mask value
S *
S * @param  uint32_t faultMask value
S * @return none
S *
S * Set the fault mask register
S */
Sextern void __set_FAULTMASK(uint32_t faultMask);
S
S/**
S * @brief  Return the Control Register value
S * 
S * @param  none
S * @return uint32_t Control value
S *
S * Return the content of the control register
S */
Sextern uint32_t __get_CONTROL(void);
S
S/**
S * @brief  Set the Control Register value
S *
S * @param  uint32_t Control value
S * @return none
S *
S * Set the control register
S */
Sextern void __set_CONTROL(uint32_t control);
S
N#else  /* (__ARMCC_VERSION >= 400000)  */
N
N
N/**
N * @brief  Remove the exclusive lock created by ldrex
N *
N * @param  none
N * @return none
N *
N * Removes the exclusive lock which is created by ldrex.
N */
N#define __CLREX                           __clrex
N
N/**
N * @brief  Return the Base Priority value
N *
N * @param  none
N * @return uint32_t BasePriority
N *
N * Return the content of the base priority register
N */
Nstatic __INLINE uint32_t  __get_BASEPRI(void)
Xstatic __inline uint32_t  __get_BASEPRI(void)
N{
N  register uint32_t __regBasePri         __ASM("basepri");
X  register uint32_t __regBasePri         __asm("basepri");
N  return(__regBasePri);
N}
N
N/**
N * @brief  Set the Base Priority value
N *
N * @param  uint32_t BasePriority
N * @return none
N *
N * Set the base priority register
N */
Nstatic __INLINE void __set_BASEPRI(uint32_t basePri)
Xstatic __inline void __set_BASEPRI(uint32_t basePri)
N{
N  register uint32_t __regBasePri         __ASM("basepri");
X  register uint32_t __regBasePri         __asm("basepri");
N  __regBasePri = (basePri & 0x1ff);
N}
N
N/**
N * @brief  Return the Priority Mask value
N *
N * @param  none
N * @return uint32_t PriMask
N *
N * Return the state of the priority mask bit from the priority mask
N * register
N */
Nstatic __INLINE uint32_t __get_PRIMASK(void)
Xstatic __inline uint32_t __get_PRIMASK(void)
N{
N  register uint32_t __regPriMask         __ASM("primask");
X  register uint32_t __regPriMask         __asm("primask");
N  return(__regPriMask);
N}
N
N/**
N * @brief  Set the Priority Mask value
N *
N * @param  uint32_t PriMask
N * @return none
N *
N * Set the priority mask bit in the priority mask register
N */
Nstatic __INLINE void __set_PRIMASK(uint32_t priMask)
Xstatic __inline void __set_PRIMASK(uint32_t priMask)
N{
N  register uint32_t __regPriMask         __ASM("primask");
X  register uint32_t __regPriMask         __asm("primask");
N  __regPriMask = (priMask);
N}
N
N/**
N * @brief  Return the Fault Mask value
N *
N * @param  none
N * @return uint32_t FaultMask
N *
N * Return the content of the fault mask register
N */
Nstatic __INLINE uint32_t __get_FAULTMASK(void)
Xstatic __inline uint32_t __get_FAULTMASK(void)
N{
N  register uint32_t __regFaultMask       __ASM("faultmask");
X  register uint32_t __regFaultMask       __asm("faultmask");
N  return(__regFaultMask);
N}
N
N/**
N * @brief  Set the Fault Mask value
N *
N * @param  uint32_t faultMask value
N * @return none
N *
N * Set the fault mask register
N */
Nstatic __INLINE void __set_FAULTMASK(uint32_t faultMask)
Xstatic __inline void __set_FAULTMASK(uint32_t faultMask)
N{
N  register uint32_t __regFaultMask       __ASM("faultmask");
X  register uint32_t __regFaultMask       __asm("faultmask");
N  __regFaultMask = (faultMask & 1);
N}
N
N/**
N * @brief  Return the Control Register value
N * 
N * @param  none
N * @return uint32_t Control value
N *
N * Return the content of the control register
N */
Nstatic __INLINE uint32_t __get_CONTROL(void)
Xstatic __inline uint32_t __get_CONTROL(void)
N{
N  register uint32_t __regControl         __ASM("control");
X  register uint32_t __regControl         __asm("control");
N  return(__regControl);
N}
N
N/**
N * @brief  Set the Control Register value
N *
N * @param  uint32_t Control value
N * @return none
N *
N * Set the control register
N */
Nstatic __INLINE void __set_CONTROL(uint32_t control)
Xstatic __inline void __set_CONTROL(uint32_t control)
N{
N  register uint32_t __regControl         __ASM("control");
X  register uint32_t __regControl         __asm("control");
N  __regControl = control;
N}
N
N#endif /* __ARMCC_VERSION  */ 
N
N
N
N#elif (defined (__ICCARM__)) /*------------------ ICC Compiler -------------------*/
S/* IAR iccarm specific functions */
S
S#define __enable_irq                              __enable_interrupt        /*!< global Interrupt enable */
S#define __disable_irq                             __disable_interrupt       /*!< global Interrupt disable */
S
Sstatic __INLINE void __enable_fault_irq()         { __ASM ("cpsie f"); }
Sstatic __INLINE void __disable_fault_irq()        { __ASM ("cpsid f"); }
S
S#define __NOP                                     __no_operation()          /*!< no operation intrinsic in IAR Compiler */ 
Sstatic __INLINE  void __WFI()                     { __ASM ("wfi"); }
Sstatic __INLINE  void __WFE()                     { __ASM ("wfe"); }
Sstatic __INLINE  void __SEV()                     { __ASM ("sev"); }
Sstatic __INLINE  void __CLREX()                   { __ASM ("clrex"); }
S
S/* intrinsic void __ISB(void)                                     */
S/* intrinsic void __DSB(void)                                     */
S/* intrinsic void __DMB(void)                                     */
S/* intrinsic void __set_PRIMASK();                                */
S/* intrinsic void __get_PRIMASK();                                */
S/* intrinsic void __set_FAULTMASK();                              */
S/* intrinsic void __get_FAULTMASK();                              */
S/* intrinsic uint32_t __REV(uint32_t value);                      */
S/* intrinsic uint32_t __REVSH(uint32_t value);                    */
S/* intrinsic unsigned long __STREX(unsigned long, unsigned long); */
S/* intrinsic unsigned long __LDREX(unsigned long *);              */
S
S
S/**
S * @brief  Return the Process Stack Pointer
S *
S * @param  none
S * @return uint32_t ProcessStackPointer
S *
S * Return the actual process stack pointer
S */
Sextern uint32_t __get_PSP(void);
S
S/**
S * @brief  Set the Process Stack Pointer
S *
S * @param  uint32_t Process Stack Pointer
S * @return none
S *
S * Assign the value ProcessStackPointer to the MSP 
S * (process stack pointer) Cortex processor register
S */
Sextern void __set_PSP(uint32_t topOfProcStack);
S
S/**
S * @brief  Return the Main Stack Pointer
S *
S * @param  none
S * @return uint32_t Main Stack Pointer
S *
S * Return the current value of the MSP (main stack pointer)
S * Cortex processor register
S */
Sextern uint32_t __get_MSP(void);
S
S/**
S * @brief  Set the Main Stack Pointer
S *
S * @param  uint32_t Main Stack Pointer
S * @return none
S *
S * Assign the value mainStackPointer to the MSP 
S * (main stack pointer) Cortex processor register
S */
Sextern void __set_MSP(uint32_t topOfMainStack);
S
S/**
S * @brief  Reverse byte order in unsigned short value
S *
S * @param  uint16_t value to reverse
S * @return uint32_t reversed value
S *
S * Reverse byte order in unsigned short value
S */
Sextern uint32_t __REV16(uint16_t value);
S
S/**
S * @brief  Reverse bit order of value
S *
S * @param  uint32_t value to reverse
S * @return uint32_t reversed value
S *
S * Reverse bit order of value
S */
Sextern uint32_t __RBIT(uint32_t value);
S
S/**
S * @brief  LDR Exclusive
S *
S * @param  uint8_t* address
S * @return uint8_t value of (*address)
S *
S * Exclusive LDR command
S */
Sextern uint8_t __LDREXB(uint8_t *addr);
S
S/**
S * @brief  LDR Exclusive
S *
S * @param  uint16_t* address
S * @return uint16_t value of (*address)
S *
S * Exclusive LDR command
S */
Sextern uint16_t __LDREXH(uint16_t *addr);
S
S/**
S * @brief  LDR Exclusive
S *
S * @param  uint32_t* address
S * @return uint32_t value of (*address)
S *
S * Exclusive LDR command
S */
Sextern uint32_t __LDREXW(uint32_t *addr);
S
S/**
S * @brief  STR Exclusive
S *
S * @param  uint8_t *address
S * @param  uint8_t value to store
S * @return uint32_t successful / failed
S *
S * Exclusive STR command
S */
Sextern uint32_t __STREXB(uint8_t value, uint8_t *addr);
S
S/**
S * @brief  STR Exclusive
S *
S * @param  uint16_t *address
S * @param  uint16_t value to store
S * @return uint32_t successful / failed
S *
S * Exclusive STR command
S */
Sextern uint32_t __STREXH(uint16_t value, uint16_t *addr);
S
S/**
S * @brief  STR Exclusive
S *
S * @param  uint32_t *address
S * @param  uint32_t value to store
S * @return uint32_t successful / failed
S *
S * Exclusive STR command
S */
Sextern uint32_t __STREXW(uint32_t value, uint32_t *addr);
S
S
S
S#elif (defined (__GNUC__)) /*------------------ GNU Compiler ---------------------*/
S/* GNU gcc specific functions */
S
Sstatic __INLINE void __enable_irq()               { __ASM volatile ("cpsie i"); }
Sstatic __INLINE void __disable_irq()              { __ASM volatile ("cpsid i"); }
S
Sstatic __INLINE void __enable_fault_irq()         { __ASM volatile ("cpsie f"); }
Sstatic __INLINE void __disable_fault_irq()        { __ASM volatile ("cpsid f"); }
S
Sstatic __INLINE void __NOP()                      { __ASM volatile ("nop"); }
Sstatic __INLINE void __WFI()                      { __ASM volatile ("wfi"); }
Sstatic __INLINE void __WFE()                      { __ASM volatile ("wfe"); }
Sstatic __INLINE void __SEV()                      { __ASM volatile ("sev"); }
Sstatic __INLINE void __ISB()                      { __ASM volatile ("isb"); }
Sstatic __INLINE void __DSB()                      { __ASM volatile ("dsb"); }
Sstatic __INLINE void __DMB()                      { __ASM volatile ("dmb"); }
Sstatic __INLINE void __CLREX()                    { __ASM volatile ("clrex"); }
S
S
S/**
S * @brief  Return the Process Stack Pointer
S *
S * @param  none
S * @return uint32_t ProcessStackPointer
S *
S * Return the actual process stack pointer
S */
Sextern uint32_t __get_PSP(void);
S
S/**
S * @brief  Set the Process Stack Pointer
S *
S * @param  uint32_t Process Stack Pointer
S * @return none
S *
S * Assign the value ProcessStackPointer to the MSP 
S * (process stack pointer) Cortex processor register
S */
Sextern void __set_PSP(uint32_t topOfProcStack);
S
S/**
S * @brief  Return the Main Stack Pointer
S *
S * @param  none
S * @return uint32_t Main Stack Pointer
S *
S * Return the current value of the MSP (main stack pointer)
S * Cortex processor register
S */
Sextern uint32_t __get_MSP(void);
S
S/**
S * @brief  Set the Main Stack Pointer
S *
S * @param  uint32_t Main Stack Pointer
S * @return none
S *
S * Assign the value mainStackPointer to the MSP 
S * (main stack pointer) Cortex processor register
S */
Sextern void __set_MSP(uint32_t topOfMainStack);
S
S/**
S * @brief  Return the Base Priority value
S *
S * @param  none
S * @return uint32_t BasePriority
S *
S * Return the content of the base priority register
S */
Sextern uint32_t __get_BASEPRI(void);
S
S/**
S * @brief  Set the Base Priority value
S *
S * @param  uint32_t BasePriority
S * @return none
S *
S * Set the base priority register
S */
Sextern void __set_BASEPRI(uint32_t basePri);
S
S/**
S * @brief  Return the Priority Mask value
S *
S * @param  none
S * @return uint32_t PriMask
S *
S * Return the state of the priority mask bit from the priority mask
S * register
S */
Sextern uint32_t  __get_PRIMASK(void);
S
S/**
S * @brief  Set the Priority Mask value
S *
S * @param  uint32_t PriMask
S * @return none
S *
S * Set the priority mask bit in the priority mask register
S */
Sextern void __set_PRIMASK(uint32_t priMask);
S
S/**
S * @brief  Return the Fault Mask value
S *
S * @param  none
S * @return uint32_t FaultMask
S *
S * Return the content of the fault mask register
S */
Sextern uint32_t __get_FAULTMASK(void);
S
S/**
S * @brief  Set the Fault Mask value
S *
S * @param  uint32_t faultMask value
S * @return none
S *
S * Set the fault mask register
S */
Sextern void __set_FAULTMASK(uint32_t faultMask);
S
S/**
S * @brief  Return the Control Register value
S* 
S*  @param  none
S*  @return uint32_t Control value
S *
S * Return the content of the control register
S */
Sextern uint32_t __get_CONTROL(void);
S
S/**
S * @brief  Set the Control Register value
S *
S * @param  uint32_t Control value
S * @return none
S *
S * Set the control register
S */
Sextern void __set_CONTROL(uint32_t control);
S
S/**
S * @brief  Reverse byte order in integer value
S *
S * @param  uint32_t value to reverse
S * @return uint32_t reversed value
S *
S * Reverse byte order in integer value
S */
Sextern uint32_t __REV(uint32_t value);
S
S/**
S * @brief  Reverse byte order in unsigned short value
S *
S * @param  uint16_t value to reverse
S * @return uint32_t reversed value
S *
S * Reverse byte order in unsigned short value
S */
Sextern uint32_t __REV16(uint16_t value);
S
S/*
S * Reverse byte order in signed short value with sign extension to integer
S *
S * @param  int16_t value to reverse
S * @return int32_t reversed value
S *
S * @brief  Reverse byte order in signed short value with sign extension to integer
S */
Sextern int32_t __REVSH(int16_t value);
S
S/**
S * @brief  Reverse bit order of value
S *
S * @param  uint32_t value to reverse
S * @return uint32_t reversed value
S *
S * Reverse bit order of value
S */
Sextern uint32_t __RBIT(uint32_t value);
S
S/**
S * @brief  LDR Exclusive
S *
S * @param  uint8_t* address
S * @return uint8_t value of (*address)
S *
S * Exclusive LDR command
S */
Sextern uint8_t __LDREXB(uint8_t *addr);
S
S/**
S * @brief  LDR Exclusive
S *
S * @param  uint16_t* address
S * @return uint16_t value of (*address)
S *
S * Exclusive LDR command
S */
Sextern uint16_t __LDREXH(uint16_t *addr);
S
S/**
S * @brief  LDR Exclusive
S *
S * @param  uint32_t* address
S * @return uint32_t value of (*address)
S *
S * Exclusive LDR command
S */
Sextern uint32_t __LDREXW(uint32_t *addr);
S
S/**
S * @brief  STR Exclusive
S *
S * @param  uint8_t *address
S * @param  uint8_t value to store
S * @return uint32_t successful / failed
S *
S * Exclusive STR command
S */
Sextern uint32_t __STREXB(uint8_t value, uint8_t *addr);
S
S/**
S * @brief  STR Exclusive
S *
S * @param  uint16_t *address
S * @param  uint16_t value to store
S * @return uint32_t successful / failed
S *
S * Exclusive STR command
S */
Sextern uint32_t __STREXH(uint16_t value, uint16_t *addr);
S
S/**
S * @brief  STR Exclusive
S *
S * @param  uint32_t *address
S * @param  uint32_t value to store
S * @return uint32_t successful / failed
S *
S * Exclusive STR command
S */
Sextern uint32_t __STREXW(uint32_t value, uint32_t *addr);
S
S
S#elif (defined (__TASKING__)) /*------------------ TASKING Compiler ---------------------*/
S/* TASKING carm specific functions */
S
S/*
S * The CMSIS functions have been implemented as intrinsics in the compiler.
S * Please use "carm -?i" to get an up to date list of all instrinsics,
S * Including the CMSIS ones.
S */
S
N#endif
N
N
N
N/* ##########################   NVIC functions  #################################### */
N
N
N/**
N * @brief  Set the Priority Grouping in NVIC Interrupt Controller
N *
N * @param  uint32_t priority_grouping is priority grouping field
N * @return none 
N *
N * Set the priority grouping field using the required unlock sequence.
N * The parameter priority_grouping is assigned to the field 
N * SCB->AIRCR [10:8] PRIGROUP field. Only values from 0..7 are used.
N * In case of a conflict between priority grouping and available
N * priority bits (__NVIC_PRIO_BITS) the smallest possible priority group is set.
N */
Nstatic __INLINE void NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
Xstatic __inline void NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
N{
N  uint32_t reg_value;
N  uint32_t PriorityGroupTmp = (PriorityGroup & 0x07);                         /* only values 0..7 are used          */
N  
N  reg_value  = SCB->AIRCR;                                                    /* read old register configuration    */
X  reg_value  = ((SCB_Type *) ((0xE000E000) + 0x0D00))->AIRCR;                                                     
N  reg_value &= ~((0xFFFFU << 16) | (0x0F << 8));                              /* clear bits to change               */
N  reg_value  = ((reg_value | NVIC_AIRCR_VECTKEY | (PriorityGroupTmp << 8)));  /* Insert write key and priorty group */
X  reg_value  = ((reg_value | (0x5FA << 16) | (PriorityGroupTmp << 8)));   
N  SCB->AIRCR = reg_value;
X  ((SCB_Type *) ((0xE000E000) + 0x0D00))->AIRCR = reg_value;
N}
N
N/**
N * @brief  Get the Priority Grouping from NVIC Interrupt Controller
N *
N * @param  none
N * @return uint32_t   priority grouping field 
N *
N * Get the priority grouping from NVIC Interrupt Controller.
N * priority grouping is SCB->AIRCR [10:8] PRIGROUP field.
N */
Nstatic __INLINE uint32_t NVIC_GetPriorityGrouping(void)
Xstatic __inline uint32_t NVIC_GetPriorityGrouping(void)
N{
N  return ((SCB->AIRCR >> 8) & 0x07);                                          /* read priority grouping field */
X  return ((((SCB_Type *) ((0xE000E000) + 0x0D00))->AIRCR >> 8) & 0x07);                                           
N}
N
N/**
N * @brief  Enable Interrupt in NVIC Interrupt Controller
N *
N * @param  IRQn_Type IRQn specifies the interrupt number
N * @return none 
N *
N * Enable a device specific interupt in the NVIC interrupt controller.
N * The interrupt number cannot be a negative value.
N */
Nstatic __INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
Xstatic __inline void NVIC_EnableIRQ(IRQn_Type IRQn)
N{
N  NVIC->ISER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* enable interrupt */
X  ((NVIC_Type *) ((0xE000E000) + 0x0100))->ISER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F));  
N}
N
N/**
N * @brief  Disable the interrupt line for external interrupt specified
N * 
N * @param  IRQn_Type IRQn is the positive number of the external interrupt
N * @return none
N * 
N * Disable a device specific interupt in the NVIC interrupt controller.
N * The interrupt number cannot be a negative value.
N */
Nstatic __INLINE void NVIC_DisableIRQ(IRQn_Type IRQn)
Xstatic __inline void NVIC_DisableIRQ(IRQn_Type IRQn)
N{
N  NVIC->ICER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* disable interrupt */
X  ((NVIC_Type *) ((0xE000E000) + 0x0100))->ICER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F));  
N}
N
N/**
N * @brief  Read the interrupt pending bit for a device specific interrupt source
N * 
N * @param  IRQn_Type IRQn is the number of the device specifc interrupt
N * @return uint32_t 1 if pending interrupt else 0
N *
N * Read the pending register in NVIC and return 1 if its status is pending, 
N * otherwise it returns 0
N */
Nstatic __INLINE uint32_t NVIC_GetPendingIRQ(IRQn_Type IRQn)
Xstatic __inline uint32_t NVIC_GetPendingIRQ(IRQn_Type IRQn)
N{
N  return((uint32_t) ((NVIC->ISPR[(uint32_t)(IRQn) >> 5] & (1 << ((uint32_t)(IRQn) & 0x1F)))?1:0)); /* Return 1 if pending else 0 */
X  return((uint32_t) ((((NVIC_Type *) ((0xE000E000) + 0x0100))->ISPR[(uint32_t)(IRQn) >> 5] & (1 << ((uint32_t)(IRQn) & 0x1F)))?1:0));  
N}
N
N/**
N * @brief  Set the pending bit for an external interrupt
N * 
N * @param  IRQn_Type IRQn is the Number of the interrupt
N * @return none
N *
N * Set the pending bit for the specified interrupt.
N * The interrupt number cannot be a negative value.
N */
Nstatic __INLINE void NVIC_SetPendingIRQ(IRQn_Type IRQn)
Xstatic __inline void NVIC_SetPendingIRQ(IRQn_Type IRQn)
N{
N  NVIC->ISPR[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* set interrupt pending */
X  ((NVIC_Type *) ((0xE000E000) + 0x0100))->ISPR[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F));  
N}
N
N/**
N * @brief  Clear the pending bit for an external interrupt
N *
N * @param  IRQn_Type IRQn is the Number of the interrupt
N * @return none
N *
N * Clear the pending bit for the specified interrupt. 
N * The interrupt number cannot be a negative value.
N */
Nstatic __INLINE void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
Xstatic __inline void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
N{
N  NVIC->ICPR[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* Clear pending interrupt */
X  ((NVIC_Type *) ((0xE000E000) + 0x0100))->ICPR[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F));  
N}
N
N/**
N * @brief  Read the active bit for an external interrupt
N *
N * @param  IRQn_Type  IRQn is the Number of the interrupt
N * @return uint32_t   1 if active else 0
N *
N * Read the active register in NVIC and returns 1 if its status is active, 
N * otherwise it returns 0.
N */
Nstatic __INLINE uint32_t NVIC_GetActive(IRQn_Type IRQn)
Xstatic __inline uint32_t NVIC_GetActive(IRQn_Type IRQn)
N{
N  return((uint32_t)((NVIC->IABR[(uint32_t)(IRQn) >> 5] & (1 << ((uint32_t)(IRQn) & 0x1F)))?1:0)); /* Return 1 if active else 0 */
X  return((uint32_t)((((NVIC_Type *) ((0xE000E000) + 0x0100))->IABR[(uint32_t)(IRQn) >> 5] & (1 << ((uint32_t)(IRQn) & 0x1F)))?1:0));  
N}
N
N/**
N * @brief  Set the priority for an interrupt
N *
N * @param  IRQn_Type IRQn is the Number of the interrupt
N * @param  priority is the priority for the interrupt
N * @return none
N *
N * Set the priority for the specified interrupt. The interrupt 
N * number can be positive to specify an external (device specific) 
N * interrupt, or negative to specify an internal (core) interrupt. \n
N *
N * Note: The priority cannot be set for every core interrupt.
N */
Nstatic __INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
Xstatic __inline void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
N{
N  if(IRQn < 0) {
N    SCB->SHP[((uint32_t)(IRQn) & 0xF)-4] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff); } /* set Priority for Cortex-M3 System Interrupts */
X    ((SCB_Type *) ((0xE000E000) + 0x0D00))->SHP[((uint32_t)(IRQn) & 0xF)-4] = ((priority << (8 - 5)) & 0xff); }  
N  else {
N    NVIC->IP[(uint32_t)(IRQn)] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff);    }        /* set Priority for device specific Interrupts      */
X    ((NVIC_Type *) ((0xE000E000) + 0x0100))->IP[(uint32_t)(IRQn)] = ((priority << (8 - 5)) & 0xff);    }         
N}
N
N/**
N * @brief  Read the priority for an interrupt
N *
N * @param  IRQn_Type IRQn is the Number of the interrupt
N * @return uint32_t  priority is the priority for the interrupt
N *
N * Read the priority for the specified interrupt. The interrupt 
N * number can be positive to specify an external (device specific) 
N * interrupt, or negative to specify an internal (core) interrupt.
N *
N * The returned priority value is automatically aligned to the implemented
N * priority bits of the microcontroller.
N *
N * Note: The priority cannot be set for every core interrupt.
N */
Nstatic __INLINE uint32_t NVIC_GetPriority(IRQn_Type IRQn)
Xstatic __inline uint32_t NVIC_GetPriority(IRQn_Type IRQn)
N{
N
N  if(IRQn < 0) {
N    return((uint32_t)(SCB->SHP[((uint32_t)(IRQn) & 0xF)-4] >> (8 - __NVIC_PRIO_BITS)));  } /* get priority for Cortex-M3 system interrupts */
X    return((uint32_t)(((SCB_Type *) ((0xE000E000) + 0x0D00))->SHP[((uint32_t)(IRQn) & 0xF)-4] >> (8 - 5)));  }  
N  else {
N    return((uint32_t)(NVIC->IP[(uint32_t)(IRQn)]           >> (8 - __NVIC_PRIO_BITS)));  } /* get priority for device specific interrupts  */
X    return((uint32_t)(((NVIC_Type *) ((0xE000E000) + 0x0100))->IP[(uint32_t)(IRQn)]           >> (8 - 5)));  }  
N}
N
N
N/**
N * @brief  Encode the priority for an interrupt
N *
N * @param  uint32_t PriorityGroup   is the used priority group
N * @param  uint32_t PreemptPriority is the preemptive priority value (starting from 0)
N * @param  uint32_t SubPriority     is the sub priority value (starting from 0)
N * @return uint32_t                    the priority for the interrupt
N *
N * Encode the priority for an interrupt with the given priority group,
N * preemptive priority value and sub priority value.
N * In case of a conflict between priority grouping and available
N * priority bits (__NVIC_PRIO_BITS) the samllest possible priority group is set.
N *
N * The returned priority value can be used for NVIC_SetPriority(...) function
N */
Nstatic __INLINE uint32_t NVIC_EncodePriority (uint32_t PriorityGroup, uint32_t PreemptPriority, uint32_t SubPriority)
Xstatic __inline uint32_t NVIC_EncodePriority (uint32_t PriorityGroup, uint32_t PreemptPriority, uint32_t SubPriority)
N{
N  uint32_t PriorityGroupTmp = (PriorityGroup & 0x07);                         /* only values 0..7 are used          */
N  uint32_t PreemptPriorityBits;
N  uint32_t SubPriorityBits;
N
N  PreemptPriorityBits = ((7 - PriorityGroupTmp) > __NVIC_PRIO_BITS) ? __NVIC_PRIO_BITS : 7 - PriorityGroupTmp;
X  PreemptPriorityBits = ((7 - PriorityGroupTmp) > 5) ? 5 : 7 - PriorityGroupTmp;
N  SubPriorityBits     = ((PriorityGroupTmp + __NVIC_PRIO_BITS) < 7) ? 0 : PriorityGroupTmp - 7 + __NVIC_PRIO_BITS;
X  SubPriorityBits     = ((PriorityGroupTmp + 5) < 7) ? 0 : PriorityGroupTmp - 7 + 5;
N 
N  return (
N           ((PreemptPriority & ((1 << (PreemptPriorityBits)) - 1)) << SubPriorityBits) |
N           ((SubPriority     & ((1 << (SubPriorityBits    )) - 1)))
N         );
N}
N
N
N/**
N * @brief  Decode the priority of an interrupt
N *
N * @param  uint32_t   Priority       the priority for the interrupt
N * @param  uint32_t   PrioGroup   is the used priority group
N * @param  uint32_t* pPreemptPrio is the preemptive priority value (starting from 0)
N * @param  uint32_t* pSubPrio     is the sub priority value (starting from 0)
N * @return none
N *
N * Decode an interrupt priority value with the given priority group to 
N * preemptive priority value and sub priority value.
N * In case of a conflict between priority grouping and available
N * priority bits (__NVIC_PRIO_BITS) the samllest possible priority group is set.
N *
N * The priority value can be retrieved with NVIC_GetPriority(...) function
N */
Nstatic __INLINE void NVIC_DecodePriority (uint32_t Priority, uint32_t PriorityGroup, uint32_t* pPreemptPriority, uint32_t* pSubPriority)
Xstatic __inline void NVIC_DecodePriority (uint32_t Priority, uint32_t PriorityGroup, uint32_t* pPreemptPriority, uint32_t* pSubPriority)
N{
N  uint32_t PriorityGroupTmp = (PriorityGroup & 0x07);                         /* only values 0..7 are used          */
N  uint32_t PreemptPriorityBits;
N  uint32_t SubPriorityBits;
N
N  PreemptPriorityBits = ((7 - PriorityGroupTmp) > __NVIC_PRIO_BITS) ? __NVIC_PRIO_BITS : 7 - PriorityGroupTmp;
X  PreemptPriorityBits = ((7 - PriorityGroupTmp) > 5) ? 5 : 7 - PriorityGroupTmp;
N  SubPriorityBits     = ((PriorityGroupTmp + __NVIC_PRIO_BITS) < 7) ? 0 : PriorityGroupTmp - 7 + __NVIC_PRIO_BITS;
X  SubPriorityBits     = ((PriorityGroupTmp + 5) < 7) ? 0 : PriorityGroupTmp - 7 + 5;
N  
N  *pPreemptPriority = (Priority >> SubPriorityBits) & ((1 << (PreemptPriorityBits)) - 1);
N  *pSubPriority     = (Priority                   ) & ((1 << (SubPriorityBits    )) - 1);
N}
N
N
N
N/* ##################################    SysTick function  ############################################ */
N
N#if (!defined (__Vendor_SysTickConfig)) || (__Vendor_SysTickConfig == 0)
X#if (!1L) || (0 == 0)
N
N/* SysTick constants */
N#define SYSTICK_ENABLE              0                                          /* Config-Bit to start or stop the SysTick Timer                         */
N#define SYSTICK_TICKINT             1                                          /* Config-Bit to enable or disable the SysTick interrupt                 */
N#define SYSTICK_CLKSOURCE           2                                          /* Clocksource has the offset 2 in SysTick Control and Status Register   */
N#define SYSTICK_MAXCOUNT       ((1<<24) -1)                                    /* SysTick MaxCount                                                      */
N
N/**
N * @brief  Initialize and start the SysTick counter and its interrupt.
N *
N * @param  uint32_t ticks is the number of ticks between two interrupts
N * @return  none
N *
N * Initialise the system tick timer and its interrupt and start the
N * system tick timer / counter in free running mode to generate 
N * periodical interrupts.
N */
Nstatic __INLINE uint32_t SysTick_Config(uint32_t ticks)
Xstatic __inline uint32_t SysTick_Config(uint32_t ticks)
N{ 
N  if (ticks > SYSTICK_MAXCOUNT)  return (1);                                             /* Reload value impossible */
X  if (ticks > ((1<<24) -1))  return (1);                                              
N
N  SysTick->LOAD  =  (ticks & SYSTICK_MAXCOUNT) - 1;                                      /* set reload register */
X  ((SysTick_Type *) ((0xE000E000) + 0x0010))->LOAD  =  (ticks & ((1<<24) -1)) - 1;                                       
N  NVIC_SetPriority (SysTick_IRQn, (1<<__NVIC_PRIO_BITS) - 1);                            /* set Priority for Cortex-M0 System Interrupts */
X  NVIC_SetPriority (SysTick_IRQn, (1<<5) - 1);                             
N  SysTick->VAL   =  (0x00);                                                              /* Load the SysTick Counter Value */
X  ((SysTick_Type *) ((0xE000E000) + 0x0010))->VAL   =  (0x00);                                                               
N  SysTick->CTRL = (1 << SYSTICK_CLKSOURCE) | (1<<SYSTICK_ENABLE) | (1<<SYSTICK_TICKINT); /* Enable SysTick IRQ and SysTick Timer */
X  ((SysTick_Type *) ((0xE000E000) + 0x0010))->CTRL = (1 << 2) | (1<<0) | (1<<1);  
N  return (0);                                                                            /* Function successful */
N}
N
N#endif
N
N
N
N
N
N/* ##################################    Reset function  ############################################ */
N
N/**
N * @brief  Initiate a system reset request.
N *
N * @param   none
N * @return  none
N *
N * Initialize a system reset request to reset the MCU
N */
Nstatic __INLINE void NVIC_SystemReset(void)
Xstatic __inline void NVIC_SystemReset(void)
N{
N  SCB->AIRCR  = (NVIC_AIRCR_VECTKEY | (SCB->AIRCR & (0x700)) | (1<<NVIC_SYSRESETREQ)); /* Keep priority group unchanged */
X  ((SCB_Type *) ((0xE000E000) + 0x0D00))->AIRCR  = ((0x5FA << 16) | (((SCB_Type *) ((0xE000E000) + 0x0D00))->AIRCR & (0x700)) | (1<<2));  
N  __DSB();                                                                             /* Ensure completion of memory access */              
X  __dsb(0);                                                                                            
N  while(1);                                                                            /* wait until reset */
N}
N
N
N/* ##################################    Debug Output  function  ############################################ */
N
N
N/**
N * @brief  Outputs a character via the ITM channel 0
N *
N * @param   uint32_t character to output
N * @return  uint32_t input character
N *
N * The function outputs a character via the ITM channel 0. 
N * The function returns when no debugger is connected that has booked the output.  
N * It is blocking when a debugger is connected, but the previous character send is not transmitted. 
N */
Nstatic __INLINE uint32_t ITM_SendChar (uint32_t ch)
Xstatic __inline uint32_t ITM_SendChar (uint32_t ch)
N{
N  if (ch == '\n') ITM_SendChar('\r');
N  
N  if ((CoreDebug->DEMCR & CoreDebug_DEMCR_TRCENA)  &&
X  if ((((CoreDebug_Type *) (0xE000EDF0))->DEMCR & (1 << 24))  &&
N      (ITM->TCR & ITM_TCR_ITMENA)                  &&
X      (((ITM_Type *) (0xE0000000))->TCR & 1)                  &&
N      (ITM->TER & (1UL << 0))  ) 
X      (((ITM_Type *) (0xE0000000))->TER & (1UL << 0))  ) 
N  {
N    while (ITM->PORT[0].u32 == 0);
X    while (((ITM_Type *) (0xE0000000))->PORT[0].u32 == 0);
N    ITM->PORT[0].u8 = (uint8_t) ch;
X    ((ITM_Type *) (0xE0000000))->PORT[0].u8 = (uint8_t) ch;
N  }  
N  return (ch);
N}
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __CM3_CORE_H__ */
N
N/*lint -restore */
L 97 "C:\Keil\ARM\INC\NXP\LPC17xx\LPC17xx.h" 2
N#include "system_LPC17xx.h"                 /* System Header                                      */
L 1 "C:\Keil\ARM\INC\NXP\LPC17xx\system_LPC17xx.h" 1
N/******************************************************************************
N * @file:    system_LPC17xx.h
N * @purpose: CMSIS Cortex-M3 Device Peripheral Access Layer Header File
N *           for the NXP LPC17xx Device Series 
N * @version: V1.01
N * @date:    22. Jul. 2009
N *----------------------------------------------------------------------------
N *
N * Copyright (C) 2009 ARM Limited. All rights reserved.
N *
N * ARM Limited (ARM) is supplying this software for use with Cortex-M3 
N * processor based microcontrollers.  This file can be freely distributed 
N * within development tools that are supporting such ARM based processors. 
N *
N * THIS SOFTWARE IS PROVIDED "AS IS".  NO WARRANTIES, WHETHER EXPRESS, IMPLIED
N * OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF
N * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.
N * ARM SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR
N * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
N *
N ******************************************************************************/
N
N
N#ifndef __SYSTEM_LPC17xx_H
N#define __SYSTEM_LPC17xx_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif 
N
Nextern uint32_t SystemFrequency;    /*!< System Clock Frequency (Core Clock)  */
N
N
N/**
N * Initialize the system
N *
N * @param  none
N * @return none
N *
N * @brief  Setup the microcontroller system.
N *         Initialize the System and update the SystemFrequency variable.
N */
Nextern void SystemInit (void);
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __SYSTEM_LPC17xx_H */
L 98 "C:\Keil\ARM\INC\NXP\LPC17xx\LPC17xx.h" 2
N
N
N/******************************************************************************/
N/*                Device Specific Peripheral registers structures             */
N/******************************************************************************/
N
N#if defined ( __CC_ARM   )
X#if 1L
N#pragma anon_unions
N#endif
N
N/*------------- System Control (SC) ------------------------------------------*/
Ntypedef struct
N{
N  __IO uint32_t FLASHCFG;               /* Flash Accelerator Module           */
X  volatile uint32_t FLASHCFG;                
N       uint32_t RESERVED0[31];
N  __IO uint32_t PLL0CON;                /* Clocking and Power Control         */
X  volatile uint32_t PLL0CON;                 
N  __IO uint32_t PLL0CFG;
X  volatile uint32_t PLL0CFG;
N  __I  uint32_t PLL0STAT;
X  volatile const  uint32_t PLL0STAT;
N  __O  uint32_t PLL0FEED;
X  volatile  uint32_t PLL0FEED;
N       uint32_t RESERVED1[4];
N  __IO uint32_t PLL1CON;
X  volatile uint32_t PLL1CON;
N  __IO uint32_t PLL1CFG;
X  volatile uint32_t PLL1CFG;
N  __I  uint32_t PLL1STAT;
X  volatile const  uint32_t PLL1STAT;
N  __O  uint32_t PLL1FEED;
X  volatile  uint32_t PLL1FEED;
N       uint32_t RESERVED2[4];
N  __IO uint32_t PCON;
X  volatile uint32_t PCON;
N  __IO uint32_t PCONP;
X  volatile uint32_t PCONP;
N       uint32_t RESERVED3[15];
N  __IO uint32_t CCLKCFG;
X  volatile uint32_t CCLKCFG;
N  __IO uint32_t USBCLKCFG;
X  volatile uint32_t USBCLKCFG;
N  __IO uint32_t CLKSRCSEL;
X  volatile uint32_t CLKSRCSEL;
N  __IO uint32_t	CANSLEEPCLR;
X  volatile uint32_t	CANSLEEPCLR;
N  __IO uint32_t	CANWAKEFLAGS;
X  volatile uint32_t	CANWAKEFLAGS;
N       uint32_t RESERVED4[10];
N  __IO uint32_t EXTINT;                 /* External Interrupts                */
X  volatile uint32_t EXTINT;                  
N       uint32_t RESERVED5;
N  __IO uint32_t EXTMODE;
X  volatile uint32_t EXTMODE;
N  __IO uint32_t EXTPOLAR;
X  volatile uint32_t EXTPOLAR;
N       uint32_t RESERVED6[12];
N  __IO uint32_t RSID;                   /* Reset                              */
X  volatile uint32_t RSID;                    
N       uint32_t RESERVED7[7];
N  __IO uint32_t SCS;                    /* Syscon Miscellaneous Registers     */
X  volatile uint32_t SCS;                     
N  __IO uint32_t IRCTRIM;                /* Clock Dividers                     */
X  volatile uint32_t IRCTRIM;                 
N  __IO uint32_t PCLKSEL0;
X  volatile uint32_t PCLKSEL0;
N  __IO uint32_t PCLKSEL1;
X  volatile uint32_t PCLKSEL1;
N       uint32_t RESERVED8[4];
N  __IO uint32_t USBIntSt;               /* USB Device/OTG Interrupt Register  */
X  volatile uint32_t USBIntSt;                
N  __IO uint32_t DMAREQSEL;
X  volatile uint32_t DMAREQSEL;
N  __IO uint32_t CLKOUTCFG;              /* Clock Output Configuration         */
X  volatile uint32_t CLKOUTCFG;               
N } LPC_SC_TypeDef;
N
N/*------------- Pin Connect Block (PINCON) -----------------------------------*/
Ntypedef struct
N{
N  __IO uint32_t PINSEL0;
X  volatile uint32_t PINSEL0;
N  __IO uint32_t PINSEL1;
X  volatile uint32_t PINSEL1;
N  __IO uint32_t PINSEL2;
X  volatile uint32_t PINSEL2;
N  __IO uint32_t PINSEL3;
X  volatile uint32_t PINSEL3;
N  __IO uint32_t PINSEL4;
X  volatile uint32_t PINSEL4;
N  __IO uint32_t PINSEL5;
X  volatile uint32_t PINSEL5;
N  __IO uint32_t PINSEL6;
X  volatile uint32_t PINSEL6;
N  __IO uint32_t PINSEL7;
X  volatile uint32_t PINSEL7;
N  __IO uint32_t PINSEL8;
X  volatile uint32_t PINSEL8;
N  __IO uint32_t PINSEL9;
X  volatile uint32_t PINSEL9;
N  __IO uint32_t PINSEL10;
X  volatile uint32_t PINSEL10;
N       uint32_t RESERVED0[5];
N  __IO uint32_t PINMODE0;
X  volatile uint32_t PINMODE0;
N  __IO uint32_t PINMODE1;
X  volatile uint32_t PINMODE1;
N  __IO uint32_t PINMODE2;
X  volatile uint32_t PINMODE2;
N  __IO uint32_t PINMODE3;
X  volatile uint32_t PINMODE3;
N  __IO uint32_t PINMODE4;
X  volatile uint32_t PINMODE4;
N  __IO uint32_t PINMODE5;
X  volatile uint32_t PINMODE5;
N  __IO uint32_t PINMODE6;
X  volatile uint32_t PINMODE6;
N  __IO uint32_t PINMODE7;
X  volatile uint32_t PINMODE7;
N  __IO uint32_t PINMODE8;
X  volatile uint32_t PINMODE8;
N  __IO uint32_t PINMODE9;
X  volatile uint32_t PINMODE9;
N  __IO uint32_t PINMODE_OD0;
X  volatile uint32_t PINMODE_OD0;
N  __IO uint32_t PINMODE_OD1;
X  volatile uint32_t PINMODE_OD1;
N  __IO uint32_t PINMODE_OD2;
X  volatile uint32_t PINMODE_OD2;
N  __IO uint32_t PINMODE_OD3;
X  volatile uint32_t PINMODE_OD3;
N  __IO uint32_t PINMODE_OD4;
X  volatile uint32_t PINMODE_OD4;
N  __IO uint32_t I2CPADCFG;
X  volatile uint32_t I2CPADCFG;
N} LPC_PINCON_TypeDef;
N
N/*------------- General Purpose Input/Output (GPIO) --------------------------*/
Ntypedef struct
N{
N  union {
N    __IO uint32_t FIODIR;
X    volatile uint32_t FIODIR;
N    struct {
N      __IO uint16_t FIODIRL;
X      volatile uint16_t FIODIRL;
N      __IO uint16_t FIODIRH;
X      volatile uint16_t FIODIRH;
N    };
N    struct {
N      __IO uint8_t  FIODIR0;
X      volatile uint8_t  FIODIR0;
N      __IO uint8_t  FIODIR1;
X      volatile uint8_t  FIODIR1;
N      __IO uint8_t  FIODIR2;
X      volatile uint8_t  FIODIR2;
N      __IO uint8_t  FIODIR3;
X      volatile uint8_t  FIODIR3;
N    };
N  };
N  uint32_t RESERVED0[3];
N  union {
N    __IO uint32_t FIOMASK;
X    volatile uint32_t FIOMASK;
N    struct {
N      __IO uint16_t FIOMASKL;
X      volatile uint16_t FIOMASKL;
N      __IO uint16_t FIOMASKH;
X      volatile uint16_t FIOMASKH;
N    };
N    struct {
N      __IO uint8_t  FIOMASK0;
X      volatile uint8_t  FIOMASK0;
N      __IO uint8_t  FIOMASK1;
X      volatile uint8_t  FIOMASK1;
N      __IO uint8_t  FIOMASK2;
X      volatile uint8_t  FIOMASK2;
N      __IO uint8_t  FIOMASK3;
X      volatile uint8_t  FIOMASK3;
N    };
N  };
N  union {
N    __IO uint32_t FIOPIN;
X    volatile uint32_t FIOPIN;
N    struct {
N      __IO uint16_t FIOPINL;
X      volatile uint16_t FIOPINL;
N      __IO uint16_t FIOPINH;
X      volatile uint16_t FIOPINH;
N    };
N    struct {
N      __IO uint8_t  FIOPIN0;
X      volatile uint8_t  FIOPIN0;
N      __IO uint8_t  FIOPIN1;
X      volatile uint8_t  FIOPIN1;
N      __IO uint8_t  FIOPIN2;
X      volatile uint8_t  FIOPIN2;
N      __IO uint8_t  FIOPIN3;
X      volatile uint8_t  FIOPIN3;
N    };
N  };
N  union {
N    __IO uint32_t FIOSET;
X    volatile uint32_t FIOSET;
N    struct {
N      __IO uint16_t FIOSETL;
X      volatile uint16_t FIOSETL;
N      __IO uint16_t FIOSETH;
X      volatile uint16_t FIOSETH;
N    };
N    struct {
N      __IO uint8_t  FIOSET0;
X      volatile uint8_t  FIOSET0;
N      __IO uint8_t  FIOSET1;
X      volatile uint8_t  FIOSET1;
N      __IO uint8_t  FIOSET2;
X      volatile uint8_t  FIOSET2;
N      __IO uint8_t  FIOSET3;
X      volatile uint8_t  FIOSET3;
N    };
N  };
N  union {
N    __O  uint32_t FIOCLR;
X    volatile  uint32_t FIOCLR;
N    struct {
N      __O  uint16_t FIOCLRL;
X      volatile  uint16_t FIOCLRL;
N      __O  uint16_t FIOCLRH;
X      volatile  uint16_t FIOCLRH;
N    };
N    struct {
N      __O  uint8_t  FIOCLR0;
X      volatile  uint8_t  FIOCLR0;
N      __O  uint8_t  FIOCLR1;
X      volatile  uint8_t  FIOCLR1;
N      __O  uint8_t  FIOCLR2;
X      volatile  uint8_t  FIOCLR2;
N      __O  uint8_t  FIOCLR3;
X      volatile  uint8_t  FIOCLR3;
N    };
N  };
N} LPC_GPIO_TypeDef;
N
Ntypedef struct
N{
N  __I  uint32_t IntStatus;
X  volatile const  uint32_t IntStatus;
N  __I  uint32_t IO0IntStatR;
X  volatile const  uint32_t IO0IntStatR;
N  __I  uint32_t IO0IntStatF;
X  volatile const  uint32_t IO0IntStatF;
N  __O  uint32_t IO0IntClr;
X  volatile  uint32_t IO0IntClr;
N  __IO uint32_t IO0IntEnR;
X  volatile uint32_t IO0IntEnR;
N  __IO uint32_t IO0IntEnF;
X  volatile uint32_t IO0IntEnF;
N       uint32_t RESERVED0[3];
N  __I  uint32_t IO2IntStatR;
X  volatile const  uint32_t IO2IntStatR;
N  __I  uint32_t IO2IntStatF;
X  volatile const  uint32_t IO2IntStatF;
N  __O  uint32_t IO2IntClr;
X  volatile  uint32_t IO2IntClr;
N  __IO uint32_t IO2IntEnR;
X  volatile uint32_t IO2IntEnR;
N  __IO uint32_t IO2IntEnF;
X  volatile uint32_t IO2IntEnF;
N} LPC_GPIOINT_TypeDef;
N
N/*------------- Timer (TIM) --------------------------------------------------*/
Ntypedef struct
N{
N  __IO uint32_t IR;
X  volatile uint32_t IR;
N  __IO uint32_t TCR;
X  volatile uint32_t TCR;
N  __IO uint32_t TC;
X  volatile uint32_t TC;
N  __IO uint32_t PR;
X  volatile uint32_t PR;
N  __IO uint32_t PC;
X  volatile uint32_t PC;
N  __IO uint32_t MCR;
X  volatile uint32_t MCR;
N  __IO uint32_t MR0;
X  volatile uint32_t MR0;
N  __IO uint32_t MR1;
X  volatile uint32_t MR1;
N  __IO uint32_t MR2;
X  volatile uint32_t MR2;
N  __IO uint32_t MR3;
X  volatile uint32_t MR3;
N  __IO uint32_t CCR;
X  volatile uint32_t CCR;
N  __I  uint32_t CR0;
X  volatile const  uint32_t CR0;
N  __I  uint32_t CR1;
X  volatile const  uint32_t CR1;
N       uint32_t RESERVED0[2];
N  __IO uint32_t EMR;
X  volatile uint32_t EMR;
N       uint32_t RESERVED1[12];
N  __IO uint32_t CTCR;
X  volatile uint32_t CTCR;
N} LPC_TIM_TypeDef;
N
N/*------------- Pulse-Width Modulation (PWM) ---------------------------------*/
Ntypedef struct
N{
N  __IO uint32_t IR;
X  volatile uint32_t IR;
N  __IO uint32_t TCR;
X  volatile uint32_t TCR;
N  __IO uint32_t TC;
X  volatile uint32_t TC;
N  __IO uint32_t PR;
X  volatile uint32_t PR;
N  __IO uint32_t PC;
X  volatile uint32_t PC;
N  __IO uint32_t MCR;
X  volatile uint32_t MCR;
N  __IO uint32_t MR0;
X  volatile uint32_t MR0;
N  __IO uint32_t MR1;
X  volatile uint32_t MR1;
N  __IO uint32_t MR2;
X  volatile uint32_t MR2;
N  __IO uint32_t MR3;
X  volatile uint32_t MR3;
N  __IO uint32_t CCR;
X  volatile uint32_t CCR;
N  __I  uint32_t CR0;
X  volatile const  uint32_t CR0;
N  __I  uint32_t CR1;
X  volatile const  uint32_t CR1;
N  __I  uint32_t CR2;
X  volatile const  uint32_t CR2;
N  __I  uint32_t CR3;
X  volatile const  uint32_t CR3;
N       uint32_t RESERVED0;
N  __IO uint32_t MR4;
X  volatile uint32_t MR4;
N  __IO uint32_t MR5;
X  volatile uint32_t MR5;
N  __IO uint32_t MR6;
X  volatile uint32_t MR6;
N  __IO uint32_t PCR;
X  volatile uint32_t PCR;
N  __IO uint32_t LER;
X  volatile uint32_t LER;
N       uint32_t RESERVED1[7];
N  __IO uint32_t CTCR;
X  volatile uint32_t CTCR;
N} LPC_PWM_TypeDef;
N
N/*------------- Universal Asynchronous Receiver Transmitter (UART) -----------*/
Ntypedef struct
N{
N  union {
N  __I  uint8_t  RBR;
X  volatile const  uint8_t  RBR;
N  __O  uint8_t  THR;
X  volatile  uint8_t  THR;
N  __IO uint8_t  DLL;
X  volatile uint8_t  DLL;
N       uint32_t RESERVED0;
N  };
N  union {
N  __IO uint8_t  DLM;
X  volatile uint8_t  DLM;
N  __IO uint32_t IER;
X  volatile uint32_t IER;
N  };
N  union {
N  __I  uint32_t IIR;
X  volatile const  uint32_t IIR;
N  __O  uint8_t  FCR;
X  volatile  uint8_t  FCR;
N  };
N  __IO uint8_t  LCR;
X  volatile uint8_t  LCR;
N       uint8_t  RESERVED1[7];
N  __I  uint8_t  LSR;
X  volatile const  uint8_t  LSR;
N       uint8_t  RESERVED2[7];
N  __IO uint8_t  SCR;
X  volatile uint8_t  SCR;
N       uint8_t  RESERVED3[3];
N  __IO uint32_t ACR;
X  volatile uint32_t ACR;
N  __IO uint8_t  ICR;
X  volatile uint8_t  ICR;
N       uint8_t  RESERVED4[3];
N  __IO uint8_t  FDR;
X  volatile uint8_t  FDR;
N       uint8_t  RESERVED5[7];
N  __IO uint8_t  TER;
X  volatile uint8_t  TER;
N       uint8_t  RESERVED6[39];
N  __IO uint32_t FIFOLVL;
X  volatile uint32_t FIFOLVL;
N} LPC_UART_TypeDef;
N
Ntypedef struct
N{
N  union {
N  __I  uint8_t  RBR;
X  volatile const  uint8_t  RBR;
N  __O  uint8_t  THR;
X  volatile  uint8_t  THR;
N  __IO uint8_t  DLL;
X  volatile uint8_t  DLL;
N       uint32_t RESERVED0;
N  };
N  union {
N  __IO uint8_t  DLM;
X  volatile uint8_t  DLM;
N  __IO uint32_t IER;
X  volatile uint32_t IER;
N  };
N  union {
N  __I  uint32_t IIR;
X  volatile const  uint32_t IIR;
N  __O  uint8_t  FCR;
X  volatile  uint8_t  FCR;
N  };
N  __IO uint8_t  LCR;
X  volatile uint8_t  LCR;
N       uint8_t  RESERVED1[7];
N  __I  uint8_t  LSR;
X  volatile const  uint8_t  LSR;
N       uint8_t  RESERVED2[7];
N  __IO uint8_t  SCR;
X  volatile uint8_t  SCR;
N       uint8_t  RESERVED3[3];
N  __IO uint32_t ACR;
X  volatile uint32_t ACR;
N  __IO uint8_t  ICR;
X  volatile uint8_t  ICR;
N       uint8_t  RESERVED4[3];
N  __IO uint8_t  FDR;
X  volatile uint8_t  FDR;
N       uint8_t  RESERVED5[7];
N  __IO uint8_t  TER;
X  volatile uint8_t  TER;
N       uint8_t  RESERVED6[39];
N  __IO uint32_t FIFOLVL;
X  volatile uint32_t FIFOLVL;
N} LPC_UART0_TypeDef;
N
Ntypedef struct
N{
N  union {
N  __I  uint8_t  RBR;
X  volatile const  uint8_t  RBR;
N  __O  uint8_t  THR;
X  volatile  uint8_t  THR;
N  __IO uint8_t  DLL;
X  volatile uint8_t  DLL;
N       uint32_t RESERVED0;
N  };
N  union {
N  __IO uint8_t  DLM;
X  volatile uint8_t  DLM;
N  __IO uint32_t IER;
X  volatile uint32_t IER;
N  };
N  union {
N  __I  uint32_t IIR;
X  volatile const  uint32_t IIR;
N  __O  uint8_t  FCR;
X  volatile  uint8_t  FCR;
N  };
N  __IO uint8_t  LCR;
X  volatile uint8_t  LCR;
N       uint8_t  RESERVED1[3];
N  __IO uint8_t  MCR;
X  volatile uint8_t  MCR;
N       uint8_t  RESERVED2[3];
N  __I  uint8_t  LSR;
X  volatile const  uint8_t  LSR;
N       uint8_t  RESERVED3[3];
N  __I  uint8_t  MSR;
X  volatile const  uint8_t  MSR;
N       uint8_t  RESERVED4[3];
N  __IO uint8_t  SCR;
X  volatile uint8_t  SCR;
N       uint8_t  RESERVED5[3];
N  __IO uint32_t ACR;
X  volatile uint32_t ACR;
N       uint32_t RESERVED6;
N  __IO uint32_t FDR;
X  volatile uint32_t FDR;
N       uint32_t RESERVED7;
N  __IO uint8_t  TER;
X  volatile uint8_t  TER;
N       uint8_t  RESERVED8[27];
N  __IO uint8_t  RS485CTRL;
X  volatile uint8_t  RS485CTRL;
N       uint8_t  RESERVED9[3];
N  __IO uint8_t  ADRMATCH;
X  volatile uint8_t  ADRMATCH;
N       uint8_t  RESERVED10[3];
N  __IO uint8_t  RS485DLY;
X  volatile uint8_t  RS485DLY;
N       uint8_t  RESERVED11[3];
N  __IO uint32_t FIFOLVL;
X  volatile uint32_t FIFOLVL;
N} LPC_UART1_TypeDef;
N
N/*------------- Serial Peripheral Interface (SPI) ----------------------------*/
Ntypedef struct
N{
N  __IO uint32_t SPCR;
X  volatile uint32_t SPCR;
N  __I  uint32_t SPSR;
X  volatile const  uint32_t SPSR;
N  __IO uint32_t SPDR;
X  volatile uint32_t SPDR;
N  __IO uint32_t SPCCR;
X  volatile uint32_t SPCCR;
N       uint32_t RESERVED0[3];
N  __IO uint32_t SPINT;
X  volatile uint32_t SPINT;
N} LPC_SPI_TypeDef;
N
N/*------------- Synchronous Serial Communication (SSP) -----------------------*/
Ntypedef struct
N{
N  __IO uint32_t CR0;
X  volatile uint32_t CR0;
N  __IO uint32_t CR1;
X  volatile uint32_t CR1;
N  __IO uint32_t DR;
X  volatile uint32_t DR;
N  __I  uint32_t SR;
X  volatile const  uint32_t SR;
N  __IO uint32_t CPSR;
X  volatile uint32_t CPSR;
N  __IO uint32_t IMSC;
X  volatile uint32_t IMSC;
N  __IO uint32_t RIS;
X  volatile uint32_t RIS;
N  __IO uint32_t MIS;
X  volatile uint32_t MIS;
N  __IO uint32_t ICR;
X  volatile uint32_t ICR;
N  __IO uint32_t DMACR;
X  volatile uint32_t DMACR;
N} LPC_SSP_TypeDef;
N
N/*------------- Inter-Integrated Circuit (I2C) -------------------------------*/
Ntypedef struct
N{
N  __IO uint32_t I2CONSET;
X  volatile uint32_t I2CONSET;
N  __I  uint32_t I2STAT;
X  volatile const  uint32_t I2STAT;
N  __IO uint32_t I2DAT;
X  volatile uint32_t I2DAT;
N  __IO uint32_t I2ADR0;
X  volatile uint32_t I2ADR0;
N  __IO uint32_t I2SCLH;
X  volatile uint32_t I2SCLH;
N  __IO uint32_t I2SCLL;
X  volatile uint32_t I2SCLL;
N  __O  uint32_t I2CONCLR;
X  volatile  uint32_t I2CONCLR;
N  __IO uint32_t MMCTRL;
X  volatile uint32_t MMCTRL;
N  __IO uint32_t I2ADR1;
X  volatile uint32_t I2ADR1;
N  __IO uint32_t I2ADR2;
X  volatile uint32_t I2ADR2;
N  __IO uint32_t I2ADR3;
X  volatile uint32_t I2ADR3;
N  __I  uint32_t I2DATA_BUFFER;
X  volatile const  uint32_t I2DATA_BUFFER;
N  __IO uint32_t I2MASK0;
X  volatile uint32_t I2MASK0;
N  __IO uint32_t I2MASK1;
X  volatile uint32_t I2MASK1;
N  __IO uint32_t I2MASK2;
X  volatile uint32_t I2MASK2;
N  __IO uint32_t I2MASK3;
X  volatile uint32_t I2MASK3;
N} LPC_I2C_TypeDef;
N
N/*------------- Inter IC Sound (I2S) -----------------------------------------*/
Ntypedef struct
N{
N  __IO uint32_t I2SDAO;
X  volatile uint32_t I2SDAO;
N  __IO uint32_t I2SDAI;
X  volatile uint32_t I2SDAI;
N  __O  uint32_t I2STXFIFO;
X  volatile  uint32_t I2STXFIFO;
N  __I  uint32_t I2SRXFIFO;
X  volatile const  uint32_t I2SRXFIFO;
N  __I  uint32_t I2SSTATE;
X  volatile const  uint32_t I2SSTATE;
N  __IO uint32_t I2SDMA1;
X  volatile uint32_t I2SDMA1;
N  __IO uint32_t I2SDMA2;
X  volatile uint32_t I2SDMA2;
N  __IO uint32_t I2SIRQ;
X  volatile uint32_t I2SIRQ;
N  __IO uint32_t I2STXRATE;
X  volatile uint32_t I2STXRATE;
N  __IO uint32_t I2SRXRATE;
X  volatile uint32_t I2SRXRATE;
N  __IO uint32_t I2STXBITRATE;
X  volatile uint32_t I2STXBITRATE;
N  __IO uint32_t I2SRXBITRATE;
X  volatile uint32_t I2SRXBITRATE;
N  __IO uint32_t I2STXMODE;
X  volatile uint32_t I2STXMODE;
N  __IO uint32_t I2SRXMODE;
X  volatile uint32_t I2SRXMODE;
N} LPC_I2S_TypeDef;
N
N/*------------- Repetitive Interrupt Timer (RIT) -----------------------------*/
Ntypedef struct
N{
N  __IO uint32_t RICOMPVAL;
X  volatile uint32_t RICOMPVAL;
N  __IO uint32_t RIMASK;
X  volatile uint32_t RIMASK;
N  __IO uint8_t  RICTRL;
X  volatile uint8_t  RICTRL;
N       uint8_t  RESERVED0[3];
N  __IO uint32_t RICOUNTER;
X  volatile uint32_t RICOUNTER;
N} LPC_RIT_TypeDef;
N
N/*------------- Real-Time Clock (RTC) ----------------------------------------*/
Ntypedef struct
N{
N  __IO uint8_t  ILR;
X  volatile uint8_t  ILR;
N       uint8_t  RESERVED0[7];
N  __IO uint8_t  CCR;
X  volatile uint8_t  CCR;
N       uint8_t  RESERVED1[3];
N  __IO uint8_t  CIIR;
X  volatile uint8_t  CIIR;
N       uint8_t  RESERVED2[3];
N  __IO uint8_t  AMR;
X  volatile uint8_t  AMR;
N       uint8_t  RESERVED3[3];
N  __I  uint32_t CTIME0;
X  volatile const  uint32_t CTIME0;
N  __I  uint32_t CTIME1;
X  volatile const  uint32_t CTIME1;
N  __I  uint32_t CTIME2;
X  volatile const  uint32_t CTIME2;
N  __IO uint8_t  SEC;
X  volatile uint8_t  SEC;
N       uint8_t  RESERVED4[3];
N  __IO uint8_t  MIN;
X  volatile uint8_t  MIN;
N       uint8_t  RESERVED5[3];
N  __IO uint8_t  HOUR;
X  volatile uint8_t  HOUR;
N       uint8_t  RESERVED6[3];
N  __IO uint8_t  DOM;
X  volatile uint8_t  DOM;
N       uint8_t  RESERVED7[3];
N  __IO uint8_t  DOW;
X  volatile uint8_t  DOW;
N       uint8_t  RESERVED8[3];
N  __IO uint16_t DOY;
X  volatile uint16_t DOY;
N       uint16_t RESERVED9;
N  __IO uint8_t  MONTH;
X  volatile uint8_t  MONTH;
N       uint8_t  RESERVED10[3];
N  __IO uint16_t YEAR;
X  volatile uint16_t YEAR;
N       uint16_t RESERVED11;
N  __IO uint32_t CALIBRATION;
X  volatile uint32_t CALIBRATION;
N  __IO uint32_t GPREG0;
X  volatile uint32_t GPREG0;
N  __IO uint32_t GPREG1;
X  volatile uint32_t GPREG1;
N  __IO uint32_t GPREG2;
X  volatile uint32_t GPREG2;
N  __IO uint32_t GPREG3;
X  volatile uint32_t GPREG3;
N  __IO uint32_t GPREG4;
X  volatile uint32_t GPREG4;
N  __IO uint8_t  RTC_AUXEN;
X  volatile uint8_t  RTC_AUXEN;
N       uint8_t  RESERVED12[3];
N  __IO uint8_t  RTC_AUX;
X  volatile uint8_t  RTC_AUX;
N       uint8_t  RESERVED13[3];
N  __IO uint8_t  ALSEC;
X  volatile uint8_t  ALSEC;
N       uint8_t  RESERVED14[3];
N  __IO uint8_t  ALMIN;
X  volatile uint8_t  ALMIN;
N       uint8_t  RESERVED15[3];
N  __IO uint8_t  ALHOUR;
X  volatile uint8_t  ALHOUR;
N       uint8_t  RESERVED16[3];
N  __IO uint8_t  ALDOM;
X  volatile uint8_t  ALDOM;
N       uint8_t  RESERVED17[3];
N  __IO uint8_t  ALDOW;
X  volatile uint8_t  ALDOW;
N       uint8_t  RESERVED18[3];
N  __IO uint16_t ALDOY;
X  volatile uint16_t ALDOY;
N       uint16_t RESERVED19;
N  __IO uint8_t  ALMON;
X  volatile uint8_t  ALMON;
N       uint8_t  RESERVED20[3];
N  __IO uint16_t ALYEAR;
X  volatile uint16_t ALYEAR;
N       uint16_t RESERVED21;
N} LPC_RTC_TypeDef;
N
N/*------------- Watchdog Timer (WDT) -----------------------------------------*/
Ntypedef struct
N{
N  __IO uint8_t  WDMOD;
X  volatile uint8_t  WDMOD;
N       uint8_t  RESERVED0[3];
N  __IO uint32_t WDTC;
X  volatile uint32_t WDTC;
N  __O  uint8_t  WDFEED;
X  volatile  uint8_t  WDFEED;
N       uint8_t  RESERVED1[3];
N  __I  uint32_t WDTV;
X  volatile const  uint32_t WDTV;
N  __IO uint32_t WDCLKSEL;
X  volatile uint32_t WDCLKSEL;
N} LPC_WDT_TypeDef;
N
N/*------------- Analog-to-Digital Converter (ADC) ----------------------------*/
Ntypedef struct
N{
N  __IO uint32_t ADCR;
X  volatile uint32_t ADCR;
N  __IO uint32_t ADGDR;
X  volatile uint32_t ADGDR;
N       uint32_t RESERVED0;
N  __IO uint32_t ADINTEN;
X  volatile uint32_t ADINTEN;
N  __I  uint32_t ADDR0;
X  volatile const  uint32_t ADDR0;
N  __I  uint32_t ADDR1;
X  volatile const  uint32_t ADDR1;
N  __I  uint32_t ADDR2;
X  volatile const  uint32_t ADDR2;
N  __I  uint32_t ADDR3;
X  volatile const  uint32_t ADDR3;
N  __I  uint32_t ADDR4;
X  volatile const  uint32_t ADDR4;
N  __I  uint32_t ADDR5;
X  volatile const  uint32_t ADDR5;
N  __I  uint32_t ADDR6;
X  volatile const  uint32_t ADDR6;
N  __I  uint32_t ADDR7;
X  volatile const  uint32_t ADDR7;
N  __I  uint32_t ADSTAT;
X  volatile const  uint32_t ADSTAT;
N  __IO uint32_t ADTRM;
X  volatile uint32_t ADTRM;
N} LPC_ADC_TypeDef;
N
N/*------------- Digital-to-Analog Converter (DAC) ----------------------------*/
Ntypedef struct
N{
N  __IO uint32_t DACR;
X  volatile uint32_t DACR;
N  __IO uint32_t DACCTRL;
X  volatile uint32_t DACCTRL;
N  __IO uint16_t DACCNTVAL;
X  volatile uint16_t DACCNTVAL;
N} LPC_DAC_TypeDef;
N
N/*------------- Motor Control Pulse-Width Modulation (MCPWM) -----------------*/
Ntypedef struct
N{
N  __I  uint32_t MCCON;
X  volatile const  uint32_t MCCON;
N  __O  uint32_t MCCON_SET;
X  volatile  uint32_t MCCON_SET;
N  __O  uint32_t MCCON_CLR;
X  volatile  uint32_t MCCON_CLR;
N  __I  uint32_t MCCAPCON;
X  volatile const  uint32_t MCCAPCON;
N  __O  uint32_t MCCAPCON_SET;
X  volatile  uint32_t MCCAPCON_SET;
N  __O  uint32_t MCCAPCON_CLR;
X  volatile  uint32_t MCCAPCON_CLR;
N  __IO uint32_t MCTIM0;
X  volatile uint32_t MCTIM0;
N  __IO uint32_t MCTIM1;
X  volatile uint32_t MCTIM1;
N  __IO uint32_t MCTIM2;
X  volatile uint32_t MCTIM2;
N  __IO uint32_t MCPER0;
X  volatile uint32_t MCPER0;
N  __IO uint32_t MCPER1;
X  volatile uint32_t MCPER1;
N  __IO uint32_t MCPER2;
X  volatile uint32_t MCPER2;
N  __IO uint32_t MCPW0;
X  volatile uint32_t MCPW0;
N  __IO uint32_t MCPW1;
X  volatile uint32_t MCPW1;
N  __IO uint32_t MCPW2;
X  volatile uint32_t MCPW2;
N  __IO uint32_t MCDEADTIME;
X  volatile uint32_t MCDEADTIME;
N  __IO uint32_t MCCCP;
X  volatile uint32_t MCCCP;
N  __IO uint32_t MCCR0;
X  volatile uint32_t MCCR0;
N  __IO uint32_t MCCR1;
X  volatile uint32_t MCCR1;
N  __IO uint32_t MCCR2;
X  volatile uint32_t MCCR2;
N  __I  uint32_t MCINTEN;
X  volatile const  uint32_t MCINTEN;
N  __O  uint32_t MCINTEN_SET;
X  volatile  uint32_t MCINTEN_SET;
N  __O  uint32_t MCINTEN_CLR;
X  volatile  uint32_t MCINTEN_CLR;
N  __I  uint32_t MCCNTCON;
X  volatile const  uint32_t MCCNTCON;
N  __O  uint32_t MCCNTCON_SET;
X  volatile  uint32_t MCCNTCON_SET;
N  __O  uint32_t MCCNTCON_CLR;
X  volatile  uint32_t MCCNTCON_CLR;
N  __I  uint32_t MCINTFLAG;
X  volatile const  uint32_t MCINTFLAG;
N  __O  uint32_t MCINTFLAG_SET;
X  volatile  uint32_t MCINTFLAG_SET;
N  __O  uint32_t MCINTFLAG_CLR;
X  volatile  uint32_t MCINTFLAG_CLR;
N  __O  uint32_t MCCAP_CLR;
X  volatile  uint32_t MCCAP_CLR;
N} LPC_MCPWM_TypeDef;
N
N/*------------- Quadrature Encoder Interface (QEI) ---------------------------*/
Ntypedef struct
N{
N  __O  uint32_t QEICON;
X  volatile  uint32_t QEICON;
N  __I  uint32_t QEISTAT;
X  volatile const  uint32_t QEISTAT;
N  __IO uint32_t QEICONF;
X  volatile uint32_t QEICONF;
N  __I  uint32_t QEIPOS;
X  volatile const  uint32_t QEIPOS;
N  __IO uint32_t QEIMAXPOS;
X  volatile uint32_t QEIMAXPOS;
N  __IO uint32_t CMPOS0;
X  volatile uint32_t CMPOS0;
N  __IO uint32_t CMPOS1;
X  volatile uint32_t CMPOS1;
N  __IO uint32_t CMPOS2;
X  volatile uint32_t CMPOS2;
N  __I  uint32_t INXCNT;
X  volatile const  uint32_t INXCNT;
N  __IO uint32_t INXCMP;
X  volatile uint32_t INXCMP;
N  __IO uint32_t QEILOAD;
X  volatile uint32_t QEILOAD;
N  __I  uint32_t QEITIME;
X  volatile const  uint32_t QEITIME;
N  __I  uint32_t QEIVEL;
X  volatile const  uint32_t QEIVEL;
N  __I  uint32_t QEICAP;
X  volatile const  uint32_t QEICAP;
N  __IO uint32_t VELCOMP;
X  volatile uint32_t VELCOMP;
N  __IO uint32_t FILTER;
X  volatile uint32_t FILTER;
N       uint32_t RESERVED0[998];
N  __O  uint32_t QEIIEC;
X  volatile  uint32_t QEIIEC;
N  __O  uint32_t QEIIES;
X  volatile  uint32_t QEIIES;
N  __I  uint32_t QEIINTSTAT;
X  volatile const  uint32_t QEIINTSTAT;
N  __I  uint32_t QEIIE;
X  volatile const  uint32_t QEIIE;
N  __O  uint32_t QEICLR;
X  volatile  uint32_t QEICLR;
N  __O  uint32_t QEISET;
X  volatile  uint32_t QEISET;
N} LPC_QEI_TypeDef;
N
N/*------------- Controller Area Network (CAN) --------------------------------*/
Ntypedef struct
N{
N  __IO uint32_t mask[512];              /* ID Masks                           */
X  volatile uint32_t mask[512];               
N} LPC_CANAF_RAM_TypeDef;
N
Ntypedef struct                          /* Acceptance Filter Registers        */
N{
N  __IO uint32_t AFMR;
X  volatile uint32_t AFMR;
N  __IO uint32_t SFF_sa;
X  volatile uint32_t SFF_sa;
N  __IO uint32_t SFF_GRP_sa;
X  volatile uint32_t SFF_GRP_sa;
N  __IO uint32_t EFF_sa;
X  volatile uint32_t EFF_sa;
N  __IO uint32_t EFF_GRP_sa;
X  volatile uint32_t EFF_GRP_sa;
N  __IO uint32_t ENDofTable;
X  volatile uint32_t ENDofTable;
N  __I  uint32_t LUTerrAd;
X  volatile const  uint32_t LUTerrAd;
N  __I  uint32_t LUTerr;
X  volatile const  uint32_t LUTerr;
N  __IO uint32_t FCANIE;
X  volatile uint32_t FCANIE;
N  __IO uint32_t FCANIC0;
X  volatile uint32_t FCANIC0;
N  __IO uint32_t FCANIC1;
X  volatile uint32_t FCANIC1;
N} LPC_CANAF_TypeDef;
N
Ntypedef struct                          /* Central Registers                  */
N{
N  __I  uint32_t CANTxSR;
X  volatile const  uint32_t CANTxSR;
N  __I  uint32_t CANRxSR;
X  volatile const  uint32_t CANRxSR;
N  __I  uint32_t CANMSR;
X  volatile const  uint32_t CANMSR;
N} LPC_CANCR_TypeDef;
N
Ntypedef struct                          /* Controller Registers               */
N{
N  __IO uint32_t MOD;
X  volatile uint32_t MOD;
N  __O  uint32_t CMR;
X  volatile  uint32_t CMR;
N  __IO uint32_t GSR;
X  volatile uint32_t GSR;
N  __I  uint32_t ICR;
X  volatile const  uint32_t ICR;
N  __IO uint32_t IER;
X  volatile uint32_t IER;
N  __IO uint32_t BTR;
X  volatile uint32_t BTR;
N  __IO uint32_t EWL;
X  volatile uint32_t EWL;
N  __I  uint32_t SR;
X  volatile const  uint32_t SR;
N  __IO uint32_t RFS;
X  volatile uint32_t RFS;
N  __IO uint32_t RID;
X  volatile uint32_t RID;
N  __IO uint32_t RDA;
X  volatile uint32_t RDA;
N  __IO uint32_t RDB;
X  volatile uint32_t RDB;
N  __IO uint32_t TFI1;
X  volatile uint32_t TFI1;
N  __IO uint32_t TID1;
X  volatile uint32_t TID1;
N  __IO uint32_t TDA1;
X  volatile uint32_t TDA1;
N  __IO uint32_t TDB1;
X  volatile uint32_t TDB1;
N  __IO uint32_t TFI2;
X  volatile uint32_t TFI2;
N  __IO uint32_t TID2;
X  volatile uint32_t TID2;
N  __IO uint32_t TDA2;
X  volatile uint32_t TDA2;
N  __IO uint32_t TDB2;
X  volatile uint32_t TDB2;
N  __IO uint32_t TFI3;
X  volatile uint32_t TFI3;
N  __IO uint32_t TID3;
X  volatile uint32_t TID3;
N  __IO uint32_t TDA3;
X  volatile uint32_t TDA3;
N  __IO uint32_t TDB3;
X  volatile uint32_t TDB3;
N} LPC_CAN_TypeDef;
N
N/*------------- General Purpose Direct Memory Access (GPDMA) -----------------*/
Ntypedef struct                          /* Common Registers                   */
N{
N  __I  uint32_t DMACIntStat;
X  volatile const  uint32_t DMACIntStat;
N  __I  uint32_t DMACIntTCStat;
X  volatile const  uint32_t DMACIntTCStat;
N  __O  uint32_t DMACIntTCClear;
X  volatile  uint32_t DMACIntTCClear;
N  __I  uint32_t DMACIntErrStat;
X  volatile const  uint32_t DMACIntErrStat;
N  __O  uint32_t DMACIntErrClr;
X  volatile  uint32_t DMACIntErrClr;
N  __I  uint32_t DMACRawIntTCStat;
X  volatile const  uint32_t DMACRawIntTCStat;
N  __I  uint32_t DMACRawIntErrStat;
X  volatile const  uint32_t DMACRawIntErrStat;
N  __I  uint32_t DMACEnbldChns;
X  volatile const  uint32_t DMACEnbldChns;
N  __IO uint32_t DMACSoftBReq;
X  volatile uint32_t DMACSoftBReq;
N  __IO uint32_t DMACSoftSReq;
X  volatile uint32_t DMACSoftSReq;
N  __IO uint32_t DMACSoftLBReq;
X  volatile uint32_t DMACSoftLBReq;
N  __IO uint32_t DMACSoftLSReq;
X  volatile uint32_t DMACSoftLSReq;
N  __IO uint32_t DMACConfig;
X  volatile uint32_t DMACConfig;
N  __IO uint32_t DMACSync;
X  volatile uint32_t DMACSync;
N} LPC_GPDMA_TypeDef;
N
Ntypedef struct                          /* Channel Registers                  */
N{
N  __IO uint32_t DMACCSrcAddr;
X  volatile uint32_t DMACCSrcAddr;
N  __IO uint32_t DMACCDestAddr;
X  volatile uint32_t DMACCDestAddr;
N  __IO uint32_t DMACCLLI;
X  volatile uint32_t DMACCLLI;
N  __IO uint32_t DMACCControl;
X  volatile uint32_t DMACCControl;
N  __IO uint32_t DMACCConfig;
X  volatile uint32_t DMACCConfig;
N} LPC_GPDMACH_TypeDef;
N
N/*------------- Universal Serial Bus (USB) -----------------------------------*/
Ntypedef struct
N{
N  __I  uint32_t HcRevision;             /* USB Host Registers                 */
X  volatile const  uint32_t HcRevision;              
N  __IO uint32_t HcControl;
X  volatile uint32_t HcControl;
N  __IO uint32_t HcCommandStatus;
X  volatile uint32_t HcCommandStatus;
N  __IO uint32_t HcInterruptStatus;
X  volatile uint32_t HcInterruptStatus;
N  __IO uint32_t HcInterruptEnable;
X  volatile uint32_t HcInterruptEnable;
N  __IO uint32_t HcInterruptDisable;
X  volatile uint32_t HcInterruptDisable;
N  __IO uint32_t HcHCCA;
X  volatile uint32_t HcHCCA;
N  __I  uint32_t HcPeriodCurrentED;
X  volatile const  uint32_t HcPeriodCurrentED;
N  __IO uint32_t HcControlHeadED;
X  volatile uint32_t HcControlHeadED;
N  __IO uint32_t HcControlCurrentED;
X  volatile uint32_t HcControlCurrentED;
N  __IO uint32_t HcBulkHeadED;
X  volatile uint32_t HcBulkHeadED;
N  __IO uint32_t HcBulkCurrentED;
X  volatile uint32_t HcBulkCurrentED;
N  __I  uint32_t HcDoneHead;
X  volatile const  uint32_t HcDoneHead;
N  __IO uint32_t HcFmInterval;
X  volatile uint32_t HcFmInterval;
N  __I  uint32_t HcFmRemaining;
X  volatile const  uint32_t HcFmRemaining;
N  __I  uint32_t HcFmNumber;
X  volatile const  uint32_t HcFmNumber;
N  __IO uint32_t HcPeriodicStart;
X  volatile uint32_t HcPeriodicStart;
N  __IO uint32_t HcLSTreshold;
X  volatile uint32_t HcLSTreshold;
N  __IO uint32_t HcRhDescriptorA;
X  volatile uint32_t HcRhDescriptorA;
N  __IO uint32_t HcRhDescriptorB;
X  volatile uint32_t HcRhDescriptorB;
N  __IO uint32_t HcRhStatus;
X  volatile uint32_t HcRhStatus;
N  __IO uint32_t HcRhPortStatus1;
X  volatile uint32_t HcRhPortStatus1;
N  __IO uint32_t HcRhPortStatus2;
X  volatile uint32_t HcRhPortStatus2;
N       uint32_t RESERVED0[40];
N  __I  uint32_t Module_ID;
X  volatile const  uint32_t Module_ID;
N
N  __I  uint32_t OTGIntSt;               /* USB On-The-Go Registers            */
X  volatile const  uint32_t OTGIntSt;                
N  __IO uint32_t OTGIntEn;
X  volatile uint32_t OTGIntEn;
N  __O  uint32_t OTGIntSet;
X  volatile  uint32_t OTGIntSet;
N  __O  uint32_t OTGIntClr;
X  volatile  uint32_t OTGIntClr;
N  __IO uint32_t OTGStCtrl;
X  volatile uint32_t OTGStCtrl;
N  __IO uint32_t OTGTmr;
X  volatile uint32_t OTGTmr;
N       uint32_t RESERVED1[58];
N
N  __I  uint32_t USBDevIntSt;            /* USB Device Interrupt Registers     */
X  volatile const  uint32_t USBDevIntSt;             
N  __IO uint32_t USBDevIntEn;
X  volatile uint32_t USBDevIntEn;
N  __O  uint32_t USBDevIntClr;
X  volatile  uint32_t USBDevIntClr;
N  __O  uint32_t USBDevIntSet;
X  volatile  uint32_t USBDevIntSet;
N
N  __O  uint32_t USBCmdCode;             /* USB Device SIE Command Registers   */
X  volatile  uint32_t USBCmdCode;              
N  __I  uint32_t USBCmdData;
X  volatile const  uint32_t USBCmdData;
N
N  __I  uint32_t USBRxData;              /* USB Device Transfer Registers      */
X  volatile const  uint32_t USBRxData;               
N  __O  uint32_t USBTxData;
X  volatile  uint32_t USBTxData;
N  __I  uint32_t USBRxPLen;
X  volatile const  uint32_t USBRxPLen;
N  __O  uint32_t USBTxPLen;
X  volatile  uint32_t USBTxPLen;
N  __IO uint32_t USBCtrl;
X  volatile uint32_t USBCtrl;
N  __O  uint32_t USBDevIntPri;
X  volatile  uint32_t USBDevIntPri;
N
N  __I  uint32_t USBEpIntSt;             /* USB Device Endpoint Interrupt Regs */
X  volatile const  uint32_t USBEpIntSt;              
N  __IO uint32_t USBEpIntEn;
X  volatile uint32_t USBEpIntEn;
N  __O  uint32_t USBEpIntClr;
X  volatile  uint32_t USBEpIntClr;
N  __O  uint32_t USBEpIntSet;
X  volatile  uint32_t USBEpIntSet;
N  __O  uint32_t USBEpIntPri;
X  volatile  uint32_t USBEpIntPri;
N
N  __IO uint32_t USBReEp;                /* USB Device Endpoint Realization Reg*/
X  volatile uint32_t USBReEp;                 
N  __O  uint32_t USBEpInd;
X  volatile  uint32_t USBEpInd;
N  __IO uint32_t USBMaxPSize;
X  volatile uint32_t USBMaxPSize;
N
N  __I  uint32_t USBDMARSt;              /* USB Device DMA Registers           */
X  volatile const  uint32_t USBDMARSt;               
N  __O  uint32_t USBDMARClr;
X  volatile  uint32_t USBDMARClr;
N  __O  uint32_t USBDMARSet;
X  volatile  uint32_t USBDMARSet;
N       uint32_t RESERVED2[9];
N  __IO uint32_t USBUDCAH;
X  volatile uint32_t USBUDCAH;
N  __I  uint32_t USBEpDMASt;
X  volatile const  uint32_t USBEpDMASt;
N  __O  uint32_t USBEpDMAEn;
X  volatile  uint32_t USBEpDMAEn;
N  __O  uint32_t USBEpDMADis;
X  volatile  uint32_t USBEpDMADis;
N  __I  uint32_t USBDMAIntSt;
X  volatile const  uint32_t USBDMAIntSt;
N  __IO uint32_t USBDMAIntEn;
X  volatile uint32_t USBDMAIntEn;
N       uint32_t RESERVED3[2];
N  __I  uint32_t USBEoTIntSt;
X  volatile const  uint32_t USBEoTIntSt;
N  __O  uint32_t USBEoTIntClr;
X  volatile  uint32_t USBEoTIntClr;
N  __O  uint32_t USBEoTIntSet;
X  volatile  uint32_t USBEoTIntSet;
N  __I  uint32_t USBNDDRIntSt;
X  volatile const  uint32_t USBNDDRIntSt;
N  __O  uint32_t USBNDDRIntClr;
X  volatile  uint32_t USBNDDRIntClr;
N  __O  uint32_t USBNDDRIntSet;
X  volatile  uint32_t USBNDDRIntSet;
N  __I  uint32_t USBSysErrIntSt;
X  volatile const  uint32_t USBSysErrIntSt;
N  __O  uint32_t USBSysErrIntClr;
X  volatile  uint32_t USBSysErrIntClr;
N  __O  uint32_t USBSysErrIntSet;
X  volatile  uint32_t USBSysErrIntSet;
N       uint32_t RESERVED4[15];
N
N  union {
N  __I  uint32_t I2C_RX;                 /* USB OTG I2C Registers              */
X  volatile const  uint32_t I2C_RX;                  
N  __O  uint32_t I2C_TX;
X  volatile  uint32_t I2C_TX;
N  };
N  __I  uint32_t I2C_STS;
X  volatile const  uint32_t I2C_STS;
N  __IO uint32_t I2C_CTL;
X  volatile uint32_t I2C_CTL;
N  __IO uint32_t I2C_CLKHI;
X  volatile uint32_t I2C_CLKHI;
N  __O  uint32_t I2C_CLKLO;
X  volatile  uint32_t I2C_CLKLO;
N       uint32_t RESERVED5[824];
N
N  union {
N  __IO uint32_t USBClkCtrl;             /* USB Clock Control Registers        */
X  volatile uint32_t USBClkCtrl;              
N  __IO uint32_t OTGClkCtrl;
X  volatile uint32_t OTGClkCtrl;
N  };
N  union {
N  __I  uint32_t USBClkSt;
X  volatile const  uint32_t USBClkSt;
N  __I  uint32_t OTGClkSt;
X  volatile const  uint32_t OTGClkSt;
N  };
N} LPC_USB_TypeDef;
N
N/*------------- Ethernet Media Access Controller (EMAC) ----------------------*/
Ntypedef struct
N{
N  __IO uint32_t MAC1;                   /* MAC Registers                      */
X  volatile uint32_t MAC1;                    
N  __IO uint32_t MAC2;
X  volatile uint32_t MAC2;
N  __IO uint32_t IPGT;
X  volatile uint32_t IPGT;
N  __IO uint32_t IPGR;
X  volatile uint32_t IPGR;
N  __IO uint32_t CLRT;
X  volatile uint32_t CLRT;
N  __IO uint32_t MAXF;
X  volatile uint32_t MAXF;
N  __IO uint32_t SUPP;
X  volatile uint32_t SUPP;
N  __IO uint32_t TEST;
X  volatile uint32_t TEST;
N  __IO uint32_t MCFG;
X  volatile uint32_t MCFG;
N  __IO uint32_t MCMD;
X  volatile uint32_t MCMD;
N  __IO uint32_t MADR;
X  volatile uint32_t MADR;
N  __O  uint32_t MWTD;
X  volatile  uint32_t MWTD;
N  __I  uint32_t MRDD;
X  volatile const  uint32_t MRDD;
N  __I  uint32_t MIND;
X  volatile const  uint32_t MIND;
N       uint32_t RESERVED0[2];
N  __IO uint32_t SA0;
X  volatile uint32_t SA0;
N  __IO uint32_t SA1;
X  volatile uint32_t SA1;
N  __IO uint32_t SA2;
X  volatile uint32_t SA2;
N       uint32_t RESERVED1[45];
N  __IO uint32_t Command;                /* Control Registers                  */
X  volatile uint32_t Command;                 
N  __I  uint32_t Status;
X  volatile const  uint32_t Status;
N  __IO uint32_t RxDescriptor;
X  volatile uint32_t RxDescriptor;
N  __IO uint32_t RxStatus;
X  volatile uint32_t RxStatus;
N  __IO uint32_t RxDescriptorNumber;
X  volatile uint32_t RxDescriptorNumber;
N  __I  uint32_t RxProduceIndex;
X  volatile const  uint32_t RxProduceIndex;
N  __IO uint32_t RxConsumeIndex;
X  volatile uint32_t RxConsumeIndex;
N  __IO uint32_t TxDescriptor;
X  volatile uint32_t TxDescriptor;
N  __IO uint32_t TxStatus;
X  volatile uint32_t TxStatus;
N  __IO uint32_t TxDescriptorNumber;
X  volatile uint32_t TxDescriptorNumber;
N  __IO uint32_t TxProduceIndex;
X  volatile uint32_t TxProduceIndex;
N  __I  uint32_t TxConsumeIndex;
X  volatile const  uint32_t TxConsumeIndex;
N       uint32_t RESERVED2[10];
N  __I  uint32_t TSV0;
X  volatile const  uint32_t TSV0;
N  __I  uint32_t TSV1;
X  volatile const  uint32_t TSV1;
N  __I  uint32_t RSV;
X  volatile const  uint32_t RSV;
N       uint32_t RESERVED3[3];
N  __IO uint32_t FlowControlCounter;
X  volatile uint32_t FlowControlCounter;
N  __I  uint32_t FlowControlStatus;
X  volatile const  uint32_t FlowControlStatus;
N       uint32_t RESERVED4[34];
N  __IO uint32_t RxFilterCtrl;           /* Rx Filter Registers                */
X  volatile uint32_t RxFilterCtrl;            
N  __IO uint32_t RxFilterWoLStatus;
X  volatile uint32_t RxFilterWoLStatus;
N  __IO uint32_t RxFilterWoLClear;
X  volatile uint32_t RxFilterWoLClear;
N       uint32_t RESERVED5;
N  __IO uint32_t HashFilterL;
X  volatile uint32_t HashFilterL;
N  __IO uint32_t HashFilterH;
X  volatile uint32_t HashFilterH;
N       uint32_t RESERVED6[882];
N  __I  uint32_t IntStatus;              /* Module Control Registers           */
X  volatile const  uint32_t IntStatus;               
N  __IO uint32_t IntEnable;
X  volatile uint32_t IntEnable;
N  __O  uint32_t IntClear;
X  volatile  uint32_t IntClear;
N  __O  uint32_t IntSet;
X  volatile  uint32_t IntSet;
N       uint32_t RESERVED7;
N  __IO uint32_t PowerDown;
X  volatile uint32_t PowerDown;
N       uint32_t RESERVED8;
N  __IO uint32_t Module_ID;
X  volatile uint32_t Module_ID;
N} LPC_EMAC_TypeDef;
N
N#if defined ( __CC_ARM   )
X#if 1L
N#pragma no_anon_unions
N#endif
N
N
N/******************************************************************************/
N/*                         Peripheral memory map                              */
N/******************************************************************************/
N/* Base addresses                                                             */
N#define LPC_FLASH_BASE        (0x00000000UL)
N#define LPC_RAM_BASE          (0x10000000UL)
N#define LPC_GPIO_BASE         (0x2009C000UL)
N#define LPC_APB0_BASE         (0x40000000UL)
N#define LPC_APB1_BASE         (0x40080000UL)
N#define LPC_AHB_BASE          (0x50000000UL)
N#define LPC_CM3_BASE          (0xE0000000UL)
N
N/* APB0 peripherals                                                           */
N#define LPC_WDT_BASE          (LPC_APB0_BASE + 0x00000)
N#define LPC_TIM0_BASE         (LPC_APB0_BASE + 0x04000)
N#define LPC_TIM1_BASE         (LPC_APB0_BASE + 0x08000)
N#define LPC_UART0_BASE        (LPC_APB0_BASE + 0x0C000)
N#define LPC_UART1_BASE        (LPC_APB0_BASE + 0x10000)
N#define LPC_PWM1_BASE         (LPC_APB0_BASE + 0x18000)
N#define LPC_I2C0_BASE         (LPC_APB0_BASE + 0x1C000)
N#define LPC_SPI_BASE          (LPC_APB0_BASE + 0x20000)
N#define LPC_RTC_BASE          (LPC_APB0_BASE + 0x24000)
N#define LPC_GPIOINT_BASE      (LPC_APB0_BASE + 0x28080)
N#define LPC_PINCON_BASE       (LPC_APB0_BASE + 0x2C000)
N#define LPC_SSP1_BASE         (LPC_APB0_BASE + 0x30000)
N#define LPC_ADC_BASE          (LPC_APB0_BASE + 0x34000)
N#define LPC_CANAF_RAM_BASE    (LPC_APB0_BASE + 0x38000)
N#define LPC_CANAF_BASE        (LPC_APB0_BASE + 0x3C000)
N#define LPC_CANCR_BASE        (LPC_APB0_BASE + 0x40000)
N#define LPC_CAN1_BASE         (LPC_APB0_BASE + 0x44000)
N#define LPC_CAN2_BASE         (LPC_APB0_BASE + 0x48000)
N#define LPC_I2C1_BASE         (LPC_APB0_BASE + 0x5C000)
N
N/* APB1 peripherals                                                           */
N#define LPC_SSP0_BASE         (LPC_APB1_BASE + 0x08000)
N#define LPC_DAC_BASE          (LPC_APB1_BASE + 0x0C000)
N#define LPC_TIM2_BASE         (LPC_APB1_BASE + 0x10000)
N#define LPC_TIM3_BASE         (LPC_APB1_BASE + 0x14000)
N#define LPC_UART2_BASE        (LPC_APB1_BASE + 0x18000)
N#define LPC_UART3_BASE        (LPC_APB1_BASE + 0x1C000)
N#define LPC_I2C2_BASE         (LPC_APB1_BASE + 0x20000)
N#define LPC_I2S_BASE          (LPC_APB1_BASE + 0x28000)
N#define LPC_RIT_BASE          (LPC_APB1_BASE + 0x30000)
N#define LPC_MCPWM_BASE        (LPC_APB1_BASE + 0x38000)
N#define LPC_QEI_BASE          (LPC_APB1_BASE + 0x3C000)
N#define LPC_SC_BASE           (LPC_APB1_BASE + 0x7C000)
N
N/* AHB peripherals                                                            */
N#define LPC_EMAC_BASE         (LPC_AHB_BASE  + 0x00000)
N#define LPC_GPDMA_BASE        (LPC_AHB_BASE  + 0x04000)
N#define LPC_GPDMACH0_BASE     (LPC_AHB_BASE  + 0x04100)
N#define LPC_GPDMACH1_BASE     (LPC_AHB_BASE  + 0x04120)
N#define LPC_GPDMACH2_BASE     (LPC_AHB_BASE  + 0x04140)
N#define LPC_GPDMACH3_BASE     (LPC_AHB_BASE  + 0x04160)
N#define LPC_GPDMACH4_BASE     (LPC_AHB_BASE  + 0x04180)
N#define LPC_GPDMACH5_BASE     (LPC_AHB_BASE  + 0x041A0)
N#define LPC_GPDMACH6_BASE     (LPC_AHB_BASE  + 0x041C0)
N#define LPC_GPDMACH7_BASE     (LPC_AHB_BASE  + 0x041E0)
N#define LPC_USB_BASE          (LPC_AHB_BASE  + 0x0C000)
N
N/* GPIOs                                                                      */
N#define LPC_GPIO0_BASE        (LPC_GPIO_BASE + 0x00000)
N#define LPC_GPIO1_BASE        (LPC_GPIO_BASE + 0x00020)
N#define LPC_GPIO2_BASE        (LPC_GPIO_BASE + 0x00040)
N#define LPC_GPIO3_BASE        (LPC_GPIO_BASE + 0x00060)
N#define LPC_GPIO4_BASE        (LPC_GPIO_BASE + 0x00080)
N
N
N/******************************************************************************/
N/*                         Peripheral declaration                             */
N/******************************************************************************/
N#define LPC_SC                ((LPC_SC_TypeDef        *) LPC_SC_BASE       )
N#define LPC_GPIO0             ((LPC_GPIO_TypeDef      *) LPC_GPIO0_BASE    )
N#define LPC_GPIO1             ((LPC_GPIO_TypeDef      *) LPC_GPIO1_BASE    )
N#define LPC_GPIO2             ((LPC_GPIO_TypeDef      *) LPC_GPIO2_BASE    )
N#define LPC_GPIO3             ((LPC_GPIO_TypeDef      *) LPC_GPIO3_BASE    )
N#define LPC_GPIO4             ((LPC_GPIO_TypeDef      *) LPC_GPIO4_BASE    )
N#define LPC_WDT               ((LPC_WDT_TypeDef       *) LPC_WDT_BASE      )
N#define LPC_TIM0              ((LPC_TIM_TypeDef       *) LPC_TIM0_BASE     )
N#define LPC_TIM1              ((LPC_TIM_TypeDef       *) LPC_TIM1_BASE     )
N#define LPC_TIM2              ((LPC_TIM_TypeDef       *) LPC_TIM2_BASE     )
N#define LPC_TIM3              ((LPC_TIM_TypeDef       *) LPC_TIM3_BASE     )
N#define LPC_RIT               ((LPC_RIT_TypeDef       *) LPC_RIT_BASE      )
N#define LPC_UART0             ((LPC_UART0_TypeDef     *) LPC_UART0_BASE    )
N#define LPC_UART1             ((LPC_UART1_TypeDef     *) LPC_UART1_BASE    )
N#define LPC_UART2             ((LPC_UART_TypeDef      *) LPC_UART2_BASE    )
N#define LPC_UART3             ((LPC_UART_TypeDef      *) LPC_UART3_BASE    )
N#define LPC_PWM1              ((LPC_PWM_TypeDef       *) LPC_PWM1_BASE     )
N#define LPC_I2C0              ((LPC_I2C_TypeDef       *) LPC_I2C0_BASE     )
N#define LPC_I2C1              ((LPC_I2C_TypeDef       *) LPC_I2C1_BASE     )
N#define LPC_I2C2              ((LPC_I2C_TypeDef       *) LPC_I2C2_BASE     )
N#define LPC_I2S               ((LPC_I2S_TypeDef       *) LPC_I2S_BASE      )
N#define LPC_SPI               ((LPC_SPI_TypeDef       *) LPC_SPI_BASE      )
N#define LPC_RTC               ((LPC_RTC_TypeDef       *) LPC_RTC_BASE      )
N#define LPC_GPIOINT           ((LPC_GPIOINT_TypeDef   *) LPC_GPIOINT_BASE  )
N#define LPC_PINCON            ((LPC_PINCON_TypeDef    *) LPC_PINCON_BASE   )
N#define LPC_SSP0              ((LPC_SSP_TypeDef       *) LPC_SSP0_BASE     )
N#define LPC_SSP1              ((LPC_SSP_TypeDef       *) LPC_SSP1_BASE     )
N#define LPC_ADC               ((LPC_ADC_TypeDef       *) LPC_ADC_BASE      )
N#define LPC_DAC               ((LPC_DAC_TypeDef       *) LPC_DAC_BASE      )
N#define LPC_CANAF_RAM         ((LPC_CANAF_RAM_TypeDef *) LPC_CANAF_RAM_BASE)
N#define LPC_CANAF             ((LPC_CANAF_TypeDef     *) LPC_CANAF_BASE    )
N#define LPC_CANCR             ((LPC_CANCR_TypeDef     *) LPC_CANCR_BASE    )
N#define LPC_CAN1              ((LPC_CAN_TypeDef       *) LPC_CAN1_BASE     )
N#define LPC_CAN2              ((LPC_CAN_TypeDef       *) LPC_CAN2_BASE     )
N#define LPC_MCPWM             ((LPC_MCPWM_TypeDef     *) LPC_MCPWM_BASE    )
N#define LPC_QEI               ((LPC_QEI_TypeDef       *) LPC_QEI_BASE      )
N#define LPC_EMAC              ((LPC_EMAC_TypeDef      *) LPC_EMAC_BASE     )
N#define LPC_GPDMA             ((LPC_GPDMA_TypeDef     *) LPC_GPDMA_BASE    )
N#define LPC_GPDMACH0          ((LPC_GPDMACH_TypeDef   *) LPC_GPDMACH0_BASE )
N#define LPC_GPDMACH1          ((LPC_GPDMACH_TypeDef   *) LPC_GPDMACH1_BASE )
N#define LPC_GPDMACH2          ((LPC_GPDMACH_TypeDef   *) LPC_GPDMACH2_BASE )
N#define LPC_GPDMACH3          ((LPC_GPDMACH_TypeDef   *) LPC_GPDMACH3_BASE )
N#define LPC_GPDMACH4          ((LPC_GPDMACH_TypeDef   *) LPC_GPDMACH4_BASE )
N#define LPC_GPDMACH5          ((LPC_GPDMACH_TypeDef   *) LPC_GPDMACH5_BASE )
N#define LPC_GPDMACH6          ((LPC_GPDMACH_TypeDef   *) LPC_GPDMACH6_BASE )
N#define LPC_GPDMACH7          ((LPC_GPDMACH_TypeDef   *) LPC_GPDMACH7_BASE )
N#define LPC_USB               ((LPC_USB_TypeDef       *) LPC_USB_BASE      )
N
N#endif  // __LPC17xx_H__
L 15 "src\tcpip\EMAC_LPC17xx.c" 2
N
N#include "hardware_profile.h"
L 1 ".\inc\hardware_profile.h" 1
N/****************************************Copyright (c)****************************************************
N**								SAPIEN SOLUES INTELIGENTES
N**--------------File Info---------------------------------------------------------------------------------
N** File name:           HardwareProfile.h
N** Last modified Date:  25-01-2013 (Rgis)
N** Last Version:        V1.00
N** Descriptions:        
N**
N**--------------------------------------------------------------------------------------------------------
N** Created by:          Sapien S.I.
N** Created date:        24-04-2012 (Rgis)
N** Version:             V1.00
N** Descriptions:        
N**
N**--------------------------------------------------------------------------------------------------------
N*********************************************************************************************************/
N
N#ifndef __HARDWARE_PROFILE_H__
N#define __HARDWARE_PROFILE_H__
N
N#include <LPC17XX.H>
N
N								/* GERAL */
N/* Porta 0 */
N#define read0(x)		(LPC_GPIO0->FIOPIN &  (1<<x))
N#define set0(x)			LPC_GPIO0->FIOSET |= (1<<x)
N#define clr0(x)			LPC_GPIO0->FIOCLR |= (1<<x)
N#define output0(x)		LPC_GPIO0->FIODIR |= (1<<x)
N#define input0(x)		LPC_GPIO0->FIODIR &=~(1<<x)
N#define toggle0(x)		if(read0(x)) clr0(x); else  set0(x)
N
N/* Porta 1 */
N#define read1(x)		(LPC_GPIO1->FIOPIN &  (1<<x))
N#define set1(x)			LPC_GPIO1->FIOSET |= (1<<x)
N#define clr1(x)			LPC_GPIO1->FIOCLR |= (1<<x)
N#define output1(x)		LPC_GPIO1->FIODIR |= (1<<x)
N#define input1(x)		LPC_GPIO1->FIODIR &=~(1<<x)
N#define toggle1(x)		if(read1(x)) clr1(x); else  set1(x)
N
N/* Porta 2 */
N#define read2(x)		(LPC_GPIO2->FIOPIN &  (1<<x))
N#define set2(x)			LPC_GPIO2->FIOSET |= (1<<x)
N#define clr2(x)			LPC_GPIO2->FIOCLR |= (1<<x)
N#define output2(x)		LPC_GPIO2->FIODIR |= (1<<x)
N#define input2(x)		LPC_GPIO2->FIODIR &=~(1<<x)
N#define toggle2(x)		if(read2(x)) clr2(x); else  set2(x)
N
N/* Porta 3 */
N#define read3(x)		(LPC_GPIO3->FIOPIN &  (1<<x))
N#define set3(x)			LPC_GPIO3->FIOSET |= (1<<x)
N#define clr3(x)			LPC_GPIO3->FIOCLR |= (1<<x)
N#define output3(x)		LPC_GPIO3->FIODIR |= (1<<x)
N#define input3(x)		LPC_GPIO3->FIODIR &=~(1<<x)
N#define toggle3(x)		if(read3(x)) clr3(x); else  set3(x)
N
N/* Porta 4 */
N#define read4(x)		(LPC_GPIO4->FIOPIN &  (1<<x))
N#define set4(x)			LPC_GPIO4->FIOSET |= (1<<x)
N#define clr4(x)			LPC_GPIO4->FIOCLR |= (1<<x)
N#define output4(x)		LPC_GPIO4->FIODIR |= (1<<x)
N#define input4(x)		LPC_GPIO4->FIODIR &=~(1<<x)
N#define toggle4(x)		if(read4(x)) clr4(x); else  set4(x)
N
N/*********Definioes de hardware para a funo IR*********/
N
N#define USE_IR				1		/*Define se a funo IR da placa ser usada ou no*/
N
N#define USE_IR_OUT_ON_HIGH	1		/*Define se o IR acender com pulso high saindo do pino do micro*/	
N
N#define PIN_RCV_IR			3		/*P2.3 correto */ 
N//#define PIN_RCV_IR			7		/*P0.7*/
N
N
N#define PIN_IR_OUT_0		0		/*P2.0*/
N#define PIN_IR_OUT_1	 	1		/*P2.1*/
N#define PIN_IR_OUT_2	 	2		/*P2.2*/
N//#define PIN_IR_OUT_3	 	3		/*P2.3*/
N//#define PIN_IR_OUT_4	 	4		/*P2.4*/
N
N#define RECEIVE_IR()  		(read2(PIN_RCV_IR))
N//#define RECEIVE_IR()  		(read0(PIN_RCV_IR))
N
N#define READ_IROUT_0() 		(read2(PIN_IR_OUT_0))
N#define READ_IROUT_1() 		(read2(PIN_IR_OUT_1))
N#define READ_IROUT_2() 		(read2(PIN_IR_OUT_2))
N//#define READ_IROUT_3() 		(read2(PIN_IR_OUT_3))
N//#define READ_IROUT_4() 		(read2(PIN_IR_OUT_4))
N
N#define READ_KEY_LEARN()	READ_KEY1_BOARD()
N
N#define LED_LEARN_TOG()		LED_PWR_TOG()	
N
N
N#if USE_IR_OUT_ON_HIGH	
X#if 1	
N#define dir_ir()			input2(PIN_RCV_IR);		\
N							output2(PIN_IR_OUT_0); 	\
N							output2(PIN_IR_OUT_1); 	\
N							output2(PIN_IR_OUT_2); 	\
N							clr2(PIN_IR_OUT_0);    	\
N							clr2(PIN_IR_OUT_1);    	\
N							clr2(PIN_IR_OUT_2);    							
X#define dir_ir()			input2(PIN_RCV_IR);									output2(PIN_IR_OUT_0); 								output2(PIN_IR_OUT_1); 								output2(PIN_IR_OUT_2); 								clr2(PIN_IR_OUT_0);    								clr2(PIN_IR_OUT_1);    								clr2(PIN_IR_OUT_2);    							
N#else  					
S#define dir_ir()			input2(PIN_RCV_IR);		\
S							output2(PIN_IR_OUT_0); 	\
S							output2(PIN_IR_OUT_1); 	\
S							output2(PIN_IR_OUT_2); 	\
S							set2(PIN_IR_OUT_0);    	\
S							set2(PIN_IR_OUT_1);    	\
S							set2(PIN_IR_OUT_2);    										
X#define dir_ir()			input2(PIN_RCV_IR);									output2(PIN_IR_OUT_0); 								output2(PIN_IR_OUT_1); 								output2(PIN_IR_OUT_2); 								set2(PIN_IR_OUT_0);    								set2(PIN_IR_OUT_1);    								set2(PIN_IR_OUT_2);    										
N#endif
N
N
N#if USE_IR
X#if 1
N#define dir_funcao_ir()		dir_ir(); 
N#else
S#define dir_funcao_ir()		{} 
N#endif
N
N/*********Definioes de hardware para a funo Shift Register*********/
N
N#define PINO_MR			4		/* P0.4 */
N#define PINO_DS			5		/* P0.5 */
N#define PINO_ST			6		/* P0.6 */
N#define PINO_SH			15		/* P0.15 */
N
N#define dir_mr()		output0(PINO_MR)   	/*Pino MR  como saida*/
N#define dir_ds()		output0(PINO_DS)   	/*Pino DS  como saida*/
N#define dir_st()		output0(PINO_ST)  	/*Pino ST como saida*/
N#define dir_sh()		output0(PINO_SH)  	/*Pino SH como saida*/
N
N#define MR(x)	    	if(x)set0(PINO_MR);  else clr0(PINO_MR);	/*Config MR(Reset)*/	
N#define DS(x)	    	if(x)set0(PINO_DS);  else clr0(PINO_DS);	/*Config DS(Dado) */
N#define ST(x)	    	if(x)set0(PINO_ST);  else clr0(PINO_ST);	/*Config ST(Latch)*/
N#define SH(x)	    	if(x)set0(PINO_SH);  else clr0(PINO_SH);	/*Config SH(Clock)*/		
N
N#define dir_reg()	    dir_st(); \
N						dir_sh(); \
N						dir_ds(); \
N						dir_mr(); \
N						MR(1); \
N						DS(1); \
N						SH(1); \
N						ST(1); 
X#define dir_reg()	    dir_st(); 						dir_sh(); 						dir_ds(); 						dir_mr(); 						MR(1); 						DS(1); 						SH(1); 						ST(1); 
N
N
N/*********Definioes para o Teclado Matricial 4x2*********/
N
N
N/*******************
N**	KEY_LIN1	p0.25
N**	KEY_LIN2	p0.23
N**	KEY_LIN3	p0.26
N**	KEY_LIN4	p0.24
N**	KEY_COL1	p1.31
N**	KEY_COL2	p1.30
N*******************/
N
N/* Linhas */
N#define key_lin1	25
N#define key_lin2	23
N#define key_lin3	26
N#define key_lin4	24
N
N/* Colunas */
N#define key_col1	31ul
N#define key_col2	30ul
N
N
N/* Configura linhas do teclado como entrada */
N#define dir_key_lin1()	input0(key_lin1)
N#define dir_key_lin2()	input0(key_lin2)
N#define dir_key_lin3()	input0(key_lin3)
N#define dir_key_lin4()	input0(key_lin4)
N
N#define rd_key_lin1()	read0(key_lin1)
N#define rd_key_lin2()	read0(key_lin2)
N#define rd_key_lin3()	read0(key_lin3)
N#define rd_key_lin4()	read0(key_lin4)
N
N/* Configura colunas do teclado */
N#define dir_key_col1()	LPC_GPIO1->FIODIR |= (1ul<<key_col1) 
N#define dir_key_col2()	output1(key_col2)
N
N#define key_col1_high()	LPC_GPIO1->FIOSET |= (1ul<<key_col1)
N#define key_col2_high()	set1(key_col2)
N
N
N#define key_col_all_high()	key_col1_high();	\
N							key_col2_high()	
X#define key_col_all_high()	key_col1_high();								key_col2_high()	
N						
N
N#define key_col1_low()	LPC_GPIO1->FIOCLR |= (1ul<<key_col1)
N#define key_col2_low()	clr1(key_col2)
N
N#define key_col_all_low()	key_col1_low();	\
N							key_col2_low()	
X#define key_col_all_low()	key_col1_low();								key_col2_low()	
N						
N/*********Definioes para o ar condicionado*********/
N
N#define TEMPERATURA_MIN			16
N#define TEMPERATURA_MAX			30
N										 													 
N/*********Definioes de hardware para KIT MINI 1768*********/
N
N#define PIN_KEY1_BOARD		11	/* P2.11 */
N#define PIN_KEY2_BOARD		12	/* P2.12 */
N#define PIN_LED1_BOARD		25	/* P3.25 */
N#define PIN_LED2_BOARD		26	/* P3.26 */
N#define PIN_LED3_BOARD		18	/* P1.18 */
N
N#define LED1_BOARD_TOG()  	if(!read3(PIN_LED1_BOARD))set3(PIN_LED1_BOARD); else clr3(PIN_LED1_BOARD);
N#define LED2_BOARD_TOG()  	if(!read3(PIN_LED2_BOARD))set3(PIN_LED2_BOARD); else clr3(PIN_LED2_BOARD);
N#define LED3_BOARD_TOG()  	if(!read1(PIN_LED3_BOARD))set1(PIN_LED3_BOARD); else clr1(PIN_LED3_BOARD);
N#define LED1_BOARD(x) 		if(!x)set3(PIN_LED1_BOARD); else clr3(PIN_LED1_BOARD);
N#define LED2_BOARD(x) 		if(!x)set3(PIN_LED2_BOARD); else clr3(PIN_LED2_BOARD);
N#define LED3_BOARD(x) 		if(!x)set1(PIN_LED3_BOARD); else clr1(PIN_LED3_BOARD);
N
N#define READ_KEY1_BOARD()	(read2(PIN_KEY1_BOARD))
N#define READ_KEY2_BOARD()	(read2(PIN_KEY2_BOARD))
N
N#define dir_key1_board()	input2(PIN_KEY1_BOARD)
N#define dir_key2_board()	input2(PIN_KEY2_BOARD)
N
N#define dir_led1_board()	output3(PIN_LED1_BOARD)
N#define dir_led2_board()	output3(PIN_LED2_BOARD)
N#define dir_led3_board()	output1(PIN_LED3_BOARD)
N
N#define dir_board()			dir_key1_board(); \
N							dir_key2_board(); \
N							dir_led1_board(); \
N							dir_led2_board(); \
N							dir_led3_board(); \
N							set3(PIN_LED1_BOARD); \
N							set3(PIN_LED2_BOARD); \
N							set1(PIN_LED3_BOARD);		
X#define dir_board()			dir_key1_board(); 							dir_key2_board(); 							dir_led1_board(); 							dir_led2_board(); 							dir_led3_board(); 							set3(PIN_LED1_BOARD); 							set3(PIN_LED2_BOARD); 							set1(PIN_LED3_BOARD);		
N
N
N/*********Definioes de hardware GERAL*********/
N
N/*PINOS*/
N
N#define PIN_LED_ATEND		27	/* P0.27 */
N#define PIN_LED_LOGO		28	/* P0.28 */
N
N
N#define PIN_BUZZER			16  /* P0.16 */
N
N#define PIN_LED_PWR			PIN_LED1_BOARD
N
N#define READ_KEY_ATEND()	READ_KEY1_BOARD()
N	
N#define LED_PWR_TOG()  		LED1_BOARD_TOG(); 
N
N#define LED_ATEND(x) 		if(x)set0(PIN_LED_ATEND); else clr0(PIN_LED_ATEND);
N#define LED_ATEND_TOG()  	if(!read0(PIN_LED_ATEND))set0(PIN_LED_ATEND); else clr0(PIN_LED_ATEND);
N
N#define LED_LOGO(x) 		if(x)set0(PIN_LED_LOGO); else clr0(PIN_LED_LOGO);
N#define LED_LOGO_TOG()  	if(!read0(PIN_LED_LOGO))set0(PIN_LED_LOGO); else clr0(PIN_LED_LOGO);
N													
N#define BUZZER(x)			if(x)set0(PIN_BUZZER); else clr0(PIN_BUZZER);
N#define BUZZER_TOG()		if(!read0(PIN_BUZZER))set0(PIN_BUZZER); else clr0(PIN_BUZZER);
N
N#define dir_buzzer()		output0(PIN_BUZZER); BUZZER(0) 
N
N#define dir_led_logo()		output0(PIN_LED_LOGO)
N#define dir_led_aten()		output0(PIN_LED_ATEND)
N
N#define dir_leds()		    dir_led_logo(); \
N							dir_led_aten();	\
N							LED_ATEND(0);	\
N							LED_LOGO(0);	 
X#define dir_leds()		    dir_led_logo(); 							dir_led_aten();								LED_ATEND(0);								LED_LOGO(0);	 
N					
N
N
N/**********************************************************/
N
N#define init_gpio()		 	dir_board(); \
N							dir_buzzer(); \
N							dir_leds(); \
N							dir_funcao_ir(); \
N							dir_reg(); 	
X#define init_gpio()		 	dir_board(); 							dir_buzzer(); 							dir_leds(); 							dir_funcao_ir(); 							dir_reg(); 	
N				  	
N
N#define wdt_feed()			LPC_WDT->WDFEED = 0xAA;	LPC_WDT->WDFEED = 0x55;
N
N#endif
L 17 "src\tcpip\EMAC_LPC17xx.c" 2
N
N
Ntypedef void (*IAP)(U32 *cmd, U32 *res);
NIAP iap_entry = (IAP)0x1FFF1FF1;
N
N/* The following macro definitions may be used to select the speed
N   of the physical link:
N
N  _10MBIT_   - connect at 10 MBit only
N  _100MBIT_  - connect at 100 MBit only
N
N  By default an autonegotiation of the link speed is used. This may take 
N  longer to connect, but it works for 10MBit and 100MBit physical links.     */
N
N/* Net_Config.c */
Nextern U8 own_hw_adr[];
N
N/* Local variables */
Nstatic BIT dev_175x;
N
N/* EMAC local DMA Descriptors. */
Nstatic            RX_Desc Rx_Desc[NUM_RX_FRAG];
Xstatic            RX_Desc Rx_Desc[4];
Nstatic __align(8) RX_Stat Rx_Stat[NUM_RX_FRAG]; /* Must be 8-Byte alligned   */
Xstatic __align(8) RX_Stat Rx_Stat[4];  
Nstatic            TX_Desc Tx_Desc[NUM_TX_FRAG];
Xstatic            TX_Desc Tx_Desc[3];
Nstatic            TX_Stat Tx_Stat[NUM_TX_FRAG];
Xstatic            TX_Stat Tx_Stat[3];
N
N/* EMAC local DMA buffers. */
Nstatic U32 rx_buf[NUM_RX_FRAG][ETH_FRAG_SIZE>>2];
Xstatic U32 rx_buf[4][1536>>2];
Nstatic U32 tx_buf[NUM_TX_FRAG][ETH_FRAG_SIZE>>2];
Xstatic U32 tx_buf[3][1536>>2];
N
N/*----------------------------------------------------------------------------
N *      EMAC Ethernet Driver Functions
N *----------------------------------------------------------------------------
N *  Required functions for Ethernet driver module:
N *  a. Polling mode: - void init_ethernet ()
N *                   - void send_frame (OS_FRAME *frame)
N *                   - void poll_ethernet (void)
N *  b. Interrupt mode: - void init_ethernet ()
N *                     - void send_frame (OS_FRAME *frame)
N *                     - void int_enable_eth ()
N *                     - void int_disable_eth ()
N *                     - interrupt function 
N *---------------------------------------------------------------------------*/
N
N/* Local Function Prototypes */
Nstatic void rx_descr_init (void);
Nstatic void tx_descr_init (void);
Nstatic void write_PHY (U32 PhyReg, U16 Value);
Nstatic U16  read_PHY (U32 PhyReg);
N
N
N#define delay()     __nop(); __nop(); __nop();
N
N
N//
N//void init_ethernet (void) {
N//  /* Initialize the EMAC ethernet controller. */
N//  U32 regv,tout,id1=id1 = 0,id2=id2 = 0;
N//  U32 pb[2];
N//
N//  //printf("passo0\r\r");
N//  //fflush(stdout);
N//
N//  dev_175x = __FALSE;
N//  /* Read device ID with IAP*/
N//  pb[0] = 54;
N//  iap_entry (&pb[0], &pb[0]);
N//  if ((pb[1] >> 24) == 0x25) {
N//    /* Use software RMII management routines. */
N////    dev_175x = __TRUE;
N//  }
N//
N//    //printf("passo1\r\r");
N//  //fflush(stdout);
N//
N//  /* Power Up the EMAC controller. */
N//  LPC_SC->PCONP |= 0x40000000;
N//
N//  /* Enable P1 Ethernet Pins. */
N//  LPC_PINCON->PINSEL2 = 0x50150105;
N//  if (dev_175x == __FALSE) {
N//    /* LPC176x devices, no MDIO, MDC remap. */
N//    LPC_PINCON->PINSEL3 = (LPC_PINCON->PINSEL3 & ~0x0000000F) | 0x00000005;
N//  }
N//  else {
N//    /* LPC175x devices, use software MII management. */  
N//    LPC_PINCON->PINSEL4 &= ~0x000F0000;
N//    LPC_GPIO2->FIODIR |= MDC;
N//  }
N//
N//    //printf("passo2\r\r");
N//  //fflush(stdout);
N//
N//  /* Reset all EMAC internal modules. */
N//  LPC_EMAC->MAC1    = MAC1_RES_TX | MAC1_RES_MCS_TX | MAC1_RES_RX | 
N//                      MAC1_RES_MCS_RX | MAC1_SIM_RES | MAC1_SOFT_RES;
N//  LPC_EMAC->Command = CR_REG_RES | CR_TX_RES | CR_RX_RES | CR_PASS_RUNT_FRM;
N//
N//  /* A short delay after reset. */
N//  for (tout = 100; tout; tout--);
N//
N//  /* Initialize MAC control registers. */
N//  LPC_EMAC->MAC1 = MAC1_PASS_ALL;
N//  LPC_EMAC->MAC2 = MAC2_CRC_EN | MAC2_PAD_EN;
N//  LPC_EMAC->MAXF = ETH_MAX_FLEN;
N//	
N//	LPC_EMAC->MCFG = 0x8020;
N//	LPC_EMAC->MCFG &= ~(MCFG_RES_MII);
N//	
N//  LPC_EMAC->CLRT = CLRT_DEF;
N//  LPC_EMAC->IPGR = IPGR_DEF;
N//
N//  //printf("passo3\r\r");
N//  //fflush(stdout);
N//
N//  /* Enable Reduced MII interface. */
N//  LPC_EMAC->Command = CR_RMII | CR_PASS_RUNT_FRM;
N//
N//  /* Reset Reduced MII Logic. */
N//  LPC_EMAC->SUPP = SUPP_RES_RMII;
N//  for (tout = 100; tout; tout--);
N//  LPC_EMAC->SUPP = 0;
N//
N//  /* Put the DP83848C in reset mode */
N//  write_PHY (PHY_REG_BMCR, 0x8000);
N//
N//  printf("[Hardware ethernet...Wait]\r");
N//  fflush(stdout);
N//
N//  /* Wait for hardware reset to end. */
N//  for (tout = 0; tout < 0x100000; tout++) 
N//  {
N//    regv = read_PHY (PHY_REG_BMCR);
N//    if (!(regv & 0x8800)) 
N//	{
N//      /* Reset complete, device not Power Down. */
N//      break;
N//    }
N//	wdt_feed();
N//	LED_PWR_TOG();
N//	if(!(tout % 5000))
N//	{
N//		printf("[%X...reg:%X]\r\r",tout,regv);
N//  		fflush(stdout);
N//	}
N//  }
N//
N//  printf("[Hardware ethernet...OK...%X...%X]\r\r",tout,regv);
N//  fflush(stdout);
N//
N//  /* Check if this is a DP83848C PHY. */
N//  //id1 = read_PHY (PHY_REG_IDR1);	//teste de leitura do mac
N//  //id2 = read_PHY (PHY_REG_IDR2);	//teste deleitura do mac
N//
N//  //printf("id1:%X...id2:%X\r\r",id1,id2);
N//  //fflush(stdout);
N//
N//  //printf("passo5\r\r");
N//  //fflush(stdout);
N//
N//  if (1/*((id1 << 16) | (id2 & 0xFFF0)) == DP83848C_ID*/) {
N//    /* Configure the PHY device */
N//#if defined (_10MBIT_)
N//    /* Connect at 10MBit */
N//    write_PHY (PHY_REG_BMCR, PHY_FULLD_10M);
N//#elif defined (_100MBIT_)
N//    /* Connect at 100MBit */
N//    write_PHY (PHY_REG_BMCR, PHY_FULLD_100M);
N//#else
N//    /* Use autonegotiation about the link speed. */
N//    write_PHY (PHY_REG_BMCR, 0x1000/*PHY_AUTO_NEG*/);
N//    /* Wait to complete Auto_Negotiation. */
N//    for (tout = /*0x100000*/0x10000; tout; tout--) {
N//      regv = read_PHY (PHY_REG_BMSR);
N//      if (regv & 0x0020) 
N//	  {
N//	  		//printf("Autonegotiation Complete\r");
N//			//fflush(stdout);
N//        /* Autonegotiation Complete. */
N//        break;
N//      }
N//    }
N//		
N//		if (tout == 0){
N//			// Time out, return error
N//		}
N//#endif
N//  }
N//
N//  /* Configure Full/Half Duplex mode. */
N//  if (regv & 0x0004) {
N//    /* Full duplex is enabled. */
N//    LPC_EMAC->MAC2    |= MAC2_FULL_DUP;
N//    LPC_EMAC->Command |= CR_FULL_DUP;
N//    LPC_EMAC->IPGT     = IPGT_FULL_DUP;
N//  }
N//  else {
N//    /* Half duplex mode. */
N//    LPC_EMAC->IPGT = IPGT_HALF_DUP;
N//  }
N//
N//  /* Configure 100MBit/10MBit mode. */
N//  if (regv & 0x0002) {
N//    /* 10MBit mode. */
N//    LPC_EMAC->SUPP = 0;
N//  }
N//  else {
N//    /* 100MBit mode. */
N//    LPC_EMAC->SUPP = SUPP_SPEED;
N//  }
N//	
N//	 /* Check the link status. */
N////   for (tout = 0; tout < 0x10000; tout++) {
N////     regv = read_PHY (PHY_REG_STS);
N////     if (regv & 0x0001) {
N////       /* Link is on. */
N////       break;
N////     }
N////   }
N//	for (tout = 0; tout < 0x10000; tout++) 
N//	{
N//    	regv = read_PHY (PHY_REG_BMSR);
N//    	if (regv & (1<<2)) 
N//		{
N//      		/* Link is on. */
N//			//printf("Link is on 2\r");
N//			//fflush(stdout);
N//      		break;
N//    	}
N//	}
N//
N//  //printf("Antes...SA0:%X...SA1:%X...SA2:%X\r\r",LPC_EMAC->SA0,LPC_EMAC->SA1,LPC_EMAC->SA2);
N//  //fflush(stdout);
N//
N//  /* Set the Ethernet MAC Address registers */
N//  LPC_EMAC->SA0 = ((U32)own_hw_adr[5] << 8) | (U32)own_hw_adr[4];
N//  LPC_EMAC->SA1 = ((U32)own_hw_adr[3] << 8) | (U32)own_hw_adr[2];
N//  LPC_EMAC->SA2 = ((U32)own_hw_adr[1] << 8) | (U32)own_hw_adr[0];
N//
N//  //printf("Depois...SA0:%X...SA1:%X...SA2:%X\r\r",LPC_EMAC->SA0,LPC_EMAC->SA1,LPC_EMAC->SA2);
N//  //fflush(stdout);
N//
N//  /* Initialize Tx and Rx DMA Descriptors */
N//  rx_descr_init ();
N//  tx_descr_init ();
N//
N//  /* Receive Broadcast, Multicast and Perfect Match Packets */
N//  LPC_EMAC->RxFilterCtrl = RFC_MCAST_EN | RFC_BCAST_EN | RFC_PERFECT_EN;
N//
N//  /* Enable EMAC interrupts. */
N//  LPC_EMAC->IntEnable = INT_RX_DONE | INT_TX_DONE;
N//
N//  /* Reset all interrupts */
N//  LPC_EMAC->IntClear  = 0xFFFF;
N//
N//  /* Enable receive and transmit mode of MAC Ethernet core */
N//  LPC_EMAC->Command  |= (CR_RX_EN | CR_TX_EN);
N//  LPC_EMAC->MAC1     |= MAC1_REC_EN;
N//
N//}
N//
N
N/*--------------------------- init_ethernet ---------------------------------*/
N
Nvoid init_ethernet (void) {
N  /* Initialize the EMAC ethernet controller. */
N  U32 regv,tout,id1=id1 = 0,id2=id2 = 0;
N  U32 pb[2];
N
N  //printf("passo0\r\r");
N  //fflush(stdout);
N
N  dev_175x = __FALSE;
X  dev_175x = 0;
N  /* Read device ID with IAP*/
N  pb[0] = 54;
N  iap_entry (&pb[0], &pb[0]);
N  if ((pb[1] >> 24) == 0x25) {
N    /* Use software RMII management routines. */
N//    dev_175x = __TRUE;
N  }
N
N  //printf("passo1\r\r");
N  //fflush(stdout);
N
N  /* Power Up the EMAC controller. */
N  LPC_SC->PCONP |= 0x40000000;
X  ((LPC_SC_TypeDef *) ((0x40080000UL) + 0x7C000) )->PCONP |= 0x40000000;
N
N  /* Enable P1 Ethernet Pins. */
N  LPC_PINCON->PINSEL2 = 0x50150105;
X  ((LPC_PINCON_TypeDef *) ((0x40000000UL) + 0x2C000) )->PINSEL2 = 0x50150105;
N  if (dev_175x == __FALSE) {
X  if (dev_175x == 0) {
N    /* LPC176x devices, no MDIO, MDC remap. */
N    LPC_PINCON->PINSEL3 = (LPC_PINCON->PINSEL3 & ~0x0000000F) | 0x00000005;
X    ((LPC_PINCON_TypeDef *) ((0x40000000UL) + 0x2C000) )->PINSEL3 = (((LPC_PINCON_TypeDef *) ((0x40000000UL) + 0x2C000) )->PINSEL3 & ~0x0000000F) | 0x00000005;
N  }
N  else {
N    /* LPC175x devices, use software MII management. */  
N    LPC_PINCON->PINSEL4 &= ~0x000F0000;
X    ((LPC_PINCON_TypeDef *) ((0x40000000UL) + 0x2C000) )->PINSEL4 &= ~0x000F0000;
N    LPC_GPIO2->FIODIR |= MDC;
X    ((LPC_GPIO_TypeDef *) ((0x2009C000UL) + 0x00040) )->FIODIR |= 0x00000100;
N  }
N
N    //printf("passo2\r\r");
N  //fflush(stdout);
N
N  /* Reset all EMAC internal modules. */
N  LPC_EMAC->MAC1    = MAC1_RES_TX | MAC1_RES_MCS_TX | MAC1_RES_RX | 
X  ((LPC_EMAC_TypeDef *) ((0x50000000UL) + 0x00000) )->MAC1    = 0x00000100 | 0x00000200 | 0x00000400 | 
N                      MAC1_RES_MCS_RX | MAC1_SIM_RES | MAC1_SOFT_RES;
X                      0x00000800 | 0x00004000 | 0x00008000;
N  LPC_EMAC->Command = CR_REG_RES | CR_TX_RES | CR_RX_RES | CR_PASS_RUNT_FRM;
X  ((LPC_EMAC_TypeDef *) ((0x50000000UL) + 0x00000) )->Command = 0x00000008 | 0x00000010 | 0x00000020 | 0x00000040;
N
N  /* A short delay after reset. */
N  for (tout = 100; tout; tout--);
N
N  /* Initialize MAC control registers. */
N  LPC_EMAC->MAC1 = MAC1_PASS_ALL;
X  ((LPC_EMAC_TypeDef *) ((0x50000000UL) + 0x00000) )->MAC1 = 0x00000002;
N  LPC_EMAC->MAC2 = MAC2_CRC_EN | MAC2_PAD_EN;
X  ((LPC_EMAC_TypeDef *) ((0x50000000UL) + 0x00000) )->MAC2 = 0x00000010 | 0x00000020;
N  LPC_EMAC->MAXF = ETH_MAX_FLEN;
X  ((LPC_EMAC_TypeDef *) ((0x50000000UL) + 0x00000) )->MAXF = 1536;
N	
N  LPC_EMAC->MCFG = 0x8020;
X  ((LPC_EMAC_TypeDef *) ((0x50000000UL) + 0x00000) )->MCFG = 0x8020;
N  LPC_EMAC->MCFG &= ~(MCFG_RES_MII);
X  ((LPC_EMAC_TypeDef *) ((0x50000000UL) + 0x00000) )->MCFG &= ~(0x00008000);
N	
N  LPC_EMAC->CLRT = CLRT_DEF;
X  ((LPC_EMAC_TypeDef *) ((0x50000000UL) + 0x00000) )->CLRT = 0x0000370F;
N  LPC_EMAC->IPGR = IPGR_DEF;
X  ((LPC_EMAC_TypeDef *) ((0x50000000UL) + 0x00000) )->IPGR = 0x00000012;
N
N  //printf("passo3\r\r");
N  //fflush(stdout);
N
N  /* Enable Reduced MII interface. */
N  LPC_EMAC->Command = CR_RMII | CR_PASS_RUNT_FRM;
X  ((LPC_EMAC_TypeDef *) ((0x50000000UL) + 0x00000) )->Command = 0x00000200 | 0x00000040;
N
N  /* Reset Reduced MII Logic. */
N  LPC_EMAC->SUPP = SUPP_RES_RMII;
X  ((LPC_EMAC_TypeDef *) ((0x50000000UL) + 0x00000) )->SUPP = 0x00000800;
N  for (tout = 100; tout; tout--);
N  LPC_EMAC->SUPP = 0;
X  ((LPC_EMAC_TypeDef *) ((0x50000000UL) + 0x00000) )->SUPP = 0;
N
N  /* Put the DP83848C in reset mode */
N  write_PHY (PHY_REG_BMCR, 0x8000);
X  write_PHY (0x00, 0x8000);
N  delay ();
X  __nop(); __nop(); __nop();;
N  delay ();
X  __nop(); __nop(); __nop();;
N  delay ();
X  __nop(); __nop(); __nop();;
N
N  printf("[Ethernet Hardware Reset...Wait]\r");
N  fflush(stdout);
X  fflush((& __stdout));
N
N  /* Wait for hardware reset to end. */
N  for (tout = 0; tout < 0x100000; tout++) 
N  {
N    regv = read_PHY (PHY_REG_BMCR);
X    regv = read_PHY (0x00);
N    if (!(regv & 0x8000)) 
N	{
N      /* Reset complete, device not Power Down. */
N      break;
N    }
N
N//	wdt_feed();
N//	LED_PWR_TOG();
N//	if(!(tout % 5000))
N//	{
N//		printf("[%X...reg:%X]\r\r",tout,regv);
N//  		fflush(stdout);
N//	}
N
N  }
N
N  printf("[Ethernet Hardware...OK]\r");
N  fflush(stdout);
X  fflush((& __stdout));
N
N  /* Check if this is a DP83848C PHY. */
N//  id1 = read_PHY (PHY_REG_IDR1);	//teste de leitura do mac
N//  id2 = read_PHY (PHY_REG_IDR2);	//teste deleitura do mac
N
N  //printf("id1:%X...id2:%X\r\r",id1,id2);
N  //fflush(stdout);
N
N  delay ();
X  __nop(); __nop(); __nop();;
N  delay ();
X  __nop(); __nop(); __nop();;
N  delay ();
X  __nop(); __nop(); __nop();;
N  //printf("passo5\r\r");
N  //fflush(stdout);
N
N  if (1/*((id1 << 16) | (id2 & 0xFFF0)) == DP83848C_ID*/) {
N    /* Configure the PHY device */
N#if defined (_10MBIT_)
X#if 0L
S    /* Connect at 10MBit */
S    write_PHY (PHY_REG_BMCR, PHY_FULLD_10M);
S#elif defined (_100MBIT_)
X#elif 0L
S    /* Connect at 100MBit */
S    write_PHY (PHY_REG_BMCR, PHY_FULLD_100M);
N#else
N    /* Use autonegotiation about the link speed. */
N    write_PHY (PHY_REG_BMCR, 0x1000 /*PHY_AUTO_NEG*/);
X    write_PHY (0x00, 0x1000  );
N    /* Wait to complete Auto_Negotiation. */
N    for (tout = /*0x100000*/  0x10000; tout; tout--) {
N      regv = read_PHY (PHY_REG_BMSR);
X      regv = read_PHY (0x01);
N      if (regv & 0x0020) 
N	  {
N	  		//printf("Autonegotiation Complete\r");
N			//fflush(stdout);
N        /* Autonegotiation Complete. */
N        break;
N      }
N    }
N		
N		if (tout == 0){
N			// Time out, return error
N		}
N#endif
N  }
N
N  delay ();
X  __nop(); __nop(); __nop();;
N  delay ();
X  __nop(); __nop(); __nop();;
N  delay ();
X  __nop(); __nop(); __nop();;
N
N  //   printf("passo6\r\r");
N  //fflush(stdout);
N
N  /* Configure Full/Half Duplex mode. */
N  if (regv & 0x0004) {
N    /* Full duplex is enabled. */
N    LPC_EMAC->MAC2    |= MAC2_FULL_DUP;
X    ((LPC_EMAC_TypeDef *) ((0x50000000UL) + 0x00000) )->MAC2    |= 0x00000001;
N    LPC_EMAC->Command |= CR_FULL_DUP;
X    ((LPC_EMAC_TypeDef *) ((0x50000000UL) + 0x00000) )->Command |= 0x00000400;
N    LPC_EMAC->IPGT     = IPGT_FULL_DUP;
X    ((LPC_EMAC_TypeDef *) ((0x50000000UL) + 0x00000) )->IPGT     = 0x00000015;
N	printf("[Ethernet Full Duplex]\r");
N  }
N  else {
N    /* Half duplex mode. */
N    LPC_EMAC->IPGT = IPGT_HALF_DUP;
X    ((LPC_EMAC_TypeDef *) ((0x50000000UL) + 0x00000) )->IPGT = 0x00000012;
N	printf("[Ethernet Half Duplex]\r");  	
N  }
N
N  fflush(stdout);
X  fflush((& __stdout));
N  delay ();
X  __nop(); __nop(); __nop();;
N  delay ();
X  __nop(); __nop(); __nop();;
N  delay ();
X  __nop(); __nop(); __nop();;
N  //printf("passo7\r\r");
N  //fflush(stdout);
N
N  /* Configure 100MBit/10MBit mode. */
N  if (regv & 0x0002) {
N    /* 10MBit mode. */
N    LPC_EMAC->SUPP = 0;
X    ((LPC_EMAC_TypeDef *) ((0x50000000UL) + 0x00000) )->SUPP = 0;
N	printf("[Ethernet 10Mbit mode]\r\r");
N  }
N  else {
N    /* 100MBit mode. */
N    LPC_EMAC->SUPP = SUPP_SPEED;
X    ((LPC_EMAC_TypeDef *) ((0x50000000UL) + 0x00000) )->SUPP = 0x00000100;
N	printf("[Ethernet 100Mbit mode]\r\r"); 	
N  }
N	fflush(stdout);	
X	fflush((& __stdout));	
N	
N	 /* Check the link status. */
N////   for (tout = 0; tout < 0x10000; tout++) {
N////     regv = read_PHY (PHY_REG_STS);
N////     if (regv & 0x0001) {
N////       /* Link is on. */
N////       break;
N////     }
N////   }
N
N
N//	for (tout = 0; tout < 0x10000; tout++) 
N//	{
N//    	regv = read_PHY (PHY_REG_BMSR);
N//    	if (regv & (1<<2)) 
N//		{
N//      		/* Link is on. */
N//			//printf("Link is on 2\r");
N//			//fflush(stdout);
N//      		break;
N//    	}
N//	}
N
N
N  //printf("Antes...SA0:%X...SA1:%X...SA2:%X\r\r",LPC_EMAC->SA0,LPC_EMAC->SA1,LPC_EMAC->SA2);
N  //fflush(stdout);
N
N  /* Set the Ethernet MAC Address registers */
N  LPC_EMAC->SA0 = ((U32)own_hw_adr[5] << 8) | (U32)own_hw_adr[4];
X  ((LPC_EMAC_TypeDef *) ((0x50000000UL) + 0x00000) )->SA0 = ((U32)own_hw_adr[5] << 8) | (U32)own_hw_adr[4];
N  LPC_EMAC->SA1 = ((U32)own_hw_adr[3] << 8) | (U32)own_hw_adr[2];
X  ((LPC_EMAC_TypeDef *) ((0x50000000UL) + 0x00000) )->SA1 = ((U32)own_hw_adr[3] << 8) | (U32)own_hw_adr[2];
N  LPC_EMAC->SA2 = ((U32)own_hw_adr[1] << 8) | (U32)own_hw_adr[0];
X  ((LPC_EMAC_TypeDef *) ((0x50000000UL) + 0x00000) )->SA2 = ((U32)own_hw_adr[1] << 8) | (U32)own_hw_adr[0];
N
N  //printf("Depois...SA0:%X...SA1:%X...SA2:%X\r\r",LPC_EMAC->SA0,LPC_EMAC->SA1,LPC_EMAC->SA2);
N  //fflush(stdout);
N
N  /* Initialize Tx and Rx DMA Descriptors */
N  rx_descr_init ();
N  tx_descr_init ();
N
N  /* Receive Broadcast, Multicast and Perfect Match Packets */
N  LPC_EMAC->RxFilterCtrl = RFC_MCAST_EN | RFC_BCAST_EN | RFC_PERFECT_EN;
X  ((LPC_EMAC_TypeDef *) ((0x50000000UL) + 0x00000) )->RxFilterCtrl = 0x00000004 | 0x00000002 | 0x00000020;
N
N  /* Enable EMAC interrupts. */
N  LPC_EMAC->IntEnable = INT_RX_DONE | INT_TX_DONE;
X  ((LPC_EMAC_TypeDef *) ((0x50000000UL) + 0x00000) )->IntEnable = 0x00000008 | 0x00000080;
N
N  /* Reset all interrupts */
N  LPC_EMAC->IntClear  = 0xFFFF;
X  ((LPC_EMAC_TypeDef *) ((0x50000000UL) + 0x00000) )->IntClear  = 0xFFFF;
N
N  /* Enable receive and transmit mode of MAC Ethernet core */
N  LPC_EMAC->Command  |= (CR_RX_EN | CR_TX_EN);
X  ((LPC_EMAC_TypeDef *) ((0x50000000UL) + 0x00000) )->Command  |= (0x00000001 | 0x00000002);
N  LPC_EMAC->MAC1     |= MAC1_REC_EN;
X  ((LPC_EMAC_TypeDef *) ((0x50000000UL) + 0x00000) )->MAC1     |= 0x00000001;
N
N}
N
N
N
N//void init_ethernet (void) {
N//// Keil: function modified to access the EMAC
N//// Initializes the EMAC ethernet controller
N//  unsigned int regv,tout,id1,id2;
N//
N//   U32 pb[2];
N//
N//   dev_175x = __FALSE;
N//   /* Read device ID with IAP*/
N//   pb[0] = 54;
N//   iap_entry (&pb[0], &pb[0]);
N//   if ((pb[1] >> 24) == 0x25) {
N//      /* Use software RMII management routines. */
N//      dev_175x = __TRUE;
N//   }
N//
N//
N//   /* Power Up the EMAC controller. */
N//   LPC_SC->PCONP |= 0x40000000;
N//
N//   /* Enable P1 Ethernet Pins. */
N//   LPC_PINCON->PINSEL2 = 0x50150105;
N//   if (dev_175x == __FALSE) {
N//      /* LPC176x devices, no MDIO, MDC remap. */
N//      LPC_PINCON->PINSEL3 = (LPC_PINCON->PINSEL3 & ~0x0000000F) | 0x00000005;
N//   }
N//   else {
N//      /* LPC175x devices, use software MII management. */  
N//      LPC_PINCON->PINSEL4 &= ~0x000F0000;
N//      LPC_GPIO2->FIODIR |= MDC;
N//   }
N//
N//  /* Reset all EMAC internal modules. */
N//  LPC_EMAC->MAC1 = MAC1_RES_TX | MAC1_RES_MCS_TX | MAC1_RES_RX | MAC1_RES_MCS_RX | MAC1_SIM_RES | MAC1_SOFT_RES;
N// // MAC_COMMAND = CR_REG_RES | CR_TX_RES | CR_RX_RES;
N// LPC_EMAC->Command = CR_REG_RES | CR_TX_RES | CR_RX_RES | CR_PASS_RUNT_FRM;
N//  
N//  /* A short delay after reset. */
N//  for (tout = 100; tout; tout--);
N//
N//  /* Initialize MAC control registers. */
N//  LPC_EMAC->MAC1 = MAC1_PASS_ALL;
N//  LPC_EMAC->MAC2 = MAC2_CRC_EN | MAC2_PAD_EN;
N// //  MAC2 = MAC2_CRC_EN | MAC2_PAD_EN | MAC2_VLAN_PAD_EN;
N//
N//  LPC_EMAC->MAXF = ETH_MAX_FLEN;
N//  LPC_EMAC->CLRT = CLRT_DEF;
N//  LPC_EMAC->IPGR = IPGR_DEF;
N//
N//  /* Enable Reduced MII interface. */
N//  LPC_EMAC->Command = CR_RMII | CR_PASS_RUNT_FRM;
N//
N//
N//  /* Put the DP83848C in reset mode */
N//  write_PHY (PHY_REG_BMCR, 0x8000);
N//
N//  /* Wait for hardware reset to end. */
N//  for (tout = 0; tout < 0x100000; tout++) {
N//    regv = read_PHY (PHY_REG_BMCR);
N//    if (!(regv & 0x8000)) {
N//      /* Reset complete */
N//      break;
N//    }
N//  }
N//
N//  /* Check if this is a DP83848C PHY. */
N//  id1 = read_PHY (PHY_REG_IDR1);
N//  id2 = read_PHY (PHY_REG_IDR2);
N//  if (1 /*((id1 << 16) | (id2 & 0xFFF0)) == DP83848C_ID*/) {
N//    /* Configure the PHY device */
N//
N//    /* Use autonegotiation about the link speed. */
N//    write_PHY (PHY_REG_BMCR, PHY_AUTO_NEG);
N//    /* Wait to complete Auto_Negotiation. */
N//    for (tout = 0; tout < 0x100000; tout++) {
N//      regv = read_PHY (PHY_REG_BMSR);
N//      if (regv & 0x0020) {
N//        /* Autonegotiation Complete. */
N//        break;
N//      }
N//    }
N//  }
N//
N//  /* Check the link status. */
N//  for (tout = 0; tout < 0x10000; tout++) {
N//    regv = read_PHY (PHY_REG_STS);
N//    if (regv & 0x0001) {
N//      /* Link is on. */
N//      break;
N//    }
N//  }
N//
N//  /* Configure Full/Half Duplex mode. */
N//  if (regv & 0x0004) {
N//    /* Full duplex is enabled. */
N//    LPC_EMAC->MAC2    |= MAC2_FULL_DUP;
N//    LPC_EMAC->Command |= CR_FULL_DUP;
N//    LPC_EMAC->IPGT     = IPGT_FULL_DUP;
N//  }
N//  else {
N//    /* Half duplex mode. */
N//    LPC_EMAC->IPGT = IPGT_HALF_DUP;
N//  }
N//
N//  /* Configure 100MBit/10MBit mode. */
N//  if (regv & 0x0002) {
N//    /* 10MBit mode. */
N//    LPC_EMAC->SUPP = 0;
N//  }
N//  else {
N//    /* 100MBit mode. */
N//    LPC_EMAC->SUPP = SUPP_SPEED;
N//  }
N//
N//  /* Set the Ethernet MAC Address registers */
N//  LPC_EMAC->SA0 = ((U32)own_hw_adr[5] << 8) | (U32)own_hw_adr[4];
N//  LPC_EMAC->SA1 = ((U32)own_hw_adr[3] << 8) | (U32)own_hw_adr[2];
N//  LPC_EMAC->SA2 = ((U32)own_hw_adr[1] << 8) | (U32)own_hw_adr[0];
N//
N//  /* Initialize Tx and Rx DMA Descriptors */
N//  rx_descr_init ();
N//  tx_descr_init ();
N//
N//  /* Receive Broadcast and Perfect Match Packets */
N//  LPC_EMAC->RxFilterCtrl = RFC_BCAST_EN | RFC_PERFECT_EN;					 
N//
N//  /* Enable EMAC interrupts. */
N//  LPC_EMAC->IntEnable = INT_RX_DONE | INT_TX_DONE;
N//
N//  /* Reset all interrupts */
N//  LPC_EMAC->IntClear  = 0xFFFF;
N//
N//  /* Enable receive and transmit mode of MAC Ethernet core */
N//  LPC_EMAC->Command  |= (CR_RX_EN | CR_TX_EN);
N//  LPC_EMAC->MAC1     |= MAC1_REC_EN;
N//}
N
N
N
N/*--------------------------- int_enable_eth --------------------------------*/
N
Nvoid int_enable_eth (void) {
N  /* Ethernet Interrupt Enable function. */
N  NVIC_EnableIRQ(ENET_IRQn);
N}
N
N
N/*--------------------------- int_disable_eth -------------------------------*/
N
Nvoid int_disable_eth (void) {
N  /* Ethernet Interrupt Disable function. */
N  NVIC_DisableIRQ(ENET_IRQn);
N}
N
N
N/*--------------------------- send_frame ------------------------------------*/
N
Nvoid send_frame (OS_FRAME *frame) {
N  /* Send frame to EMAC ethernet controller */
N  U32 idx,len;
N  U32 *sp,*dp;
N
N  idx = LPC_EMAC->TxProduceIndex;
X  idx = ((LPC_EMAC_TypeDef *) ((0x50000000UL) + 0x00000) )->TxProduceIndex;
N  sp  = (U32 *)&frame->data[0];
N  dp  = (U32 *)Tx_Desc[idx].Packet;
N
N  /* Copy frame data to EMAC packet buffers. */
N  for (len = (frame->length + 3) >> 2; len; len--) {
N    *dp++ = *sp++;
N  }
N  Tx_Desc[idx].Ctrl = (frame->length-1) | (TCTRL_INT | TCTRL_LAST);
X  Tx_Desc[idx].Ctrl = (frame->length-1) | (0x80000000 | 0x40000000);
N
N  /* Start frame transmission. */
N  if (++idx == NUM_TX_FRAG) idx = 0;
X  if (++idx == 3) idx = 0;
N  LPC_EMAC->TxProduceIndex = idx;
X  ((LPC_EMAC_TypeDef *) ((0x50000000UL) + 0x00000) )->TxProduceIndex = idx;
N}
N
N
N/*--------------------------- interrupt_ethernet ----------------------------*/
N
Nvoid ENET_IRQHandler (void) {
N  /* EMAC Ethernet Controller Interrupt function. */
N  OS_FRAME *frame;
N  U32 idx,int_stat,RxLen,info;
N  U32 *sp,*dp;
N
N  while ((int_stat = (LPC_EMAC->IntStatus & LPC_EMAC->IntEnable)) != 0) {
X  while ((int_stat = (((LPC_EMAC_TypeDef *) ((0x50000000UL) + 0x00000) )->IntStatus & ((LPC_EMAC_TypeDef *) ((0x50000000UL) + 0x00000) )->IntEnable)) != 0) {
N    LPC_EMAC->IntClear = int_stat;
X    ((LPC_EMAC_TypeDef *) ((0x50000000UL) + 0x00000) )->IntClear = int_stat;
N    if (int_stat & INT_RX_DONE) {
X    if (int_stat & 0x00000008) {
N      /* Packet received, check if packet is valid. */
N      idx = LPC_EMAC->RxConsumeIndex;
X      idx = ((LPC_EMAC_TypeDef *) ((0x50000000UL) + 0x00000) )->RxConsumeIndex;
N      while (idx != LPC_EMAC->RxProduceIndex) {
X      while (idx != ((LPC_EMAC_TypeDef *) ((0x50000000UL) + 0x00000) )->RxProduceIndex) {
N        info = Rx_Stat[idx].Info;
N        if (!(info & RINFO_LAST_FLAG)) {
X        if (!(info & 0x40000000)) {
N          goto rel;
N        }
N
N        RxLen = (info & RINFO_SIZE) - 3;
X        RxLen = (info & 0x000007FF) - 3;
N        if (RxLen > ETH_MTU || (info & RINFO_ERR_MASK)) {
X        if (RxLen > 1514 || (info & (0x00100000 | 0x00800000 | 0x01000000 | 0x02000000 | 0x08000000 | 0x10000000))) {
N          /* Invalid frame, ignore it and free buffer. */
N          goto rel;
N        }
N        /* Flag 0x80000000 to skip sys_error() call when out of memory. */
N        frame = alloc_mem (RxLen | 0x80000000);
N        /* if 'alloc_mem()' has failed, ignore this packet. */
N        if (frame != NULL) {
X        if (frame != 0) {
N          dp = (U32 *)&frame->data[0];
N          sp = (U32 *)Rx_Desc[idx].Packet;
N          for (RxLen = (RxLen + 3) >> 2; RxLen; RxLen--) {
N            *dp++ = *sp++;
N          }
N          put_in_queue (frame);
N        }
Nrel:    if (++idx == NUM_RX_FRAG) idx = 0;
Xrel:    if (++idx == 4) idx = 0;
N        /* Release frame from EMAC buffer. */
N        LPC_EMAC->RxConsumeIndex = idx;
X        ((LPC_EMAC_TypeDef *) ((0x50000000UL) + 0x00000) )->RxConsumeIndex = idx;
N      }
N    }
N    if (int_stat & INT_TX_DONE) {
X    if (int_stat & 0x00000080) {
N      /* Frame transmit completed. */
N    }
N  }
N
N}
N
N
N/*--------------------------- rx_descr_init ---------------------------------*/
N
Nstatic void rx_descr_init (void) {
N  /* Initialize Receive Descriptor and Status array. */
N  U32 i;
N
N  for (i = 0; i < NUM_RX_FRAG; i++) {
X  for (i = 0; i < 4; i++) {
N    Rx_Desc[i].Packet  = (U32)&rx_buf[i];
N    Rx_Desc[i].Ctrl    = RCTRL_INT | (ETH_FRAG_SIZE-1);
X    Rx_Desc[i].Ctrl    = 0x80000000 | (1536-1);
N    Rx_Stat[i].Info    = 0;
N    Rx_Stat[i].HashCRC = 0;
N  }
N
N  /* Set EMAC Receive Descriptor Registers. */
N  LPC_EMAC->RxDescriptor       = (U32)&Rx_Desc[0];
X  ((LPC_EMAC_TypeDef *) ((0x50000000UL) + 0x00000) )->RxDescriptor       = (U32)&Rx_Desc[0];
N  LPC_EMAC->RxStatus           = (U32)&Rx_Stat[0];
X  ((LPC_EMAC_TypeDef *) ((0x50000000UL) + 0x00000) )->RxStatus           = (U32)&Rx_Stat[0];
N  LPC_EMAC->RxDescriptorNumber = NUM_RX_FRAG-1;
X  ((LPC_EMAC_TypeDef *) ((0x50000000UL) + 0x00000) )->RxDescriptorNumber = 4-1;
N
N  /* Rx Descriptors Point to 0 */
N  LPC_EMAC->RxConsumeIndex  = 0;
X  ((LPC_EMAC_TypeDef *) ((0x50000000UL) + 0x00000) )->RxConsumeIndex  = 0;
N}
N
N
N/*--------------------------- tx_descr_init ---- ----------------------------*/
N
Nstatic void tx_descr_init (void) {
N  /* Initialize Transmit Descriptor and Status array. */
N  U32 i;
N
N  for (i = 0; i < NUM_TX_FRAG; i++) {
X  for (i = 0; i < 3; i++) {
N    Tx_Desc[i].Packet = (U32)&tx_buf[i];
N    Tx_Desc[i].Ctrl   = 0;
N    Tx_Stat[i].Info   = 0;
N  }
N
N  /* Set EMAC Transmit Descriptor Registers. */
N  LPC_EMAC->TxDescriptor       = (U32)&Tx_Desc[0];
X  ((LPC_EMAC_TypeDef *) ((0x50000000UL) + 0x00000) )->TxDescriptor       = (U32)&Tx_Desc[0];
N  LPC_EMAC->TxStatus           = (U32)&Tx_Stat[0];
X  ((LPC_EMAC_TypeDef *) ((0x50000000UL) + 0x00000) )->TxStatus           = (U32)&Tx_Stat[0];
N  LPC_EMAC->TxDescriptorNumber = NUM_TX_FRAG-1;
X  ((LPC_EMAC_TypeDef *) ((0x50000000UL) + 0x00000) )->TxDescriptorNumber = 3-1;
N
N  /* Tx Descriptors Point to 0 */
N  LPC_EMAC->TxProduceIndex  = 0;
X  ((LPC_EMAC_TypeDef *) ((0x50000000UL) + 0x00000) )->TxProduceIndex  = 0;
N}
N
N
N/*--------------------------- output_MDIO -----------------------------------*/
N
N//#define delay()     __nop(); __nop(); __nop();
N
Nstatic void output_MDIO (U32 val, U32 n) {
N  /* Output a value to the MII PHY management interface. */
N
N  for (val <<= (32 - n); n; val <<= 1, n--) {
N    if (val & 0x80000000) {
N      LPC_GPIO2->FIOSET = MDIO;
X      ((LPC_GPIO_TypeDef *) ((0x2009C000UL) + 0x00040) )->FIOSET = 0x00000200;
N    }
N    else {
N      LPC_GPIO2->FIOCLR = MDIO;
X      ((LPC_GPIO_TypeDef *) ((0x2009C000UL) + 0x00040) )->FIOCLR = 0x00000200;
N    }
N    delay ();
X    __nop(); __nop(); __nop();;
N    LPC_GPIO2->FIOSET = MDC;
X    ((LPC_GPIO_TypeDef *) ((0x2009C000UL) + 0x00040) )->FIOSET = 0x00000100;
N    delay ();
X    __nop(); __nop(); __nop();;
N    LPC_GPIO2->FIOCLR = MDC;
X    ((LPC_GPIO_TypeDef *) ((0x2009C000UL) + 0x00040) )->FIOCLR = 0x00000100;
N  }
N}
N
N/*--------------------------- turnaround_MDIO -------------------------------*/
N
Nstatic void turnaround_MDIO (void) {
N  /* Turnaround MDO is tristated. */
N
N  LPC_GPIO2->FIODIR &= ~MDIO;
X  ((LPC_GPIO_TypeDef *) ((0x2009C000UL) + 0x00040) )->FIODIR &= ~0x00000200;
N  LPC_GPIO2->FIOSET  = MDC;
X  ((LPC_GPIO_TypeDef *) ((0x2009C000UL) + 0x00040) )->FIOSET  = 0x00000100;
N  delay ();
X  __nop(); __nop(); __nop();;
N  LPC_GPIO2->FIOCLR  = MDC;
X  ((LPC_GPIO_TypeDef *) ((0x2009C000UL) + 0x00040) )->FIOCLR  = 0x00000100;
N  delay ();
X  __nop(); __nop(); __nop();;
N}
N
N/*--------------------------- input_MDIO ------------------------------------*/
N
Nstatic U32 input_MDIO (void) {
N  /* Input a value from the MII PHY management interface. */
N  U32 i,val = 0;
N
N  for (i = 0; i < 16; i++) {
N    val <<= 1;
N    LPC_GPIO2->FIOSET = MDC;
X    ((LPC_GPIO_TypeDef *) ((0x2009C000UL) + 0x00040) )->FIOSET = 0x00000100;
N    delay ();
X    __nop(); __nop(); __nop();;
N    LPC_GPIO2->FIOCLR = MDC;
X    ((LPC_GPIO_TypeDef *) ((0x2009C000UL) + 0x00040) )->FIOCLR = 0x00000100;
N    if (LPC_GPIO2->FIOPIN & MDIO) {
X    if (((LPC_GPIO_TypeDef *) ((0x2009C000UL) + 0x00040) )->FIOPIN & 0x00000200) {
N      val |= 1;
N    }
N  }
N  return (val);
N}
N
N
N/*--------------------------- write_PHY -------------------------------------*/
N
Nstatic void write_PHY (U32 PhyReg, U16 Value) {
N  /* Write a data 'Value' to PHY register 'PhyReg'. */
N  U32 tout;
N
N  if (dev_175x == __TRUE) {
X  if (dev_175x == 1) {
N    /* Software MII Management for LPC175x. */
N    /* Remapped MDC on P2.8 and MDIO on P2.9 do not work. */
N    LPC_GPIO2->FIODIR |= MDIO;
X    ((LPC_GPIO_TypeDef *) ((0x2009C000UL) + 0x00040) )->FIODIR |= 0x00000200;
N
N    /* 32 consecutive ones on MDO to establish sync */
N    output_MDIO (0xFFFFFFFF, 32);
N
N    /* start code (01), write command (01) */
N    output_MDIO (0x05, 4);
N
N    /* write PHY address */
N    output_MDIO (DP83848C_DEF_ADR >> 8, 5);
X    output_MDIO (0x0100 >> 8, 5);
N
N    /* write the PHY register to write */
N    output_MDIO (PhyReg, 5);
N
N    /* turnaround MDIO (1,0)*/
N    output_MDIO (0x02, 2);
N
N    /* write the data value */
N    output_MDIO (Value, 16);
N
N    /* turnaround MDO is tristated */
N    turnaround_MDIO ();
N  }
N  else {
N    /* Hardware MII Management for LPC176x devices. */
N    LPC_EMAC->MADR = DP83848C_DEF_ADR | PhyReg;
X    ((LPC_EMAC_TypeDef *) ((0x50000000UL) + 0x00000) )->MADR = 0x0100 | PhyReg;
N    LPC_EMAC->MWTD = Value;
X    ((LPC_EMAC_TypeDef *) ((0x50000000UL) + 0x00000) )->MWTD = Value;
N
N    /* Wait utill operation completed */
N    for (tout = 0; tout < MII_WR_TOUT; tout++) {
X    for (tout = 0; tout < 0x00050000; tout++) {
N      if ((LPC_EMAC->MIND & MIND_BUSY) == 0) {
X      if ((((LPC_EMAC_TypeDef *) ((0x50000000UL) + 0x00000) )->MIND & 0x00000001) == 0) {
N        break;
N      }
N    }
N  }
N}
N
N
N/*--------------------------- read_PHY --------------------------------------*/
N
Nstatic U16 read_PHY (U32 PhyReg) {
N  /* Read a PHY register 'PhyReg'. */
N  U32 tout, val;
N
N  if (dev_175x == __TRUE) {
X  if (dev_175x == 1) {
N    /* Software MII Management for LPC175x. */
N    /* Remapped MDC on P2.8 and MDIO on P2.9 does not work. */
N    LPC_GPIO2->FIODIR |= MDIO;
X    ((LPC_GPIO_TypeDef *) ((0x2009C000UL) + 0x00040) )->FIODIR |= 0x00000200;
N
N    /* 32 consecutive ones on MDO to establish sync */
N    output_MDIO (0xFFFFFFFF, 32);
N
N    /* start code (01), read command (10) */
N    output_MDIO (0x06, 4);
N
N    /* write PHY address */
N    output_MDIO (DP83848C_DEF_ADR >> 8, 5);
X    output_MDIO (0x0100 >> 8, 5);
N
N    /* write the PHY register to write */
N    output_MDIO (PhyReg, 5);
N
N    /* turnaround MDO is tristated */
N    turnaround_MDIO ();
N
N    /* read the data value */
N    val = input_MDIO ();
N
N    /* turnaround MDIO is tristated */
N    turnaround_MDIO ();
N  }
N  else {
N    LPC_EMAC->MADR = DP83848C_DEF_ADR | PhyReg;
X    ((LPC_EMAC_TypeDef *) ((0x50000000UL) + 0x00000) )->MADR = 0x0100 | PhyReg;
N    LPC_EMAC->MCMD = MCMD_READ;
X    ((LPC_EMAC_TypeDef *) ((0x50000000UL) + 0x00000) )->MCMD = 0x00000001;
N
N    /* Wait until operation completed */
N    for (tout = 0; tout < MII_RD_TOUT; tout++) 
X    for (tout = 0; tout < 0x00050000; tout++) 
N	{
N      if ((LPC_EMAC->MIND & MIND_BUSY) == 0) 
X      if ((((LPC_EMAC_TypeDef *) ((0x50000000UL) + 0x00000) )->MIND & 0x00000001) == 0) 
N	  {
N        break;
N      }
N    }
N    LPC_EMAC->MCMD = 0;
X    ((LPC_EMAC_TypeDef *) ((0x50000000UL) + 0x00000) )->MCMD = 0;
N    val = LPC_EMAC->MRDD;
X    val = ((LPC_EMAC_TypeDef *) ((0x50000000UL) + 0x00000) )->MRDD;
N  }
N  return (val);
N}
N
N/*----------------------------------------------------------------------------
N * end of file
N *---------------------------------------------------------------------------*/
