; generated by ARM C/C++ Compiler, 4.1 [Build 644]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\out\ir.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\out\ir.d --cpu=Cortex-M3 --apcs=interwork -I.\inc -I.\inc\file_system -I.\inc\IR -IC:\Keil\ARM\RL\TCPnet\Drivers -I.\inc\tcpip -IC:\Keil\ARM\CMSIS\Include -IC:\Keil\ARM\INC\NXP\LPC17xx -DLPC1700 -DFLASH_512 --omf_browse=.\out\ir.crf src\IR\ir.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_u
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_s
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                  save_ir PROC
;;;29     ************************************************************************/
;;;30     char save_ir(unsigned short *dado,short addr,short channel,int index_file)
000000  e92d43f0          PUSH     {r4-r9,lr}
;;;31     {
000004  b093              SUB      sp,sp,#0x4c
000006  4605              MOV      r5,r0
000008  4688              MOV      r8,r1
;;;32     	FILE *f;
;;;33     	char StrIdIr[50],str_aux[20];
;;;34     	short i=0,fim=0;
00000a  2400              MOVS     r4,#0
00000c  4691              MOV      r9,r2                 ;31
00000e  461f              MOV      r7,r3                 ;31
000010  4626              MOV      r6,r4
;;;35     
;;;36     	memset(StrIdIr,0,sizeof(StrIdIr));		/*Limpa vetor que irá conter o endereço onde o IR será armazenado*/
000012  2134              MOVS     r1,#0x34
000014  4668              MOV      r0,sp
000016  f7fffffe          BL       __aeabi_memclr4
;;;37     	if(index_file == FILE_INDEX_INFRARED)	/*Salvar IR na pasta INFRARED?*/
00001a  b127              CBZ      r7,|L1.38|
;;;38     	{
;;;39     		if(addr <= IR_ID6)
;;;40     			/*(TV)->ID0:Source...ID1:CH-...ID2:CH+...ID3:ON...ID4:OFF...ID5:Vol-...ID6:Vol+*/
;;;41     			strcat(StrIdIr,FILE_IR_DIR_TV);	
;;;42     		else
;;;43     		if(addr <= IR_ID18)
;;;44     		{
;;;45     			/*(HOME)->ID7:Source...ID8:VOL-...ID9:VOL+...ID10:ON...ID11:OFF...ID12:PLAY...ID13:PAUSE...ID14:BACK...ID15:NEXT*/
;;;46     			/*ID16: Cursor Left...ID17: Cursor Righ...ID18: Cursor Down*/
;;;47     			strcat(StrIdIr,FILE_IR_DIR_HOME);	
;;;48     		}else
;;;49     		{
;;;50     			if(atoi(cfg.file.mode_func_ar)) 	/*Swing In (Função swing embutida na temperatura)?*/
;;;51     			{
;;;52     				/*(AR)->ID19:16°...ID20:17°............ID33:30°...ID34:ON...ID35:OFF*/
;;;53     				if(ir_state.bit.ArSwing)
;;;54     					strcat(StrIdIr,FILE_IR_DIR_AR_SW_ON);
;;;55     				else
;;;56     					strcat(StrIdIr,FILE_IR_DIR_AR_SW_OFF);
;;;57     
;;;58     			}else
;;;59     			{
;;;60     				/*(AR)->ID19:16°...ID20:17°............ID33:30°...ID34:ON...ID35:OFF..ID36:SWING ON..ID37:SWING OFF*/
;;;61     				strcat(StrIdIr,FILE_IR_DIR_AR_SW_OUT);
;;;62     			}
;;;63     		}
;;;64     
;;;65     		sprintf(str_aux,"%u.TXT\0",addr);	/*Copia o endereço*/
;;;66     		strcat(StrIdIr,str_aux);			/*Endereço completo(caminho + endereço)*/
;;;67     	}else
;;;68     	if(index_file == FILE_INDEX_CMDIR)	/*Salvar o IR como sendo um comando para geração de cenas?*/
00001c  2f01              CMP      r7,#1
00001e  d026              BEQ      |L1.110|
;;;69     	{
;;;70        		sprintf(StrIdIr,"%s%u.TXT\0",FILE_CMDIR,addr);
;;;71     	}else
;;;72     	if(index_file == FILE_INDEX_RAIZ)	/*Salvar o IR apenas na raiz do SD?*/
000020  2f02              CMP      r7,#2
000022  d02b              BEQ      |L1.124|
000024  e048              B        |L1.184|
                  |L1.38|
000026  f1b80f06          CMP      r8,#6                 ;39
00002a  dc01              BGT      |L1.48|
00002c  a1e6              ADR      r1,|L1.968|
00002e  e00f              B        |L1.80|
                  |L1.48|
000030  f1b80f12          CMP      r8,#0x12              ;43
000034  dc01              BGT      |L1.58|
000036  a1e8              ADR      r1,|L1.984|
000038  e00a              B        |L1.80|
                  |L1.58|
00003a  48ec              LDR      r0,|L1.1004|
00003c  f7fffffe          BL       atoi
000040  b198              CBZ      r0,|L1.106|
000042  48eb              LDR      r0,|L1.1008|
000044  7800              LDRB     r0,[r0,#0]            ;53  ; ir_state
000046  0680              LSLS     r0,r0,#26             ;53
000048  d501              BPL      |L1.78|
00004a  a1ea              ADR      r1,|L1.1012|
00004c  e000              B        |L1.80|
                  |L1.78|
00004e  a1ef              ADR      r1,|L1.1036|
                  |L1.80|
000050  4668              MOV      r0,sp                 ;61
000052  f7fffffe          BL       strcat
000056  4642              MOV      r2,r8                 ;65
000058  a1f2              ADR      r1,|L1.1060|
00005a  a80d              ADD      r0,sp,#0x34           ;65
00005c  f7fffffe          BL       __2sprintf
000060  a90d              ADD      r1,sp,#0x34           ;66
000062  4668              MOV      r0,sp                 ;66
000064  f7fffffe          BL       strcat
000068  e00c              B        |L1.132|
                  |L1.106|
00006a  a1f0              ADR      r1,|L1.1068|
00006c  e7f0              B        |L1.80|
                  |L1.110|
00006e  4643              MOV      r3,r8                 ;70
000070  a2f4              ADR      r2,|L1.1092|
000072  a1f7              ADR      r1,|L1.1104|
000074  4668              MOV      r0,sp                 ;70
000076  f7fffffe          BL       __2sprintf
00007a  e003              B        |L1.132|
                  |L1.124|
;;;73     	{
;;;74     		sprintf(StrIdIr,"IR.TXT\0");
00007c  a1f7              ADR      r1,|L1.1116|
00007e  4668              MOV      r0,sp
000080  f7fffffe          BL       __2sprintf
                  |L1.132|
;;;75     	}else
;;;76     		return ERROR_NOT_SAVED;		/*Error ao especificar o local de armazenamento do IR*/
;;;77     	/*Apenas para debug do endereço completo*/
;;;78     	printf("[Save IR...addr:%s]\r",StrIdIr);
000084  4669              MOV      r1,sp
000086  a0f7              ADR      r0,|L1.1124|
000088  f7fffffe          BL       __2printf
;;;79     	fflush(stdout);
00008c  48fb              LDR      r0,|L1.1148|
00008e  f7fffffe          BL       fflush
;;;80     
;;;81     	f = fopen(StrIdIr,"w");	/*Abre arquivo para escrita*/
000092  a1fb              ADR      r1,|L1.1152|
000094  4668              MOV      r0,sp
000096  f7fffffe          BL       fopen
00009a  0007              MOVS     r7,r0
;;;82     	if(f == NULL)
00009c  d00c              BEQ      |L1.184|
;;;83     		return ERROR_NOT_SAVED;
;;;84     	/*Arquivo abriu corretamente*/
;;;85     	/*Loop para encontrar o primeiro pulso vazio do IR e armazenar nessa posição o canal de emissão*/
;;;86     	for(i=0;i<MAX_QTD_PULSOS;i++)
;;;87     	{
;;;88     		if(dado[i] == 0xFFFF)	/*Posição vazia?*/
00009e  f64f71ff          MOV      r1,#0xffff
0000a2  f44f70c8          MOV      r0,#0x190             ;86
                  |L1.166|
0000a6  f8352014          LDRH     r2,[r5,r4,LSL #1]
0000aa  428a              CMP      r2,r1
0000ac  d108              BNE      |L1.192|
;;;89     		{
;;;90     			dado[i] = channel;	/*Armazena o canal e de emissão do IR*/
0000ae  f8259014          STRH     r9,[r5,r4,LSL #1]
;;;91     			fim = i + 1;		/*Guarda a posição do final do IR (uma posição a frente da localização do canal)*/
0000b2  1c64              ADDS     r4,r4,#1
0000b4  b226              SXTH     r6,r4
;;;92     			break;				/*Sai do laço*/
0000b6  e007              B        |L1.200|
                  |L1.184|
0000b8  200b              MOVS     r0,#0xb               ;83
                  |L1.186|
;;;93     		}
;;;94     	}
;;;95     	/*Loop para escrever no arquivo*/
;;;96     	for(i=0;i<MAX_QTD_PULSOS;i++)
;;;97     	{
;;;98     		if(i == fim)					/*Chegou no fim?*/
;;;99     			break;					   	/*Sai do laço*/
;;;100    		fprintf(f,"%u#\r\n",dado[i]);	/*Escreve no aruivo o pulso*/
;;;101    	}
;;;102    	/*Fecha arquivo e retorna sem erros*/
;;;103    	fclose(f);	
;;;104    	return NO_ERROR;
;;;105    }
0000ba  b013              ADD      sp,sp,#0x4c
0000bc  e8bd83f0          POP      {r4-r9,pc}
                  |L1.192|
0000c0  1c64              ADDS     r4,r4,#1              ;86
0000c2  b224              SXTH     r4,r4                 ;86
0000c4  4284              CMP      r4,r0                 ;86
0000c6  dbee              BLT      |L1.166|
                  |L1.200|
0000c8  2400              MOVS     r4,#0                 ;96
0000ca  4680              MOV      r8,r0                 ;86
                  |L1.204|
0000cc  42b4              CMP      r4,r6                 ;98
0000ce  d009              BEQ      |L1.228|
0000d0  f8352014          LDRH     r2,[r5,r4,LSL #1]     ;100
0000d4  a1eb              ADR      r1,|L1.1156|
0000d6  4638              MOV      r0,r7                 ;100
0000d8  f7fffffe          BL       __2fprintf
0000dc  1c64              ADDS     r4,r4,#1              ;96
0000de  b224              SXTH     r4,r4                 ;96
0000e0  4544              CMP      r4,r8                 ;96
0000e2  dbf3              BLT      |L1.204|
                  |L1.228|
0000e4  4638              MOV      r0,r7                 ;103
0000e6  f7fffffe          BL       fclose
0000ea  200f              MOVS     r0,#0xf               ;104
0000ec  e7e5              B        |L1.186|
;;;106    
                          ENDP

                  read_ir PROC
;;;109    *****************************************************************************/
;;;110    char read_ir(unsigned short addr, int index_file)
0000ee  e92d47f0          PUSH     {r4-r10,lr}
;;;111    {
0000f2  b08c              SUB      sp,sp,#0x30
0000f4  4606              MOV      r6,r0
0000f6  460f              MOV      r7,r1
;;;112    	FILE *f;
;;;113    	char StrIdIr[30],str[10];
;;;114    	int id=0,ch=0,i=0;
0000f8  2500              MOVS     r5,#0
0000fa  462c              MOV      r4,r5
;;;115    
;;;116    	/*Limpa vetor que irá conter o endereço onde o IR será armazenado e o vetor auxiliar*/
;;;117    	memset(StrIdIr,0,sizeof(StrIdIr));
0000fc  2120              MOVS     r1,#0x20
0000fe  4668              MOV      r0,sp
000100  f7fffffe          BL       __aeabi_memclr4
;;;118    	memset(str,0,sizeof(str));
000104  46a8              MOV      r8,r5
000106  f8cd8020          STR      r8,[sp,#0x20]
00010a  f8cd8024          STR      r8,[sp,#0x24]
;;;119    
;;;120    	if(index_file == FILE_INDEX_INFRARED)	/*Salvar IR na pasta INFRARED?*/
00010e  f8cd8028          STR      r8,[sp,#0x28]
000112  b117              CBZ      r7,|L1.282|
;;;121    	{
;;;122    		if(addr <= IR_ID6)
;;;123    			/*(TV)->ID0:Source...ID1:CH-...ID2:CH+...ID3:ON...ID4:OFF...ID5:Vol-...ID6:Vol+*/
;;;124    			strcat(StrIdIr,FILE_IR_DIR_TV);	
;;;125    		else
;;;126    		if(addr <= IR_ID18)
;;;127    		{
;;;128    			/*(HOME)->ID7:Source...ID8:VOL-...ID9:VOL+...ID10:ON...ID11:OFF...ID12:PLAY...ID13:PAUSE...ID14:BACK...ID15:NEXT*/
;;;129    			/*ID16: Cursor Left...ID17: Cursor Righ...ID18: Cursor Down*/
;;;130    			strcat(StrIdIr,FILE_IR_DIR_HOME);	
;;;131    		}else
;;;132    		{
;;;133    			if(atoi(cfg.file.mode_func_ar)) 	/*Swing In (Função swing embutida na temperatura)?*/
;;;134    			{
;;;135    				/*(AR)->ID19:16°...ID20:17°............ID33:30°...ID34:ON...ID35:OFF*/
;;;136    				if(ir_state.bit.ArSwing)
;;;137    					strcat(StrIdIr,FILE_IR_DIR_AR_SW_ON);
;;;138    				else
;;;139    					strcat(StrIdIr,FILE_IR_DIR_AR_SW_OFF);
;;;140    
;;;141    			}else
;;;142    			{
;;;143    				/*(AR)->ID19:16°...ID20:17°............ID33:30°...ID34:ON...ID35:OFF..ID36:SWING ON..ID37:SWING OFF*/
;;;144    				strcat(StrIdIr,FILE_IR_DIR_AR_SW_OUT);
;;;145    			}
;;;146    		}
;;;147    		sprintf(StrIdIr,"%s%u.TXT\0",StrIdIr,addr);		/*Endereço completo(caminho + endereço)*/
;;;148    
;;;149    	}else
;;;150    	if(index_file == FILE_INDEX_RAIZ)	/*Salvar o IR apenas na raiz do SD?*/
000114  2f02              CMP      r7,#2
000116  d01f              BEQ      |L1.344|
000118  e022              B        |L1.352|
                  |L1.282|
00011a  2e06              CMP      r6,#6                 ;122
00011c  d801              BHI      |L1.290|
00011e  a1aa              ADR      r1,|L1.968|
000120  e00e              B        |L1.320|
                  |L1.290|
000122  2e12              CMP      r6,#0x12              ;126
000124  d801              BHI      |L1.298|
000126  a1ac              ADR      r1,|L1.984|
000128  e00a              B        |L1.320|
                  |L1.298|
00012a  48b0              LDR      r0,|L1.1004|
00012c  f7fffffe          BL       atoi
000130  b180              CBZ      r0,|L1.340|
000132  48af              LDR      r0,|L1.1008|
000134  7800              LDRB     r0,[r0,#0]            ;136  ; ir_state
000136  0680              LSLS     r0,r0,#26             ;136
000138  d501              BPL      |L1.318|
00013a  a1ae              ADR      r1,|L1.1012|
00013c  e000              B        |L1.320|
                  |L1.318|
00013e  a1b3              ADR      r1,|L1.1036|
                  |L1.320|
000140  4668              MOV      r0,sp                 ;144
000142  f7fffffe          BL       strcat
000146  466a              MOV      r2,sp                 ;147
000148  4633              MOV      r3,r6                 ;147
00014a  a1c1              ADR      r1,|L1.1104|
00014c  4610              MOV      r0,r2                 ;147
00014e  f7fffffe          BL       __2sprintf
000152  e005              B        |L1.352|
                  |L1.340|
000154  a1b5              ADR      r1,|L1.1068|
000156  e7f3              B        |L1.320|
                  |L1.344|
;;;151    		sprintf(StrIdIr,"IR.TXT\0");
000158  a1c0              ADR      r1,|L1.1116|
00015a  4668              MOV      r0,sp
00015c  f7fffffe          BL       __2sprintf
                  |L1.352|
;;;152    	/*Apenas para debug do endereço completo*/
;;;153    	printf("\r[%s]\r",StrIdIr);
000160  4669              MOV      r1,sp
000162  a0ca              ADR      r0,|L1.1164|
000164  f7fffffe          BL       __2printf
;;;154    	fflush(stdout);
000168  48c4              LDR      r0,|L1.1148|
00016a  f7fffffe          BL       fflush
;;;155    
;;;156    	f = fopen(StrIdIr,"r");			/*Abre aquivo para leitura*/
00016e  a1c9              ADR      r1,|L1.1172|
000170  4668              MOV      r0,sp
000172  f7fffffe          BL       fopen
000176  4682              MOV      r10,r0
;;;157    	memset(ir,0xFFFF,sizeof(ir));	/*Limpa vetor que vai armazenar o IR lido no SD*/
000178  f64f72ff          MOV      r2,#0xffff
00017c  f44f7148          MOV      r1,#0x320
000180  48c5              LDR      r0,|L1.1176|
000182  f7fffffe          BL       __aeabi_memset
000186  4ec4              LDR      r6,|L1.1176|
;;;158      	if(f == NULL)					/*Ocorreu erro?*/
000188  f1ba0f00          CMP      r10,#0
00018c  d011              BEQ      |L1.434|
00018e  f10d0920          ADD      r9,sp,#0x20           ;113
000192  4647              MOV      r7,r8                 ;114
                  |L1.404|
;;;159    	{
;;;160    		printf("[File not found]\r");
;;;161    		fflush(stdout);
;;;162       		return __FALSE; 
;;;163    	}
;;;164    	/*Arquivo aberto*/
;;;165    	/*Laço que vai ler os pulsos e armazenar cada um*/
;;;166    	while((ch = fgetc (f)) != EOF)
000194  4650              MOV      r0,r10
000196  f7fffffe          BL       fgetc
00019a  1c41              ADDS     r1,r0,#1
00019c  d022              BEQ      |L1.484|
;;;167    	{
;;;168    		if(ch == '#')
00019e  2823              CMP      r0,#0x23
0001a0  d011              BEQ      |L1.454|
;;;169    		{
;;;170    			ir[id] = atoi(str);	/*Armazena o pulso*/
;;;171    			if(ir[id] <= 16)	/*Encontrou a posição no canal de emissão do IR?*/
;;;172    				break;
;;;173    			id++;		
;;;174    		}else
;;;175    		{
;;;176    			if(ch != '\r' && ch != '\n')
0001a2  280d              CMP      r0,#0xd
0001a4  d019              BEQ      |L1.474|
0001a6  280a              CMP      r0,#0xa
0001a8  d017              BEQ      |L1.474|
;;;177    			{
;;;178    				str[i] = ch;
0001aa  f8090004          STRB     r0,[r9,r4]
;;;179    				i++;
0001ae  1c64              ADDS     r4,r4,#1
0001b0  e7f0              B        |L1.404|
                  |L1.434|
0001b2  a0ba              ADR      r0,|L1.1180|
0001b4  f7fffffe          BL       __2printf
0001b8  48b0              LDR      r0,|L1.1148|
0001ba  f7fffffe          BL       fflush
0001be  2000              MOVS     r0,#0                 ;162
                  |L1.448|
;;;180    			}else
;;;181    			{
;;;182    				/*Limpa e reseta contador as vezes que contrar caracteres indesejados (\r,\n)*/
;;;183    				memset(str,0,sizeof(str));
;;;184    				i=0;
;;;185    			}
;;;186    		}
;;;187    	}
;;;188    	printf("[File closed]\r");
;;;189    	fflush(stdout);
;;;190    	fclose(f);		/*Fecha arquivo*/    
;;;191    	if(ir[id] > 0 && ir[id] < 16)	
;;;192    		last_port_ir = ir[id];
;;;193    	else
;;;194    		last_port_ir = 7; /*Em todas as portas*/
;;;195    	return NO_ERROR;
;;;196    }
0001c0  b00c              ADD      sp,sp,#0x30
0001c2  e8bd87f0          POP      {r4-r10,pc}
                  |L1.454|
0001c6  a808              ADD      r0,sp,#0x20           ;170
0001c8  f7fffffe          BL       atoi
0001cc  b280              UXTH     r0,r0                 ;170
0001ce  f8260015          STRH     r0,[r6,r5,LSL #1]     ;170
0001d2  2810              CMP      r0,#0x10              ;171
0001d4  d906              BLS      |L1.484|
0001d6  1c6d              ADDS     r5,r5,#1              ;173
0001d8  e7dc              B        |L1.404|
                  |L1.474|
0001da  9708              STR      r7,[sp,#0x20]         ;183
0001dc  9709              STR      r7,[sp,#0x24]         ;183
0001de  2400              MOVS     r4,#0                 ;184
0001e0  970a              STR      r7,[sp,#0x28]         ;184
0001e2  e7d7              B        |L1.404|
                  |L1.484|
0001e4  a0b2              ADR      r0,|L1.1200|
0001e6  f7fffffe          BL       __2printf
0001ea  48a4              LDR      r0,|L1.1148|
0001ec  f7fffffe          BL       fflush
0001f0  4650              MOV      r0,r10                ;190
0001f2  f7fffffe          BL       fclose
0001f6  f8360015          LDRH     r0,[r6,r5,LSL #1]     ;191
0001fa  49b1              LDR      r1,|L1.1216|
0001fc  1e42              SUBS     r2,r0,#1              ;191
0001fe  2a0f              CMP      r2,#0xf               ;191
000200  d300              BCC      |L1.516|
000202  2007              MOVS     r0,#7                 ;194
                  |L1.516|
000204  7008              STRB     r0,[r1,#0]            ;192
000206  200f              MOVS     r0,#0xf               ;195
000208  e7da              B        |L1.448|
;;;197    
                          ENDP

                  erase_all_ir PROC
;;;200    *****************************************************************************/
;;;201    void erase_all_ir(void)
00020a  b530              PUSH     {r4,r5,lr}
;;;202    {	
00020c  b089              SUB      sp,sp,#0x24
;;;203    	char StrIdIr[30];
;;;204    	short i;
;;;205    	 
;;;206    	memset(StrIdIr,0,sizeof(StrIdIr));	
00020e  2120              MOVS     r1,#0x20
000210  4668              MOV      r0,sp
000212  f7fffffe          BL       __aeabi_memclr4
;;;207    	for(i=0;i<MAX_QTD_IR;i++)
000216  2400              MOVS     r4,#0
000218  f44f651b          MOV      r5,#0x9b0
                  |L1.540|
;;;208    	{
;;;209    		sprintf(StrIdIr,"%s%u.TXT\0",FILE_INFRARED,i);
00021c  4623              MOV      r3,r4
00021e  a2a9              ADR      r2,|L1.1220|
000220  a18b              ADR      r1,|L1.1104|
000222  4668              MOV      r0,sp
000224  f7fffffe          BL       __2sprintf
;;;210    		fdelete(StrIdIr);
000228  4668              MOV      r0,sp
00022a  f7fffffe          BL       fdelete
00022e  1c64              ADDS     r4,r4,#1              ;207
000230  b224              SXTH     r4,r4                 ;207
000232  42ac              CMP      r4,r5                 ;207
000234  dbf2              BLT      |L1.540|
;;;211    	}	 
;;;212    }
000236  b009              ADD      sp,sp,#0x24
000238  bd30              POP      {r4,r5,pc}
;;;213    
                          ENDP

                  erase_ir PROC
;;;216    *****************************************************************************/
;;;217    void erase_ir(unsigned short addr)
00023a  b510              PUSH     {r4,lr}
;;;218    {	 	
00023c  b088              SUB      sp,sp,#0x20
00023e  4604              MOV      r4,r0
;;;219       	char StrIdIr[30];
;;;220    	memset(StrIdIr,0,sizeof(StrIdIr));
000240  2120              MOVS     r1,#0x20
000242  4668              MOV      r0,sp
000244  f7fffffe          BL       __aeabi_memclr4
;;;221    	sprintf(StrIdIr,"%s%u.TXT\0",FILE_INFRARED,addr);
000248  4623              MOV      r3,r4
00024a  a29e              ADR      r2,|L1.1220|
00024c  a180              ADR      r1,|L1.1104|
00024e  4668              MOV      r0,sp
000250  f7fffffe          BL       __2sprintf
;;;222    	fdelete(StrIdIr);	
000254  4668              MOV      r0,sp
000256  f7fffffe          BL       fdelete
;;;223    }
00025a  b008              ADD      sp,sp,#0x20
00025c  bd10              POP      {r4,pc}
;;;224    
                          ENDP

                  send_ir PROC
;;;227    *****************************************************************************/
;;;228    char send_ir(unsigned short addr, int index_file)
00025e  e92d4ff3          PUSH     {r0,r1,r4-r11,lr}
;;;229    {
000262  b08b              SUB      sp,sp,#0x2c
;;;230    	unsigned int i=0;
000264  2400              MOVS     r4,#0
;;;231    	U32 lead_in_on=0, lead_in_off=0;
;;;232    	char freq[30];
;;;233    
;;;234    	if(!read_ir(addr, index_file))	/*Lê IR localizado no endereço 'addr'  e verifica se houve erro de leitura no sd*/
000266  980b              LDR      r0,[sp,#0x2c]
000268  f7fffffe          BL       read_ir
00026c  46a0              MOV      r8,r4                 ;230
00026e  b300              CBZ      r0,|L1.690|
;;;235    	{
;;;236    		contEnableExtIr = 0;		/*Inicia temporização para habilitar a interrupção externa*/
;;;237    		enable_timer(0);			/*Habilita timer 0*/
;;;238    		return __FALSE;
;;;239    	}
;;;240    
;;;241    	disable_timer(0);				/*Desabilita timer 0*/
000270  2000              MOVS     r0,#0
000272  f7fffffe          BL       disable_timer
;;;242    	NVIC_DisableIRQ(EINT3_IRQn);	/*Desabilita a interrupção responsavel por detectar se um comando IR xegou no pino (IR CMD)*/
000276  2015              MOVS     r0,#0x15
000278  f7fffffe          BL       NVIC_DisableIRQ
;;;243    
;;;244    	/*IR no formato DEC*/
;;;245    	memset(freq,0,sizeof(freq));
00027c  2120              MOVS     r1,#0x20
00027e  a801              ADD      r0,sp,#4
000280  f7fffffe          BL       __aeabi_memclr4
;;;246    	lead_in_on = ir[0] * 4; 	/*Pulso Lead IN high em us*/ 
000284  f8df9210          LDR      r9,|L1.1176|
;;;247    	lead_in_off = ir[1] * 4; /*Pulso Lead IN low em us*/
;;;248    
;;;249    	/*SIRC-SONY: 40Khz..Lead In on: 2400us..Lead In of: 600us..Logic high ON: 1200us..Logic high OFF: 600us..
;;;250    	Logic low ON: 600us..Logic low OFF: 600us..Pulse high without Lead IN: 12bits, 15bits or 20bits*/
;;;251    	if( lead_in_on  >= 2400 - 2400 * 0.1 && lead_in_on  <= 2400 + 2400 * 0.1 /*&&
;;;252    		lead_in_off >= 600  - 600  * 0.1 && lead_in_off <= 600  + 600  * 0.1*/ )	
;;;253    	{
;;;254    		PWM_freq_KHz = CARRIER_FREQ_40KHZ;
000288  4f92              LDR      r7,|L1.1236|
;;;255    		strcpy(freq, "40KHz (SONY/SIRC)\0");
;;;256    
;;;257    	}else
;;;258    	/*RC5-PHILIPS: 36Khz..Lead In on: 889us..Lead In off: 889us..Logic high ON: 889us..Logic high OFF: 889us..
;;;259    	  Logic low ON: 889us..Logic low OFF: 889us*/ 
;;;260    	if( lead_in_on 	>= 889 - 889 * 0.1 && lead_in_on  <= 889 + 889 * 0.1 /*&&
;;;261    		lead_in_off >= 889 - 889 * 0.1 && lead_in_off <= 889 + 889 * 0.1*/ )
;;;262    	{
;;;263    		PWM_freq_KHz = CARRIER_FREQ_36KHZ;
00028a  f2402bb3          MOV      r11,#0x2b3
00028e  f8b90000          LDRH     r0,[r9,#0]            ;246  ; ir
000292  0080              LSLS     r0,r0,#2              ;246
000294  4682              MOV      r10,r0                ;246
000296  f8b90002          LDRH     r0,[r9,#2]            ;247  ; ir
00029a  0080              LSLS     r0,r0,#2              ;247
00029c  9009              STR      r0,[sp,#0x24]         ;251
00029e  f5aa6007          SUB      r0,r10,#0x870         ;251
0002a2  f5b07ff0          CMP      r0,#0x1e0             ;251
0002a6  d80e              BHI      |L1.710|
0002a8  f44f701b          MOV      r0,#0x26c             ;254
0002ac  a18a              ADR      r1,|L1.1240|
0002ae  6038              STR      r0,[r7,#0]            ;255  ; PWM_freq_KHz
0002b0  e036              B        |L1.800|
                  |L1.690|
0002b2  498e              LDR      r1,|L1.1260|
0002b4  2000              MOVS     r0,#0                 ;237
0002b6  f8c18000          STR      r8,[r1,#0]            ;237  ; contEnableExtIr
0002ba  f7fffffe          BL       enable_timer
0002be  2000              MOVS     r0,#0                 ;238
                  |L1.704|
;;;264    		strcpy(freq, "36KHz (RC5/PHILIPS)\0");
;;;265    
;;;266    	}else
;;;267    	/*RC6-PHILIPS: 36Khz..Lead In on: 2666us..Lead In off: 889us*/
;;;268    	if( lead_in_on 	>= 2666 - 2666 * 0.1 && lead_in_on  <= 2666 + 2666 * 0.1 /*&&
;;;269    	    lead_in_off >= 889  - 889  * 0.1 && lead_in_off <= 889  + 889  * 0.1*/ )	
;;;270    	{
;;;271    		PWM_freq_KHz = CARRIER_FREQ_36KHZ;
;;;272    		strcpy(freq, "36KHz (RC6/PHILIPS)\0");
;;;273    
;;;274    	}else
;;;275    	{
;;;276    		/*Frequencia default*/
;;;277       		PWM_freq_KHz = CARRIER_FREQ_38KHZ;
;;;278    		strcpy(freq, "38KHz (DEFAULT)\0");
;;;279    	}
;;;280    
;;;281    	PWM_Set(PWM_freq_KHz);			/*Configura o PWM*/
;;;282    
;;;283    	for(i=0;i<MAX_QTD_PULSOS;i++)	/*Loop que passa por todos os pulsos do IR*/
;;;284    	{ 
;;;285    		/*Sai do laço na primeira posição vazia do vetor(0xffff) ou se o pulso for < 16 (porta do IR 0-15)*/	
;;;286    		if(ir[i] >= 0xffff || ir[i] < 0x10)	
;;;287    			break;		
;;;288    
;;;289    		if(i%2==0)	
;;;290    			PWM_Start(last_port_ir);	/*Numeros Pares...Liga PWM*/ 		
;;;291    		else 	  
;;;292    			PWM_Stop();					/*Numeros Impares...Desliga PWM*/
;;;293    	
;;;294    		timer1_counter = 0;	/*Reseta contador do timer*/
;;;295    		LPC_TIM1->IR = 1;	/*Limpa flag da interrupção*/
;;;296    		LPC_TIM1->TCR = 2;	/*Reseta contador do timer*/
;;;297    		LPC_TIM1->TCR = 1;	/*Inicia a contagem*/
;;;298    
;;;299    		while(1)	/*Laço que aguarda o tempo necessario de cada pulso*/
;;;300    		{
;;;301    			/*Verifica se houve interrupção para fazer o incremento do contador IR*/ 
;;;302    			if(LPC_TIM1->IR & (1<<0))
;;;303    			{
;;;304    				LPC_TIM1->IR = 1;				/*Limpa flag da interrupção do timer 1 para uma nova interrupção*/
;;;305    				if(++timer1_counter >= ir[i])	/*Passou-se o tempo necessário do pulso?*/
;;;306    				{
;;;307    					LPC_TIM1->TCR = 0;	/*Finaliza contagem*/
;;;308    					break;				/*Sai do laço para fazer a contagem de um novo pulso*/
;;;309    				}
;;;310    			}
;;;311    		}
;;;312    	}
;;;313    	LPC_TIM1->TCR = 0;		/*Finaliza contagem*/
;;;314    	PWM_Stop();				/*Desliga todos os PWMs*/
;;;315    	enable_timer(0);		/*Habilita novamente o timer 0*/
;;;316    	contEnableExtIr = 0;	/*Inicia temporização para habilitar a interrupção externa*/
;;;317    
;;;318    	/*Informação das portas em que o IR foi emitido*/
;;;319    	printf("\r***\r[IR:%u..Port:0(%s) 1(%s) 2(%s)]\r",addr,(last_port_ir & (1<<0))?"SIM":"NÃO",(last_port_ir & (1<<1))?"SIM":"NÃO",(last_port_ir & (1<<2))?"SIM":"NÃO");
;;;320    	fflush(stdout);
;;;321    	/*Informações do IR DEC*/
;;;322    	printf("Frequencia: %s\r",freq);
;;;323    	printf("Lead IN ON: %uus\r",lead_in_on);
;;;324    	printf("Lead IN OFF: %uus\r***\r\r",lead_in_off);
;;;325    	fflush(stdout);
;;;326    
;;;327    	return __TRUE;
;;;328    }
0002c0  b00d              ADD      sp,sp,#0x34
                  |L1.706|
0002c2  e8bd8ff0          POP      {r4-r11,pc}
                  |L1.710|
0002c6  4650              MOV      r0,r10                ;260
0002c8  f7fffffe          BL       __aeabi_ui2d
0002cc  4605              MOV      r5,r0                 ;260
0002ce  460e              MOV      r6,r1                 ;260
0002d0  4a87              LDR      r2,|L1.1264|
0002d2  4b88              LDR      r3,|L1.1268|
0002d4  f7fffffe          BL       __aeabi_cdrcmple
0002d8  d80b              BHI      |L1.754|
0002da  f04f3233          MOV      r2,#0x33333333        ;260
0002de  4b86              LDR      r3,|L1.1272|
0002e0  4628              MOV      r0,r5                 ;260
0002e2  4631              MOV      r1,r6                 ;260
0002e4  f7fffffe          BL       __aeabi_cdcmple
0002e8  d803              BHI      |L1.754|
0002ea  a184              ADR      r1,|L1.1276|
0002ec  f8c7b000          STR      r11,[r7,#0]           ;264  ; PWM_freq_KHz
0002f0  e016              B        |L1.800|
                  |L1.754|
0002f2  4a7f              LDR      r2,|L1.1264|
0002f4  4b87              LDR      r3,|L1.1300|
0002f6  4628              MOV      r0,r5                 ;268
0002f8  4631              MOV      r1,r6                 ;268
0002fa  f7fffffe          BL       __aeabi_cdrcmple
0002fe  d80b              BHI      |L1.792|
000300  f04f3233          MOV      r2,#0x33333333        ;268
000304  4b84              LDR      r3,|L1.1304|
000306  4628              MOV      r0,r5                 ;268
000308  4631              MOV      r1,r6                 ;268
00030a  f7fffffe          BL       __aeabi_cdcmple
00030e  d803              BHI      |L1.792|
000310  a182              ADR      r1,|L1.1308|
000312  f8c7b000          STR      r11,[r7,#0]           ;272  ; PWM_freq_KHz
000316  e003              B        |L1.800|
                  |L1.792|
000318  f2402091          MOV      r0,#0x291             ;277
00031c  a185              ADR      r1,|L1.1332|
00031e  6038              STR      r0,[r7,#0]            ;278  ; PWM_freq_KHz
                  |L1.800|
000320  a801              ADD      r0,sp,#4              ;272
000322  f7fffffe          BL       strcpy
000326  6838              LDR      r0,[r7,#0]            ;281  ; PWM_freq_KHz
000328  f7fffffe          BL       PWM_Set
00032c  464f              MOV      r7,r9                 ;246
00032e  4d86              LDR      r5,|L1.1352|
000330  4e86              LDR      r6,|L1.1356|
000332  f8df918c          LDR      r9,|L1.1216|
000336  f04f0b01          MOV      r11,#1                ;295
                  |L1.826|
00033a  f8370014          LDRH     r0,[r7,r4,LSL #1]     ;286
00033e  f64f71ef          MOV      r1,#0xffef            ;286
000342  3810              SUBS     r0,r0,#0x10           ;286
000344  4288              CMP      r0,r1                 ;286
000346  d224              BCS      |L1.914|
000348  07e0              LSLS     r0,r4,#31             ;289
00034a  d03b              BEQ      |L1.964|
00034c  f7fffffe          BL       PWM_Stop
                  |L1.848|
000350  2000              MOVS     r0,#0                 ;292
000352  e9c50000          STRD     r0,r0,[r5,#0]         ;295
000356  465b              MOV      r3,r11                ;295
000358  f8c6b000          STR      r11,[r6,#0]           ;295
00035c  2002              MOVS     r0,#2                 ;296
00035e  6070              STR      r0,[r6,#4]            ;296
000360  f8c6b004          STR      r11,[r6,#4]           ;297
                  |L1.868|
000364  6830              LDR      r0,[r6,#0]            ;302
000366  07c0              LSLS     r0,r0,#31             ;302
000368  d0fc              BEQ      |L1.868|
00036a  6033              STR      r3,[r6,#0]            ;304
00036c  e9d50100          LDRD     r0,r1,[r5,#0]         ;304
000370  1c40              ADDS     r0,r0,#1              ;304
000372  f1410100          ADC      r1,r1,#0              ;304
000376  e9c50100          STRD     r0,r1,[r5,#0]         ;304
00037a  f8372014          LDRH     r2,[r7,r4,LSL #1]     ;305
00037e  1a80              SUBS     r0,r0,r2              ;305
000380  f1710100          SBCS     r1,r1,#0              ;305
000384  d3ee              BCC      |L1.868|
000386  f8c68004          STR      r8,[r6,#4]            ;307
00038a  1c64              ADDS     r4,r4,#1              ;283
00038c  f5b47fc8          CMP      r4,#0x190             ;283
000390  d3d3              BCC      |L1.826|
                  |L1.914|
000392  4644              MOV      r4,r8                 ;313
000394  f8c68004          STR      r8,[r6,#4]            ;313
000398  f7fffffe          BL       PWM_Stop
00039c  2000              MOVS     r0,#0                 ;315
00039e  f7fffffe          BL       enable_timer
0003a2  4852              LDR      r0,|L1.1260|
0003a4  a16a              ADR      r1,|L1.1360|
0003a6  6004              STR      r4,[r0,#0]            ;319  ; contEnableExtIr
0003a8  f8990000          LDRB     r0,[r9,#0]            ;319  ; last_port_ir
0003ac  0742              LSLS     r2,r0,#29             ;319
0003ae  d400              BMI      |L1.946|
0003b0  a168              ADR      r1,|L1.1364|
                  |L1.946|
0003b2  9100              STR      r1,[sp,#0]            ;319
0003b4  a366              ADR      r3,|L1.1360|
0003b6  0781              LSLS     r1,r0,#30             ;319
0003b8  d400              BMI      |L1.956|
0003ba  a366              ADR      r3,|L1.1364|
                  |L1.956|
0003bc  a264              ADR      r2,|L1.1360|
0003be  07c0              LSLS     r0,r0,#31             ;319
0003c0  d101              BNE      |L1.966|
0003c2  e0ce              B        |L1.1378|
                  |L1.964|
0003c4  e0c8              B        |L1.1368|
                  |L1.966|
0003c6  e0ce              B        |L1.1382|
                  |L1.968|
0003c8  494e4652          DCB      "INFRARED\\TV\\IR_",0
0003cc  41524544
0003d0  5c54565c
0003d4  49525f00
                  |L1.984|
0003d8  494e4652          DCB      "INFRARED\\HOME\\IR_",0
0003dc  41524544
0003e0  5c484f4d
0003e4  455c4952
0003e8  5f00    
0003ea  00                DCB      0
0003eb  00                DCB      0
                  |L1.1004|
                          DCD      ||cfg||+0x88
                  |L1.1008|
                          DCD      ir_state
                  |L1.1012|
0003f4  494e4652          DCB      "INFRARED\\AR\\SWON\\IR_",0
0003f8  41524544
0003fc  5c41525c
000400  53574f4e
000404  5c49525f
000408  00      
000409  00                DCB      0
00040a  00                DCB      0
00040b  00                DCB      0
                  |L1.1036|
00040c  494e4652          DCB      "INFRARED\\AR\\SWOFF\\IR_",0
000410  41524544
000414  5c41525c
000418  53574f46
00041c  465c4952
000420  5f00    
000422  00                DCB      0
000423  00                DCB      0
                  |L1.1060|
000424  25752e54          DCB      "%u.TXT",0
000428  585400  
00042b  00                DCB      0
                  |L1.1068|
00042c  494e4652          DCB      "INFRARED\\AR\\SWOUT\\IR_",0
000430  41524544
000434  5c41525c
000438  53574f55
00043c  545c4952
000440  5f00    
000442  00                DCB      0
000443  00                DCB      0
                  |L1.1092|
000444  434d4449          DCB      "CMDIR\\IR_",0
000448  525c4952
00044c  5f00    
00044e  00                DCB      0
00044f  00                DCB      0
                  |L1.1104|
000450  25732575          DCB      "%s%u.TXT",0
000454  2e545854
000458  00      
000459  00                DCB      0
00045a  00                DCB      0
00045b  00                DCB      0
                  |L1.1116|
00045c  49522e54          DCB      "IR.TXT",0
000460  585400  
000463  00                DCB      0
                  |L1.1124|
000464  5b536176          DCB      "[Save IR...addr:%s]\r",0
000468  65204952
00046c  2e2e2e61
000470  6464723a
000474  25735d0d
000478  00      
000479  00                DCB      0
00047a  00                DCB      0
00047b  00                DCB      0
                  |L1.1148|
                          DCD      __stdout
                  |L1.1152|
000480  7700              DCB      "w",0
000482  00                DCB      0
000483  00                DCB      0
                  |L1.1156|
000484  2575230d          DCB      "%u#\r\n",0
000488  0a00    
00048a  00                DCB      0
00048b  00                DCB      0
                  |L1.1164|
00048c  0d5b2573          DCB      "\r[%s]\r",0
000490  5d0d00  
000493  00                DCB      0
                  |L1.1172|
000494  7200              DCB      "r",0
000496  00                DCB      0
000497  00                DCB      0
                  |L1.1176|
                          DCD      ||.bss||
                  |L1.1180|
00049c  5b46696c          DCB      "[File not found]\r",0
0004a0  65206e6f
0004a4  7420666f
0004a8  756e645d
0004ac  0d00    
0004ae  00                DCB      0
0004af  00                DCB      0
                  |L1.1200|
0004b0  5b46696c          DCB      "[File closed]\r",0
0004b4  6520636c
0004b8  6f736564
0004bc  5d0d00  
0004bf  00                DCB      0
                  |L1.1216|
                          DCD      ||.data||
                  |L1.1220|
0004c4  494e4652          DCB      "INFRARED\\IR_",0
0004c8  41524544
0004cc  5c49525f
0004d0  00      
0004d1  00                DCB      0
0004d2  00                DCB      0
0004d3  00                DCB      0
                  |L1.1236|
                          DCD      PWM_freq_KHz
                  |L1.1240|
0004d8  34304b48          DCB      "40KHz (SONY/SIRC)",0
0004dc  7a202853
0004e0  4f4e592f
0004e4  53495243
0004e8  2900    
0004ea  00                DCB      0
0004eb  00                DCB      0
                  |L1.1260|
                          DCD      contEnableExtIr
                  |L1.1264|
                          DCD      0xcccccccd
                  |L1.1268|
                          DCD      0x408900cc
                  |L1.1272|
                          DCD      0x408e8f33
                  |L1.1276|
0004fc  33364b48          DCB      "36KHz (RC5/PHILIPS)",0
000500  7a202852
000504  43352f50
000508  48494c49
00050c  50532900
000510  00                DCB      0
000511  00                DCB      0
000512  00                DCB      0
000513  00                DCB      0
                  |L1.1300|
                          DCD      0x40a2becc
                  |L1.1304|
                          DCD      0x40a6e933
                  |L1.1308|
00051c  33364b48          DCB      "36KHz (RC6/PHILIPS)",0
000520  7a202852
000524  43362f50
000528  48494c49
00052c  50532900
000530  00                DCB      0
000531  00                DCB      0
000532  00                DCB      0
000533  00                DCB      0
                  |L1.1332|
000534  33384b48          DCB      "38KHz (DEFAULT)",0
000538  7a202844
00053c  45464155
000540  4c542900
000544  00                DCB      0
000545  00                DCB      0
000546  00                DCB      0
000547  00                DCB      0
                  |L1.1352|
                          DCD      timer1_counter
                  |L1.1356|
                          DCD      0x40008000
                  |L1.1360|
000550  53494d00          DCB      "SIM",0
                  |L1.1364|
000554  4ec34f00          DCB      "N",195,"O",0
                  |L1.1368|
000558  f8990000          LDRB     r0,[r9,#0]            ;290  ; last_port_ir
00055c  f7fffffe          BL       PWM_Start
000560  e6f6              B        |L1.848|
                  |L1.1378|
000562  f2af0210          ADR      r2,|L1.1364|
                  |L1.1382|
000566  a089              ADR      r0,|L1.1932|
000568  990b              LDR      r1,[sp,#0x2c]         ;319
00056a  f7fffffe          BL       __2printf
00056e  4891              LDR      r0,|L1.1972|
000570  f7fffffe          BL       fflush
000574  a901              ADD      r1,sp,#4              ;322
000576  a090              ADR      r0,|L1.1976|
000578  f7fffffe          BL       __2printf
00057c  4651              MOV      r1,r10                ;323
00057e  a092              ADR      r0,|L1.1992|
000580  f7fffffe          BL       __2printf
000584  a095              ADR      r0,|L1.2012|
000586  9909              LDR      r1,[sp,#0x24]         ;324
000588  f7fffffe          BL       __2printf
00058c  4889              LDR      r0,|L1.1972|
00058e  f7fffffe          BL       fflush
000592  2001              MOVS     r0,#1                 ;327
000594  e694              B        |L1.704|
;;;329    /****************************************************************************
                          ENDP

                  learn_ir PROC
;;;331    *****************************************************************************/
;;;332    char learn_ir(unsigned short addr, unsigned char channel, int index_file)
000596  e92d4ff7          PUSH     {r0-r2,r4-r11,lr}
;;;333    {
00059a  b082              SUB      sp,sp,#8
;;;334    	U32 pulse = 0, cont_exit=0;
00059c  2400              MOVS     r4,#0
;;;335    	U8 logic = 0, status = 1, erro = 0, learn_error = NO_ERROR; 
00059e  200f              MOVS     r0,#0xf
;;;336    
;;;337    	memset(ir,0xFFFF,sizeof(ir));	/*Reseta vetor onde o IR irá ser armazenados*/	
0005a0  9000              STR      r0,[sp,#0]
0005a2  4627              MOV      r7,r4                 ;334
0005a4  4625              MOV      r5,r4                 ;335
0005a6  2601              MOVS     r6,#1                 ;335
0005a8  46a0              MOV      r8,r4                 ;335
0005aa  f64f72ff          MOV      r2,#0xffff
0005ae  f44f7148          MOV      r1,#0x320
0005b2  4890              LDR      r0,|L1.2036|
0005b4  f7fffffe          BL       __aeabi_memset
;;;338    	beep(BEEP_PULSO);				/*Apena sinaliza a operação learn*/
0005b8  2000              MOVS     r0,#0
0005ba  f7fffffe          BL       beep
;;;339    	NVIC_DisableIRQ(EINT3_IRQn);	/*Desabilita a interrupção responsavel por detectar que um IR xegou no pino*/
0005be  2015              MOVS     r0,#0x15
0005c0  f7fffffe          BL       NVIC_DisableIRQ
;;;340    	disable_timer(0);				/*Desabilita timer 0*/
0005c4  2000              MOVS     r0,#0
0005c6  f7fffffe          BL       disable_timer
;;;341    
;;;342    	timer1_counter = 0;
0005ca  4b8b              LDR      r3,|L1.2040|
0005cc  2000              MOVS     r0,#0                 ;340
;;;343    	LPC_TIM1->TCR = 1;		/*Inicia contagem do timer 1*/	
0005ce  f8dfc22c          LDR      r12,|L1.2044|
0005d2  e9c30000          STRD     r0,r0,[r3,#0]
0005d6  f04f0a01          MOV      r10,#1
0005da  f8cca004          STR      r10,[r12,#4]
;;;344    
;;;345    	while(1)
;;;346    	{
;;;347    		if(LPC_TIM1->IR & (1<<0))	/*A contagem chegou ao fim e gerou interrupção?*/
;;;348    		{
;;;349    			LPC_TIM1->IR = 1;		/*Limpa flag da interrupção para uma nova contagem*/
;;;350    			timer1_counter++;		/*Incrementa contador*/
;;;351    		}
;;;352    		
;;;353    		if(timer1_counter * 4 >= 50000)	/*Passou-se aproximadamente 50ms?*/
;;;354    		{
;;;355    			LED_LEARN_TOG();			/*Led board sinalizando que o sistema está pronto pra ler o IR*/
0005de  f8df9220          LDR      r9,|L1.2048|
;;;356    			wdt_feed();
0005e2  f04f4e80          MOV      lr,#0x40000000
0005e6  4683              MOV      r11,r0                ;334
                  |L1.1512|
0005e8  f8dc0000          LDR      r0,[r12,#0]           ;347
0005ec  07c0              LSLS     r0,r0,#31             ;347
0005ee  d008              BEQ      |L1.1538|
0005f0  f8cca000          STR      r10,[r12,#0]          ;349
0005f4  e9d30100          LDRD     r0,r1,[r3,#0]         ;349
0005f8  1c40              ADDS     r0,r0,#1              ;349
0005fa  f1410100          ADC      r1,r1,#0              ;349
0005fe  e9c30100          STRD     r0,r1,[r3,#0]         ;349
                  |L1.1538|
000602  e9d30100          LDRD     r0,r1,[r3,#0]         ;349
000606  0089              LSLS     r1,r1,#2              ;353
000608  ea417190          ORR      r1,r1,r0,LSR #30      ;353
00060c  0080              LSLS     r0,r0,#2              ;353
00060e  f24c3250          MOV      r2,#0xc350            ;353
000612  1a80              SUBS     r0,r0,r2              ;353
000614  f1710000          SBCS     r0,r1,#0              ;353
000618  d323              BCC      |L1.1634|
00061a  f8d91074          LDR      r1,[r9,#0x74]         ;355
00061e  4648              MOV      r0,r9                 ;355
000620  0189              LSLS     r1,r1,#6              ;355
000622  d404              BMI      |L1.1582|
000624  6f81              LDR      r1,[r0,#0x78]         ;355
000626  f0417100          ORR      r1,r1,#0x2000000      ;355
00062a  6781              STR      r1,[r0,#0x78]         ;355
00062c  e003              B        |L1.1590|
                  |L1.1582|
00062e  6fc1              LDR      r1,[r0,#0x7c]         ;355
000630  f0417100          ORR      r1,r1,#0x2000000      ;355
000634  67c1              STR      r1,[r0,#0x7c]         ;355
                  |L1.1590|
000636  21aa              MOVS     r1,#0xaa
000638  f88e1008          STRB     r1,[lr,#8]
00063c  2155              MOVS     r1,#0x55
00063e  f88e1008          STRB     r1,[lr,#8]
000642  2000              MOVS     r0,#0
;;;357    			timer1_counter=0;
;;;358    			cont_exit++;
;;;359    			if(cont_exit > 200)				/*Passou-se 10s esperando IR? (50ms * 200 = 10s)*/
000644  e9c30000          STRD     r0,r0,[r3,#0]
000648  1c7f              ADDS     r7,r7,#1              ;358
00064a  2fc8              CMP      r7,#0xc8
00064c  d909              BLS      |L1.1634|
;;;360    			{
;;;361    				LPC_TIM1->TCR = 0;			/*Desabilita Timer 1*/
00064e  f8ccb004          STR      r11,[r12,#4]
;;;362    				learn_error = ERROR_TIMEOUT;	
000652  2403              MOVS     r4,#3
;;;363    				printf("[Timeout learn]\r");
000654  a06b              ADR      r0,|L1.2052|
000656  f7fffffe          BL       __2printf
;;;364    				fflush(stdout);
00065a  4856              LDR      r0,|L1.1972|
00065c  f7fffffe          BL       fflush
;;;365    				erro = __TRUE;
;;;366    				break;
000660  e06a              B        |L1.1848|
                  |L1.1634|
;;;367    			}
;;;368    		}
;;;369    
;;;370    		/*Fica contando tempo de espera enquanto nao recebe nenhum sinal de IR*/
;;;371    		if(RECEIVE_IR())
000662  f8d90054          LDR      r0,[r9,#0x54]
000666  0700              LSLS     r0,r0,#28
000668  d4be              BMI      |L1.1512|
;;;372    			continue;
;;;373    
;;;374    		LPC_TIM1->TCR = 0;	/*Desabilita Timer*/
00066a  f8ccb004          STR      r11,[r12,#4]
;;;375    		wdt_feed();
00066e  22aa              MOVS     r2,#0xaa
000670  f88e2008          STRB     r2,[lr,#8]
000674  2255              MOVS     r2,#0x55
000676  f88e2008          STRB     r2,[lr,#8]
;;;376    
;;;377    		ir_counter = 0;		/*Reseta contador do IR*/
00067a  4f67              LDR      r7,|L1.2072|
;;;378    		LPC_TIM1->IR = 1;	/*Limpa flag da interrupção*/
00067c  2201              MOVS     r2,#1
00067e  f8a7b002          STRH     r11,[r7,#2]           ;377
000682  f8cc2000          STR      r2,[r12,#0]
;;;379    		LPC_TIM1->TCR = 2;	/*Reseta contador do timer*/
000686  2002              MOVS     r0,#2
000688  f8cc0004          STR      r0,[r12,#4]
;;;380    		LPC_TIM1->TCR = 1;	/*Inicia a contagem*/
00068c  f8cc2004          STR      r2,[r12,#4]
000690  46da              MOV      r10,r11               ;334
                  |L1.1682|
;;;381    		while(1)	
;;;382    		{	 		
;;;383    			/*Verifica se houve interrupção para fazer o incremento do contador IR*/ 	
;;;384    			if(LPC_TIM1->IR & (1<<0))
000692  485a              LDR      r0,|L1.2044|
000694  6801              LDR      r1,[r0,#0]
000696  07c9              LSLS     r1,r1,#31
000698  d005              BEQ      |L1.1702|
;;;385    			{
;;;386    				LPC_TIM1->IR = 1;
00069a  2101              MOVS     r1,#1
00069c  6001              STR      r1,[r0,#0]
;;;387    				ir_counter++;
00069e  8878              LDRH     r0,[r7,#2]  ; ir_counter
0006a0  f1000001          ADD      r0,r0,#1
0006a4  8078              STRH     r0,[r7,#2]
                  |L1.1702|
;;;388    			}
;;;389    
;;;390    			if(status)	/*Ainda está acontecendo a leitura do IR?*/
0006a6  b39e              CBZ      r6,|L1.1808|
;;;391    			{
;;;392    				if(!RECEIVE_IR())	/*IR está em low?*/	
0006a8  f8d90054          LDR      r0,[r9,#0x54]
0006ac  0700              LSLS     r0,r0,#28
0006ae  d402              BMI      |L1.1718|
;;;393    				{
;;;394    					if(logic)	
0006b0  b125              CBZ      r5,|L1.1724|
;;;395    					{
;;;396    						logic = __FALSE;
0006b2  2500              MOVS     r5,#0
;;;397    						pulse++;  
0006b4  e001              B        |L1.1722|
                  |L1.1718|
;;;398    					}
;;;399    				}else
;;;400    				{
;;;401    					if(!logic)
0006b6  b90d              CBNZ     r5,|L1.1724|
;;;402    					{
;;;403    						logic = __TRUE;
0006b8  2501              MOVS     r5,#1
                  |L1.1722|
;;;404    						pulse++;  
0006ba  1c64              ADDS     r4,r4,#1
                  |L1.1724|
;;;405    					}
;;;406    				}
;;;407    				if(pulse >= MAX_QTD_PULSOS-1)	/*Já ocorreram o numero máximo de pulsos?*/
0006bc  f5b47fc7          CMP      r4,#0x18e
0006c0  d90c              BLS      |L1.1756|
;;;408    				{
;;;409    					/*Overflow dos pulsos no IR. Reseta contadores e vetor do IR*/	
;;;410    					memset(ir,0xFFFF,sizeof(ir));
0006c2  f64f72ff          MOV      r2,#0xffff
0006c6  f44f7148          MOV      r1,#0x320
0006ca  484a              LDR      r0,|L1.2036|
0006cc  f7fffffe          BL       __aeabi_memset
;;;411    					ir_counter = 0;
;;;412    					pulse = 0;
0006d0  2400              MOVS     r4,#0
;;;413    					status = __FALSE;		/*Sinaliza que a leitura do IR já terminou*/
;;;414    					erro = __TRUE;			/*Sinaliza erro (Overflow de pulsos)*/	
0006d2  2001              MOVS     r0,#1
0006d4  f8a7a002          STRH     r10,[r7,#2]           ;411
0006d8  4626              MOV      r6,r4                 ;413
0006da  4680              MOV      r8,r0
                  |L1.1756|
;;;415    				}
;;;416    						 		 
;;;417    				ir[pulse] = ((ir[pulse] == 0xFFFF) ? 0 : ir[pulse]) + ir_counter;	/*Vai incrementando os pulsos do IR*/
0006dc  4b45              LDR      r3,|L1.2036|
0006de  46d4              MOV      r12,r10
0006e0  4650              MOV      r0,r10
0006e2  f8331014          LDRH     r1,[r3,r4,LSL #1]
0006e6  f5a1427f          SUB      r2,r1,#0xff00
0006ea  3aff              SUBS     r2,r2,#0xff
0006ec  d000              BEQ      |L1.1776|
0006ee  4608              MOV      r0,r1
                  |L1.1776|
0006f0  8879              LDRH     r1,[r7,#2]  ; ir_counter
0006f2  4408              ADD      r0,r0,r1
0006f4  b280              UXTH     r0,r0
;;;418    				ir_counter = 0;											/*Reseta para um novo incremento*/
;;;419    				if(ir[pulse] * 4 >= TIMEOUT_END_IR * 1000 /*120000*/) /*Maior que 120ms?*/
0006f6  4949              LDR      r1,|L1.2076|
0006f8  f8230014          STRH     r0,[r3,r4,LSL #1]     ;417
0006fc  f8a7c002          STRH     r12,[r7,#2]           ;418
000700  ebb10f80          CMP      r1,r0,LSL #2
000704  d805              BHI      |L1.1810|
;;;420    				{	
;;;421    					ir[pulse] = 0xFFFF; /*Reseta o ultimo pulso (timeout)*/
000706  493b              LDR      r1,|L1.2036|
000708  f64f70ff          MOV      r0,#0xffff
00070c  f8210014          STRH     r0,[r1,r4,LSL #1]
                  |L1.1808|
;;;422    					status = __FALSE;	/*Sinaliza que a leitura do IR já terminou*/	
000710  e001              B        |L1.1814|
                  |L1.1810|
;;;423    				}
;;;424    			}
;;;425    			
;;;426    			/*Sai do laço se o IR foi armazenado*/
;;;427    			if(!status)
000712  2e00              CMP      r6,#0
000714  d1bd              BNE      |L1.1682|
                  |L1.1814|
;;;428    				break;
;;;429    		}
;;;430    		LPC_TIM1->TCR = 0;	/*Desabilita Timer 1*/
000716  4939              LDR      r1,|L1.2044|
000718  f8c1a004          STR      r10,[r1,#4]
;;;431    
;;;432    		if(pulse > 10 && erro == __FALSE)	/*Não houve erro?*/
00071c  2c0a              CMP      r4,#0xa
00071e  d902              BLS      |L1.1830|
000720  f1b80f00          CMP      r8,#0
000724  d011              BEQ      |L1.1866|
                  |L1.1830|
;;;433    		{
;;;434    			printf("[IR Receiver...Pulses:%u...ADDR:%u]\r\r",pulse,addr);
;;;435    			fflush(stdout);
;;;436    			/*Chama função que irá salvar o IR lido no endereço especificado*/
;;;437    			if(save_ir(ir,addr,channel,index_file) == NO_ERROR)
;;;438    				learn_error = NO_ERROR;			/*IR OK*/
;;;439    			else
;;;440    				learn_error = ERROR_NOT_SAVED;	
;;;441    										
;;;442    		}else
;;;443    		{
;;;444    			printf("[Error Learn %u..Try again..Pulses:%u]\r",learn_error,pulse);
000726  4622              MOV      r2,r4
000728  a03d              ADR      r0,|L1.2080|
00072a  9900              LDR      r1,[sp,#0]
00072c  f7fffffe          BL       __2printf
;;;445    			fflush(stdout);
000730  4820              LDR      r0,|L1.1972|
000732  f7fffffe          BL       fflush
;;;446    			learn_error = ERROR_RECEIVER_IR;	/*Falha na recepção de IR*/	
000736  2404              MOVS     r4,#4
                  |L1.1848|
;;;447    		}
;;;448    		break;
;;;449    	}
;;;450    
;;;451    	enable_timer(0);
000738  2000              MOVS     r0,#0
00073a  f7fffffe          BL       enable_timer
;;;452    	contEnableExtIr = 0;
00073e  4942              LDR      r1,|L1.2120|
;;;453    
;;;454    	return learn_error;
000740  4620              MOV      r0,r4
000742  f8c1b000          STR      r11,[r1,#0]  ; contEnableExtIr
;;;455    }
000746  b005              ADD      sp,sp,#0x14
000748  e5bb              B        |L1.706|
                  |L1.1866|
00074a  4621              MOV      r1,r4                 ;434
00074c  a03f              ADR      r0,|L1.2124|
00074e  9a02              LDR      r2,[sp,#8]            ;434
000750  f7fffffe          BL       __2printf
000754  4817              LDR      r0,|L1.1972|
000756  f7fffffe          BL       fflush
00075a  a902              ADD      r1,sp,#8              ;435
00075c  c90d              LDM      r1!,{r0,r2,r3}        ;435
00075e  b201              SXTH     r1,r0                 ;437
000760  4824              LDR      r0,|L1.2036|
000762  f7fffffe          BL       save_ir
000766  280f              CMP      r0,#0xf               ;437
000768  d001              BEQ      |L1.1902|
00076a  240b              MOVS     r4,#0xb               ;440
00076c  e7e4              B        |L1.1848|
                  |L1.1902|
00076e  240f              MOVS     r4,#0xf               ;438
000770  e7e2              B        |L1.1848|
;;;456    #endif
                          ENDP

                  NVIC_DisableIRQ PROC
;;;1109    */
;;;1110   static __INLINE void NVIC_DisableIRQ(IRQn_Type IRQn)
000772  f000021f          AND      r2,r0,#0x1f
;;;1111   {
;;;1112     NVIC->ICER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* disable interrupt */
000776  2101              MOVS     r1,#1
000778  4091              LSLS     r1,r1,r2
00077a  0940              LSRS     r0,r0,#5
00077c  f04f22e0          MOV      r2,#0xe000e000
000780  eb020080          ADD      r0,r2,r0,LSL #2
000784  f8c01180          STR      r1,[r0,#0x180]
;;;1113   }
000788  4770              BX       lr
;;;1114   
                          ENDP

00078a  0000              DCW      0x0000
                  |L1.1932|
00078c  0d2a2a2a          DCB      "\r***\r[IR:%u..Port:0(%s) 1(%s) 2(%s)]\r",0
000790  0d5b4952
000794  3a25752e
000798  2e506f72
00079c  743a3028
0007a0  25732920
0007a4  31282573
0007a8  29203228
0007ac  2573295d
0007b0  0d00    
0007b2  00                DCB      0
0007b3  00                DCB      0
                  |L1.1972|
                          DCD      __stdout
                  |L1.1976|
0007b8  46726571          DCB      "Frequencia: %s\r",0
0007bc  75656e63
0007c0  69613a20
0007c4  25730d00
                  |L1.1992|
0007c8  4c656164          DCB      "Lead IN ON: %uus\r",0
0007cc  20494e20
0007d0  4f4e3a20
0007d4  25757573
0007d8  0d00    
0007da  00                DCB      0
0007db  00                DCB      0
                  |L1.2012|
0007dc  4c656164          DCB      "Lead IN OFF: %uus\r***\r\r",0
0007e0  20494e20
0007e4  4f46463a
0007e8  20257575
0007ec  730d2a2a
0007f0  2a0d0d00
                  |L1.2036|
                          DCD      ||.bss||
                  |L1.2040|
                          DCD      timer1_counter
                  |L1.2044|
                          DCD      0x40008000
                  |L1.2048|
                          DCD      0x2009c000
                  |L1.2052|
000804  5b54696d          DCB      "[Timeout learn]\r",0
000808  656f7574
00080c  206c6561
000810  726e5d0d
000814  00      
000815  00                DCB      0
000816  00                DCB      0
000817  00                DCB      0
                  |L1.2072|
                          DCD      ||.data||
                  |L1.2076|
                          DCD      0x0001d4c0
                  |L1.2080|
000820  5b457272          DCB      "[Error Learn %u..Try again..Pulses:%u]\r",0
000824  6f72204c
000828  6561726e
00082c  2025752e
000830  2e547279
000834  20616761
000838  696e2e2e
00083c  50756c73
000840  65733a25
000844  755d0d00
                  |L1.2120|
                          DCD      contEnableExtIr
                  |L1.2124|
00084c  5b495220          DCB      "[IR Receiver...Pulses:%u...ADDR:%u]\r\r",0
000850  52656365
000854  69766572
000858  2e2e2e50
00085c  756c7365
000860  733a2575
000864  2e2e2e41
000868  4444523a
00086c  25755d0d
000870  0d00    
000872  00                DCB      0
000873  00                DCB      0

                          AREA ||.bss||, DATA, NOINIT, ALIGN=1

                  ||ir||
                          %        800

                          AREA ||area_number.4||, DATA, NOINIT, ALIGN=1

                          EXPORTAS ||area_number.4||, ||.bss||
                  ir_cmp
                          %        800

                          AREA ||.data||, DATA, ALIGN=1

                  last_port_ir
000000  0000              DCB      0x00,0x00
                  ir_counter
000002  0000              DCB      0x00,0x00
